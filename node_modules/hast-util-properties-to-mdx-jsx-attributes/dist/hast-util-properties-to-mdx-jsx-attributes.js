import { stringify as commas } from 'comma-separated-tokens';
import { valueToEstree } from 'estree-util-value-to-estree';
import { find, hastToReact, html, svg } from 'property-information';
import { stringify as spaces } from 'space-separated-tokens';
import styleToObject from 'style-to-js';
/**
 * Transform [hast](https://github.com/syntax-tree/hast)
 * [properties](https://github.com/syntax-tree/hast#properties) to a list of
 * [`mdxJsxAttribute`](https://github.com/syntax-tree/mdast-util-mdx-jsx#mdxjsxattribute) nodes.
 *
 * @param properties
 *   The hast properties to transform.
 * @param options
 *   Additional options to pass.
 * @returns
 *   The hast properties as a list of `mdxJsxAttribute` nodes.
 */
export function propertiesToMdxJsxAttributes(properties, options) {
    const schema = options?.space === 'svg' ? svg : html;
    const attributes = [];
    for (let name in properties) {
        if (!Object.hasOwn(properties, name)) {
            continue;
        }
        const info = find(schema, name);
        const original = properties[name];
        name = info.property;
        if (options?.elementAttributeNameCase !== 'html' &&
            info.space &&
            Object.hasOwn(hastToReact, name)) {
            name = hastToReact[name];
        }
        if (original == null) {
            continue;
        }
        if (original === false) {
            continue;
        }
        if (Number.isNaN(original)) {
            continue;
        }
        if (!original && info.boolean) {
            continue;
        }
        let value = Array.isArray(original)
            ? info.commaSeparated
                ? commas(original)
                : spaces(original)
            : original === true
                ? null
                : String(original);
        if (options?.transform) {
            value = options.transform(name, value, original);
        }
        if (value == null) {
            attributes.push({
                type: 'mdxJsxAttribute',
                name
            });
        }
        else if (typeof value === 'object') {
            attributes.push({
                type: 'mdxJsxAttribute',
                name,
                value: {
                    type: 'mdxJsxAttributeValueExpression',
                    value: '',
                    data: {
                        estree: {
                            type: 'Program',
                            sourceType: 'module',
                            body: [{ type: 'ExpressionStatement', expression: value }]
                        }
                    }
                }
            });
        }
        else if (name === 'style') {
            attributes.push({
                type: 'mdxJsxAttribute',
                name,
                value: {
                    type: 'mdxJsxAttributeValueExpression',
                    value: '',
                    data: {
                        estree: {
                            type: 'Program',
                            sourceType: 'module',
                            body: [
                                { type: 'ExpressionStatement', expression: valueToEstree(styleToObject(value)) }
                            ]
                        }
                    }
                }
            });
        }
        else {
            attributes.push({
                type: 'mdxJsxAttribute',
                name,
                value
            });
        }
    }
    return attributes;
}
//# sourceMappingURL=hast-util-properties-to-mdx-jsx-attributes.js.map