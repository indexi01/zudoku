import * as o from "react";
var _ = {}, ue;
function Me() {
  if (ue) return _;
  ue = 1, Object.defineProperty(_, "__esModule", { value: !0 }), _.parse = c, _.serialize = s;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, n = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, a = /^[\u0020-\u003A\u003D-\u007E]*$/, r = Object.prototype.toString, i = /* @__PURE__ */ (() => {
    const d = function() {
    };
    return d.prototype = /* @__PURE__ */ Object.create(null), d;
  })();
  function c(d, v) {
    const f = new i(), w = d.length;
    if (w < 2)
      return f;
    const E = (v == null ? void 0 : v.decode) || h;
    let m = 0;
    do {
      const g = d.indexOf("=", m);
      if (g === -1)
        break;
      const y = d.indexOf(";", m), R = y === -1 ? w : y;
      if (g > R) {
        m = d.lastIndexOf(";", g - 1) + 1;
        continue;
      }
      const x = u(d, m, g), C = l(d, g, x), $ = d.slice(x, C);
      if (f[$] === void 0) {
        let P = u(d, g + 1, R), S = l(d, R, P);
        const D = E(d.slice(P, S));
        f[$] = D;
      }
      m = R + 1;
    } while (m < w);
    return f;
  }
  function u(d, v, f) {
    do {
      const w = d.charCodeAt(v);
      if (w !== 32 && w !== 9)
        return v;
    } while (++v < f);
    return f;
  }
  function l(d, v, f) {
    for (; v > f; ) {
      const w = d.charCodeAt(--v);
      if (w !== 32 && w !== 9)
        return v + 1;
    }
    return f;
  }
  function s(d, v, f) {
    const w = (f == null ? void 0 : f.encode) || encodeURIComponent;
    if (!e.test(d))
      throw new TypeError(`argument name is invalid: ${d}`);
    const E = w(v);
    if (!t.test(E))
      throw new TypeError(`argument val is invalid: ${v}`);
    let m = d + "=" + E;
    if (!f)
      return m;
    if (f.maxAge !== void 0) {
      if (!Number.isInteger(f.maxAge))
        throw new TypeError(`option maxAge is invalid: ${f.maxAge}`);
      m += "; Max-Age=" + f.maxAge;
    }
    if (f.domain) {
      if (!n.test(f.domain))
        throw new TypeError(`option domain is invalid: ${f.domain}`);
      m += "; Domain=" + f.domain;
    }
    if (f.path) {
      if (!a.test(f.path))
        throw new TypeError(`option path is invalid: ${f.path}`);
      m += "; Path=" + f.path;
    }
    if (f.expires) {
      if (!p(f.expires) || !Number.isFinite(f.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${f.expires}`);
      m += "; Expires=" + f.expires.toUTCString();
    }
    if (f.httpOnly && (m += "; HttpOnly"), f.secure && (m += "; Secure"), f.partitioned && (m += "; Partitioned"), f.priority)
      switch (typeof f.priority == "string" ? f.priority.toLowerCase() : void 0) {
        case "low":
          m += "; Priority=Low";
          break;
        case "medium":
          m += "; Priority=Medium";
          break;
        case "high":
          m += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${f.priority}`);
      }
    if (f.sameSite)
      switch (typeof f.sameSite == "string" ? f.sameSite.toLowerCase() : f.sameSite) {
        case !0:
        case "strict":
          m += "; SameSite=Strict";
          break;
        case "lax":
          m += "; SameSite=Lax";
          break;
        case "none":
          m += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${f.sameSite}`);
      }
    return m;
  }
  function h(d) {
    if (d.indexOf("%") === -1)
      return d;
    try {
      return decodeURIComponent(d);
    } catch {
      return d;
    }
  }
  function p(d) {
    return r.call(d) === "[object Date]";
  }
  return _;
}
Me();
/**
 * react-router v7.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function b(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function L(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function B({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function Y(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let a = e.indexOf("?");
    a >= 0 && (t.search = e.substring(a), e = e.substring(0, a)), e && (t.pathname = e);
  }
  return t;
}
function pe(e, t, n = "/") {
  return De(e, t, n, !1);
}
function De(e, t, n, a) {
  let r = typeof t == "string" ? Y(t) : t, i = M(r.pathname || "/", n);
  if (i == null)
    return null;
  let c = ve(e);
  Ie(c);
  let u = null;
  for (let l = 0; u == null && l < c.length; ++l) {
    let s = ye(i);
    u = Ve(
      c[l],
      s,
      a
    );
  }
  return u;
}
function ve(e, t = [], n = [], a = "") {
  let r = (i, c, u) => {
    let l = {
      relativePath: u === void 0 ? i.path || "" : u,
      caseSensitive: i.caseSensitive === !0,
      childrenIndex: c,
      route: i
    };
    l.relativePath.startsWith("/") && (b(
      l.relativePath.startsWith(a),
      `Absolute route path "${l.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
    ), l.relativePath = l.relativePath.slice(a.length));
    let s = A([a, l.relativePath]), h = n.concat(l);
    i.children && i.children.length > 0 && (b(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      i.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${s}".`
    ), ve(i.children, t, h, s)), !(i.path == null && !i.index) && t.push({
      path: s,
      score: We(s, i.index),
      routesMeta: h
    });
  };
  return e.forEach((i, c) => {
    var u;
    if (i.path === "" || !((u = i.path) != null && u.includes("?")))
      r(i, c);
    else
      for (let l of ge(i.path))
        r(i, c, l);
  }), t;
}
function ge(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...a] = t, r = n.endsWith("?"), i = n.replace(/\?$/, "");
  if (a.length === 0)
    return r ? [i, ""] : [i];
  let c = ge(a.join("/")), u = [];
  return u.push(
    ...c.map(
      (l) => l === "" ? i : [i, l].join("/")
    )
  ), r && u.push(...c), u.map(
    (l) => e.startsWith("/") && l === "" ? "/" : l
  );
}
function Ie(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : ze(
      t.routesMeta.map((a) => a.childrenIndex),
      n.routesMeta.map((a) => a.childrenIndex)
    )
  );
}
var Oe = /^:[\w-]+$/, Fe = 3, _e = 2, Ue = 1, Be = 10, He = -2, ce = (e) => e === "*";
function We(e, t) {
  let n = e.split("/"), a = n.length;
  return n.some(ce) && (a += He), t && (a += _e), n.filter((r) => !ce(r)).reduce(
    (r, i) => r + (Oe.test(i) ? Fe : i === "" ? Ue : Be),
    a
  );
}
function ze(e, t) {
  return e.length === t.length && e.slice(0, -1).every((a, r) => a === t[r]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function Ve(e, t, n = !1) {
  let { routesMeta: a } = e, r = {}, i = "/", c = [];
  for (let u = 0; u < a.length; ++u) {
    let l = a[u], s = u === a.length - 1, h = i === "/" ? t : t.slice(i.length) || "/", p = H(
      { path: l.relativePath, caseSensitive: l.caseSensitive, end: s },
      h
    ), d = l.route;
    if (!p && s && n && !a[a.length - 1].route.index && (p = H(
      {
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: !1
      },
      h
    )), !p)
      return null;
    Object.assign(r, p.params), c.push({
      // TODO: Can this as be avoided?
      params: r,
      pathname: A([i, p.pathname]),
      pathnameBase: qe(
        A([i, p.pathnameBase])
      ),
      route: d
    }), p.pathnameBase !== "/" && (i = A([i, p.pathnameBase]));
  }
  return c;
}
function H(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, a] = je(
    e.path,
    e.caseSensitive,
    e.end
  ), r = t.match(n);
  if (!r) return null;
  let i = r[0], c = i.replace(/(.)\/+$/, "$1"), u = r.slice(1);
  return {
    params: a.reduce(
      (s, { paramName: h, isOptional: p }, d) => {
        if (h === "*") {
          let f = u[d] || "";
          c = i.slice(0, i.length - f.length).replace(/(.)\/+$/, "$1");
        }
        const v = u[d];
        return p && !v ? s[h] = void 0 : s[h] = (v || "").replace(/%2F/g, "/"), s;
      },
      {}
    ),
    pathname: i,
    pathnameBase: c,
    pattern: e
  };
}
function je(e, t = !1, n = !0) {
  L(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let a = [], r = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (c, u, l) => (a.push({ paramName: u, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
  );
  return e.endsWith("*") ? (a.push({ paramName: "*" }), r += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? r += "\\/*$" : e !== "" && e !== "/" && (r += "(?:(?=\\/|$))"), [new RegExp(r, t ? void 0 : "i"), a];
}
function ye(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return L(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function M(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, a = e.charAt(n);
  return a && a !== "/" ? null : e.slice(n) || "/";
}
function Ye(e, t = "/") {
  let {
    pathname: n,
    search: a = "",
    hash: r = ""
  } = typeof e == "string" ? Y(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : Je(n, t) : t,
    search: Ge(a),
    hash: Xe(r)
  };
}
function Je(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((r) => {
    r === ".." ? n.length > 1 && n.pop() : r !== "." && n.push(r);
  }), n.length > 1 ? n.join("/") : "/";
}
function G(e, t, n, a) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    a
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function Ke(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function Z(e) {
  let t = Ke(e);
  return t.map(
    (n, a) => a === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function ee(e, t, n, a = !1) {
  let r;
  typeof e == "string" ? r = Y(e) : (r = { ...e }, b(
    !r.pathname || !r.pathname.includes("?"),
    G("?", "pathname", "search", r)
  ), b(
    !r.pathname || !r.pathname.includes("#"),
    G("#", "pathname", "hash", r)
  ), b(
    !r.search || !r.search.includes("#"),
    G("#", "search", "hash", r)
  ));
  let i = e === "" || r.pathname === "", c = i ? "/" : r.pathname, u;
  if (c == null)
    u = n;
  else {
    let p = t.length - 1;
    if (!a && c.startsWith("..")) {
      let d = c.split("/");
      for (; d[0] === ".."; )
        d.shift(), p -= 1;
      r.pathname = d.join("/");
    }
    u = p >= 0 ? t[p] : "/";
  }
  let l = Ye(r, u), s = c && c !== "/" && c.endsWith("/"), h = (i || c === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (s || h) && (l.pathname += "/"), l;
}
var A = (e) => e.join("/").replace(/\/\/+/g, "/"), qe = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), Ge = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Xe = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, an = (e, t = 302) => {
  let n = t;
  typeof n == "number" ? n = { status: n } : typeof n.status > "u" && (n.status = 302);
  let a = new Headers(n.headers);
  return a.set("Location", e), new Response(null, { ...n, headers: a });
};
function we(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
var Ee = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  Ee
);
var Qe = [
  "GET",
  ...Ee
];
new Set(Qe);
var I = o.createContext(null);
I.displayName = "DataRouter";
var F = o.createContext(null);
F.displayName = "DataRouterState";
var J = o.createContext({
  isTransitioning: !1
});
J.displayName = "ViewTransition";
var te = o.createContext(
  /* @__PURE__ */ new Map()
);
te.displayName = "Fetchers";
var Ze = o.createContext(null);
Ze.displayName = "Await";
var T = o.createContext(
  null
);
T.displayName = "Navigation";
var K = o.createContext(
  null
);
K.displayName = "Location";
var k = o.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
k.displayName = "Route";
var ne = o.createContext(null);
ne.displayName = "RouteError";
function et(e, { relative: t } = {}) {
  b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: a } = o.useContext(T), { hash: r, pathname: i, search: c } = W(e, { relative: t }), u = i;
  return n !== "/" && (u = i === "/" ? n : A([n, i])), a.createHref({ pathname: u, search: c, hash: r });
}
function O() {
  return o.useContext(K) != null;
}
function N() {
  return b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), o.useContext(K).location;
}
function on(e) {
  b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  );
  let { pathname: t } = N();
  return o.useMemo(
    () => H(e, ye(t)),
    [t, e]
  );
}
var xe = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function Re(e) {
  o.useContext(T).static || o.useLayoutEffect(e);
}
function re() {
  let { isDataRoute: e } = o.useContext(k);
  return e ? ht() : tt();
}
function tt() {
  b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = o.useContext(I), { basename: t, navigator: n } = o.useContext(T), { matches: a } = o.useContext(k), { pathname: r } = N(), i = JSON.stringify(Z(a)), c = o.useRef(!1);
  return Re(() => {
    c.current = !0;
  }), o.useCallback(
    (l, s = {}) => {
      if (L(c.current, xe), !c.current) return;
      if (typeof l == "number") {
        n.go(l);
        return;
      }
      let h = ee(
        l,
        JSON.parse(i),
        r,
        s.relative === "path"
      );
      e == null && t !== "/" && (h.pathname = h.pathname === "/" ? t : A([t, h.pathname])), (s.replace ? n.replace : n.push)(
        h,
        s.state,
        s
      );
    },
    [
      t,
      n,
      i,
      r,
      e
    ]
  );
}
var nt = o.createContext(null);
function rt(e) {
  let t = o.useContext(k).outlet;
  return t && /* @__PURE__ */ o.createElement(nt.Provider, { value: e }, t);
}
function ln() {
  let { matches: e } = o.useContext(k), t = e[e.length - 1];
  return t ? t.params : {};
}
function W(e, { relative: t } = {}) {
  let { matches: n } = o.useContext(k), { pathname: a } = N(), r = JSON.stringify(Z(n));
  return o.useMemo(
    () => ee(
      e,
      JSON.parse(r),
      a,
      t === "path"
    ),
    [e, r, a, t]
  );
}
function be(e, t, n, a) {
  b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: r, static: i } = o.useContext(T), { matches: c } = o.useContext(k), u = c[c.length - 1], l = u ? u.params : {}, s = u ? u.pathname : "/", h = u ? u.pathnameBase : "/", p = u && u.route;
  {
    let g = p && p.path || "";
    Pe(
      s,
      !p || g.endsWith("*") || g.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${s}" (under <Route path="${g}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${g}"> to <Route path="${g === "/" ? "*" : `${g}/*`}">.`
    );
  }
  let d = N(), v;
  v = d;
  let f = v.pathname || "/", w = f;
  if (h !== "/") {
    let g = h.replace(/^\//, "").split("/");
    w = "/" + f.replace(/^\//, "").split("/").slice(g.length).join("/");
  }
  let E = !i && n && n.matches && n.matches.length > 0 ? n.matches : pe(e, { pathname: w });
  return L(
    p || E != null,
    `No routes matched location "${v.pathname}${v.search}${v.hash}" `
  ), L(
    E == null || E[E.length - 1].route.element !== void 0 || E[E.length - 1].route.Component !== void 0 || E[E.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), st(
    E && E.map(
      (g) => Object.assign({}, g, {
        params: Object.assign({}, l, g.params),
        pathname: A([
          h,
          // Re-encode pathnames that were decoded inside matchRoutes
          r.encodeLocation ? r.encodeLocation(g.pathname).pathname : g.pathname
        ]),
        pathnameBase: g.pathnameBase === "/" ? h : A([
          h,
          // Re-encode pathnames that were decoded inside matchRoutes
          r.encodeLocation ? r.encodeLocation(g.pathnameBase).pathname : g.pathnameBase
        ])
      })
    ),
    c,
    n,
    a
  );
}
function at() {
  let e = dt(), t = we(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, a = "rgba(200,200,200, 0.5)", r = { padding: "0.5rem", backgroundColor: a }, i = { padding: "2px 4px", backgroundColor: a }, c = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), c = /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement("p", null, "ðŸ’¿ Hey developer ðŸ‘‹"), /* @__PURE__ */ o.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ o.createElement("code", { style: i }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ o.createElement("code", { style: i }, "errorElement"), " prop on your route.")), /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ o.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ o.createElement("pre", { style: r }, n) : null, c);
}
var it = /* @__PURE__ */ o.createElement(at, null), ot = class extends o.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ o.createElement(k.Provider, { value: this.props.routeContext }, /* @__PURE__ */ o.createElement(
      ne.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function lt({ routeContext: e, match: t, children: n }) {
  let a = o.useContext(I);
  return a && a.static && a.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (a.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ o.createElement(k.Provider, { value: e }, n);
}
function st(e, t = [], n = null, a = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let r = e, i = n == null ? void 0 : n.errors;
  if (i != null) {
    let l = r.findIndex(
      (s) => s.route.id && (i == null ? void 0 : i[s.route.id]) !== void 0
    );
    b(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        i
      ).join(",")}`
    ), r = r.slice(
      0,
      Math.min(r.length, l + 1)
    );
  }
  let c = !1, u = -1;
  if (n)
    for (let l = 0; l < r.length; l++) {
      let s = r[l];
      if ((s.route.HydrateFallback || s.route.hydrateFallbackElement) && (u = l), s.route.id) {
        let { loaderData: h, errors: p } = n, d = s.route.loader && !h.hasOwnProperty(s.route.id) && (!p || p[s.route.id] === void 0);
        if (s.route.lazy || d) {
          c = !0, u >= 0 ? r = r.slice(0, u + 1) : r = [r[0]];
          break;
        }
      }
    }
  return r.reduceRight((l, s, h) => {
    let p, d = !1, v = null, f = null;
    n && (p = i && s.route.id ? i[s.route.id] : void 0, v = s.route.errorElement || it, c && (u < 0 && h === 0 ? (Pe(
      "route-fallback",
      !1,
      "No `HydrateFallback` element provided to render during initial hydration"
    ), d = !0, f = null) : u === h && (d = !0, f = s.route.hydrateFallbackElement || null)));
    let w = t.concat(r.slice(0, h + 1)), E = () => {
      let m;
      return p ? m = v : d ? m = f : s.route.Component ? m = /* @__PURE__ */ o.createElement(s.route.Component, null) : s.route.element ? m = s.route.element : m = l, /* @__PURE__ */ o.createElement(
        lt,
        {
          match: s,
          routeContext: {
            outlet: l,
            matches: w,
            isDataRoute: n != null
          },
          children: m
        }
      );
    };
    return n && (s.route.ErrorBoundary || s.route.errorElement || h === 0) ? /* @__PURE__ */ o.createElement(
      ot,
      {
        location: n.location,
        revalidation: n.revalidation,
        component: v,
        error: p,
        children: E(),
        routeContext: { outlet: null, matches: w, isDataRoute: !0 }
      }
    ) : E();
  }, null);
}
function ae(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function ut(e) {
  let t = o.useContext(I);
  return b(t, ae(e)), t;
}
function Ce(e) {
  let t = o.useContext(F);
  return b(t, ae(e)), t;
}
function ct(e) {
  let t = o.useContext(k);
  return b(t, ae(e)), t;
}
function ie(e) {
  let t = ct(e), n = t.matches[t.matches.length - 1];
  return b(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function ft() {
  return ie(
    "useRouteId"
    /* UseRouteId */
  );
}
function sn() {
  return Ce(
    "useNavigation"
    /* UseNavigation */
  ).navigation;
}
function dt() {
  var a;
  let e = o.useContext(ne), t = Ce(
    "useRouteError"
    /* UseRouteError */
  ), n = ie(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : (a = t.errors) == null ? void 0 : a[n];
}
function ht() {
  let { router: e } = ut(
    "useNavigate"
    /* UseNavigateStable */
  ), t = ie(
    "useNavigate"
    /* UseNavigateStable */
  ), n = o.useRef(!1);
  return Re(() => {
    n.current = !0;
  }), o.useCallback(
    async (r, i = {}) => {
      L(n.current, xe), n.current && (typeof r == "number" ? e.navigate(r) : await e.navigate(r, { fromRouteId: t, ...i }));
    },
    [e, t]
  );
}
var fe = {};
function Pe(e, t, n) {
  !t && !fe[e] && (fe[e] = !0, L(!1, n));
}
var de = {};
function he(e, t) {
  !e && !de[t] && (de[t] = !0, console.warn(t));
}
var mt = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (n) => {
        this.status === "pending" && (this.status = "resolved", e(n));
      }, this.reject = (n) => {
        this.status === "pending" && (this.status = "rejected", t(n));
      };
    });
  }
};
function un({
  router: e,
  flushSync: t
}) {
  let [n, a] = o.useState(e.state), [r, i] = o.useState(), [c, u] = o.useState({
    isTransitioning: !1
  }), [l, s] = o.useState(), [h, p] = o.useState(), [d, v] = o.useState(), f = o.useRef(/* @__PURE__ */ new Map()), w = o.useCallback(
    (y, { deletedFetchers: R, flushSync: x, viewTransitionOpts: C }) => {
      y.fetchers.forEach((P, S) => {
        P.data !== void 0 && f.current.set(S, P.data);
      }), R.forEach((P) => f.current.delete(P)), he(
        x === !1 || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let $ = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (he(
        C == null || $,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !C || !$) {
        t && x ? t(() => a(y)) : o.startTransition(() => a(y));
        return;
      }
      if (t && x) {
        t(() => {
          h && (l && l.resolve(), h.skipTransition()), u({
            isTransitioning: !0,
            flushSync: !0,
            currentLocation: C.currentLocation,
            nextLocation: C.nextLocation
          });
        });
        let P = e.window.document.startViewTransition(() => {
          t(() => a(y));
        });
        P.finished.finally(() => {
          t(() => {
            s(void 0), p(void 0), i(void 0), u({ isTransitioning: !1 });
          });
        }), t(() => p(P));
        return;
      }
      h ? (l && l.resolve(), h.skipTransition(), v({
        state: y,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      })) : (i(y), u({
        isTransitioning: !0,
        flushSync: !1,
        currentLocation: C.currentLocation,
        nextLocation: C.nextLocation
      }));
    },
    [e.window, t, h, l]
  );
  o.useLayoutEffect(() => e.subscribe(w), [e, w]), o.useEffect(() => {
    c.isTransitioning && !c.flushSync && s(new mt());
  }, [c]), o.useEffect(() => {
    if (l && r && e.window) {
      let y = r, R = l.promise, x = e.window.document.startViewTransition(async () => {
        o.startTransition(() => a(y)), await R;
      });
      x.finished.finally(() => {
        s(void 0), p(void 0), i(void 0), u({ isTransitioning: !1 });
      }), p(x);
    }
  }, [r, l, e.window]), o.useEffect(() => {
    l && r && n.location.key === r.location.key && l.resolve();
  }, [l, h, n.location, r]), o.useEffect(() => {
    !c.isTransitioning && d && (i(d.state), u({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: d.currentLocation,
      nextLocation: d.nextLocation
    }), v(void 0));
  }, [c.isTransitioning, d]);
  let E = o.useMemo(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (y) => e.navigate(y),
    push: (y, R, x) => e.navigate(y, {
      state: R,
      preventScrollReset: x == null ? void 0 : x.preventScrollReset
    }),
    replace: (y, R, x) => e.navigate(y, {
      replace: !0,
      state: R,
      preventScrollReset: x == null ? void 0 : x.preventScrollReset
    })
  }), [e]), m = e.basename || "/", g = o.useMemo(
    () => ({
      router: e,
      navigator: E,
      static: !1,
      basename: m
    }),
    [e, E, m]
  );
  return /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement(I.Provider, { value: g }, /* @__PURE__ */ o.createElement(F.Provider, { value: n }, /* @__PURE__ */ o.createElement(te.Provider, { value: f.current }, /* @__PURE__ */ o.createElement(J.Provider, { value: c }, /* @__PURE__ */ o.createElement(
    Se,
    {
      basename: m,
      location: n.location,
      navigationType: n.historyAction,
      navigator: E
    },
    /* @__PURE__ */ o.createElement(
      pt,
      {
        routes: e.routes,
        future: e.future,
        state: n
      }
    )
  ))))), null);
}
var pt = o.memo(vt);
function vt({
  routes: e,
  future: t,
  state: n
}) {
  return be(e, void 0, n, t);
}
function cn({
  to: e,
  replace: t,
  state: n,
  relative: a
}) {
  b(
    O(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: r } = o.useContext(T);
  L(
    !r,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: i } = o.useContext(k), { pathname: c } = N(), u = re(), l = ee(
    e,
    Z(i),
    c,
    a === "path"
  ), s = JSON.stringify(l);
  return o.useEffect(() => {
    u(JSON.parse(s), { replace: t, state: n, relative: a });
  }, [u, s, a, t, n]), null;
}
function fn(e) {
  return rt(e.context);
}
function Se({
  basename: e = "/",
  children: t = null,
  location: n,
  navigationType: a = "POP",
  navigator: r,
  static: i = !1
}) {
  b(
    !O(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let c = e.replace(/^\/*/, "/"), u = o.useMemo(
    () => ({
      basename: c,
      navigator: r,
      static: i,
      future: {}
    }),
    [c, r, i]
  );
  typeof n == "string" && (n = Y(n));
  let {
    pathname: l = "/",
    search: s = "",
    hash: h = "",
    state: p = null,
    key: d = "default"
  } = n, v = o.useMemo(() => {
    let f = M(l, c);
    return f == null ? null : {
      location: {
        pathname: f,
        search: s,
        hash: h,
        state: p,
        key: d
      },
      navigationType: a
    };
  }, [c, l, s, h, p, d, a]);
  return L(
    v != null,
    `<Router basename="${c}"> is not able to match the URL "${l}${s}${h}" because it does not start with the basename, so the <Router> won't render anything.`
  ), v == null ? null : /* @__PURE__ */ o.createElement(T.Provider, { value: u }, /* @__PURE__ */ o.createElement(K.Provider, { children: t, value: v }));
}
var V = "get", j = "application/x-www-form-urlencoded";
function q(e) {
  return e != null && typeof e.tagName == "string";
}
function gt(e) {
  return q(e) && e.tagName.toLowerCase() === "button";
}
function yt(e) {
  return q(e) && e.tagName.toLowerCase() === "form";
}
function wt(e) {
  return q(e) && e.tagName.toLowerCase() === "input";
}
function Et(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function xt(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Et(e);
}
function Q(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, n) => {
      let a = e[n];
      return t.concat(
        Array.isArray(a) ? a.map((r) => [n, r]) : [[n, a]]
      );
    }, [])
  );
}
function Rt(e, t) {
  let n = Q(e);
  return t && t.forEach((a, r) => {
    n.has(r) || t.getAll(r).forEach((i) => {
      n.append(r, i);
    });
  }), n;
}
var z = null;
function bt() {
  if (z === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), z = !1;
    } catch {
      z = !0;
    }
  return z;
}
var Ct = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function X(e) {
  return e != null && !Ct.has(e) ? (L(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${j}"`
  ), null) : e;
}
function Pt(e, t) {
  let n, a, r, i, c;
  if (yt(e)) {
    let u = e.getAttribute("action");
    a = u ? M(u, t) : null, n = e.getAttribute("method") || V, r = X(e.getAttribute("enctype")) || j, i = new FormData(e);
  } else if (gt(e) || wt(e) && (e.type === "submit" || e.type === "image")) {
    let u = e.form;
    if (u == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = e.getAttribute("formaction") || u.getAttribute("action");
    if (a = l ? M(l, t) : null, n = e.getAttribute("formmethod") || u.getAttribute("method") || V, r = X(e.getAttribute("formenctype")) || X(u.getAttribute("enctype")) || j, i = new FormData(u, e), !bt()) {
      let { name: s, type: h, value: p } = e;
      if (h === "image") {
        let d = s ? `${s}.` : "";
        i.append(`${d}x`, "0"), i.append(`${d}y`, "0");
      } else s && i.append(s, p);
    }
  } else {
    if (q(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = V, a = null, r = j, c = e;
  }
  return i && r === "text/plain" && (c = i, i = void 0), { action: a, method: n.toLowerCase(), encType: r, formData: i, body: c };
}
function oe(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
async function St(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Lt(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function kt(e, t, n) {
  let a = await Promise.all(
    e.map(async (r) => {
      let i = t.routes[r.route.id];
      if (i) {
        let c = await St(i, n);
        return c.links ? c.links() : [];
      }
      return [];
    })
  );
  return At(
    a.flat(1).filter(Lt).filter((r) => r.rel === "stylesheet" || r.rel === "preload").map(
      (r) => r.rel === "stylesheet" ? { ...r, rel: "prefetch", as: "style" } : { ...r, rel: "prefetch" }
    )
  );
}
function me(e, t, n, a, r, i) {
  let c = (l, s) => n[s] ? l.route.id !== n[s].route.id : !0, u = (l, s) => {
    var h;
    return (
      // param change, /users/123 -> /users/456
      n[s].pathname !== l.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((h = n[s].route.path) == null ? void 0 : h.endsWith("*")) && n[s].params["*"] !== l.params["*"]
    );
  };
  return i === "assets" ? t.filter(
    (l, s) => c(l, s) || u(l, s)
  ) : i === "data" ? t.filter((l, s) => {
    var p;
    let h = a.routes[l.route.id];
    if (!h || !h.hasLoader)
      return !1;
    if (c(l, s) || u(l, s))
      return !0;
    if (l.route.shouldRevalidate) {
      let d = l.route.shouldRevalidate({
        currentUrl: new URL(
          r.pathname + r.search + r.hash,
          window.origin
        ),
        currentParams: ((p = n[0]) == null ? void 0 : p.params) || {},
        nextUrl: new URL(e, window.origin),
        nextParams: l.params,
        defaultShouldRevalidate: !0
      });
      if (typeof d == "boolean")
        return d;
    }
    return !0;
  }) : [];
}
function $t(e, t, { includeHydrateFallback: n } = {}) {
  return Tt(
    e.map((a) => {
      let r = t.routes[a.route.id];
      if (!r) return [];
      let i = [r.module];
      return r.clientActionModule && (i = i.concat(r.clientActionModule)), r.clientLoaderModule && (i = i.concat(r.clientLoaderModule)), n && r.hydrateFallbackModule && (i = i.concat(r.hydrateFallbackModule)), r.imports && (i = i.concat(r.imports)), i;
    }).flat(1)
  );
}
function Tt(e) {
  return [...new Set(e)];
}
function Nt(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let a of n)
    t[a] = e[a];
  return t;
}
function At(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((a, r) => {
    let i = JSON.stringify(Nt(r));
    return n.has(i) || (n.add(i), a.push({ key: i, link: r })), a;
  }, []);
}
function Mt(e, t) {
  let n = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return n.pathname === "/" ? n.pathname = "_root.data" : t && M(n.pathname, t) === "/" ? n.pathname = `${t.replace(/\/$/, "")}/_root.data` : n.pathname = `${n.pathname.replace(/\/$/, "")}.data`, n;
}
function Le() {
  let e = o.useContext(I);
  return oe(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Dt() {
  let e = o.useContext(F);
  return oe(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var le = o.createContext(void 0);
le.displayName = "FrameworkContext";
function ke() {
  let e = o.useContext(le);
  return oe(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function It(e, t) {
  let n = o.useContext(le), [a, r] = o.useState(!1), [i, c] = o.useState(!1), { onFocus: u, onBlur: l, onMouseEnter: s, onMouseLeave: h, onTouchStart: p } = t, d = o.useRef(null);
  o.useEffect(() => {
    if (e === "render" && c(!0), e === "viewport") {
      let w = (m) => {
        m.forEach((g) => {
          c(g.isIntersecting);
        });
      }, E = new IntersectionObserver(w, { threshold: 0.5 });
      return d.current && E.observe(d.current), () => {
        E.disconnect();
      };
    }
  }, [e]), o.useEffect(() => {
    if (a) {
      let w = setTimeout(() => {
        c(!0);
      }, 100);
      return () => {
        clearTimeout(w);
      };
    }
  }, [a]);
  let v = () => {
    r(!0);
  }, f = () => {
    r(!1), c(!1);
  };
  return n ? e !== "intent" ? [i, d, {}] : [
    i,
    d,
    {
      onFocus: U(u, v),
      onBlur: U(l, f),
      onMouseEnter: U(s, v),
      onMouseLeave: U(h, f),
      onTouchStart: U(p, v)
    }
  ] : [!1, d, {}];
}
function U(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function Ot({
  page: e,
  ...t
}) {
  let { router: n } = Le(), a = o.useMemo(
    () => pe(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return a ? /* @__PURE__ */ o.createElement(_t, { page: e, matches: a, ...t }) : null;
}
function Ft(e) {
  let { manifest: t, routeModules: n } = ke(), [a, r] = o.useState([]);
  return o.useEffect(() => {
    let i = !1;
    return kt(e, t, n).then(
      (c) => {
        i || r(c);
      }
    ), () => {
      i = !0;
    };
  }, [e, t, n]), a;
}
function _t({
  page: e,
  matches: t,
  ...n
}) {
  let a = N(), { manifest: r, routeModules: i } = ke(), { basename: c } = Le(), { loaderData: u, matches: l } = Dt(), s = o.useMemo(
    () => me(
      e,
      t,
      l,
      r,
      a,
      "data"
    ),
    [e, t, l, r, a]
  ), h = o.useMemo(
    () => me(
      e,
      t,
      l,
      r,
      a,
      "assets"
    ),
    [e, t, l, r, a]
  ), p = o.useMemo(() => {
    if (e === a.pathname + a.search + a.hash)
      return [];
    let f = /* @__PURE__ */ new Set(), w = !1;
    if (t.forEach((m) => {
      var y;
      let g = r.routes[m.route.id];
      !g || !g.hasLoader || (!s.some((R) => R.route.id === m.route.id) && m.route.id in u && ((y = i[m.route.id]) != null && y.shouldRevalidate) || g.hasClientLoader ? w = !0 : f.add(m.route.id));
    }), f.size === 0)
      return [];
    let E = Mt(e, c);
    return w && f.size > 0 && E.searchParams.set(
      "_routes",
      t.filter((m) => f.has(m.route.id)).map((m) => m.route.id).join(",")
    ), [E.pathname + E.search];
  }, [
    c,
    u,
    a,
    r,
    s,
    t,
    e,
    i
  ]), d = o.useMemo(
    () => $t(h, r),
    [h, r]
  ), v = Ft(h);
  return /* @__PURE__ */ o.createElement(o.Fragment, null, p.map((f) => /* @__PURE__ */ o.createElement("link", { key: f, rel: "prefetch", as: "fetch", href: f, ...n })), d.map((f) => /* @__PURE__ */ o.createElement("link", { key: f, rel: "modulepreload", href: f, ...n })), v.map(({ key: f, link: w }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ o.createElement("link", { key: f, ...w })
  )));
}
function Ut(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var $e = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  $e && (window.__reactRouterVersion = "7.5.0");
} catch {
}
var Te = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ne = o.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: a = "none",
    relative: r,
    reloadDocument: i,
    replace: c,
    state: u,
    target: l,
    to: s,
    preventScrollReset: h,
    viewTransition: p,
    ...d
  }, v) {
    let { basename: f } = o.useContext(T), w = typeof s == "string" && Te.test(s), E, m = !1;
    if (typeof s == "string" && w && (E = s, $e))
      try {
        let S = new URL(window.location.href), D = s.startsWith("//") ? new URL(S.protocol + s) : new URL(s), se = M(D.pathname, f);
        D.origin === S.origin && se != null ? s = se + D.search + D.hash : m = !0;
      } catch {
        L(
          !1,
          `<Link to="${s}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let g = et(s, { relative: r }), [y, R, x] = It(
      a,
      d
    ), C = zt(s, {
      replace: c,
      state: u,
      target: l,
      preventScrollReset: h,
      relative: r,
      viewTransition: p
    });
    function $(S) {
      t && t(S), S.defaultPrevented || C(S);
    }
    let P = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ o.createElement(
        "a",
        {
          ...d,
          ...x,
          href: E || g,
          onClick: m || i ? t : $,
          ref: Ut(v, R),
          target: l,
          "data-discover": !w && n === "render" ? "true" : void 0
        }
      )
    );
    return y && !w ? /* @__PURE__ */ o.createElement(o.Fragment, null, P, /* @__PURE__ */ o.createElement(Ot, { page: g })) : P;
  }
);
Ne.displayName = "Link";
var Bt = o.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: a = "",
    end: r = !1,
    style: i,
    to: c,
    viewTransition: u,
    children: l,
    ...s
  }, h) {
    let p = W(c, { relative: s.relative }), d = N(), v = o.useContext(F), { navigator: f, basename: w } = o.useContext(T), E = v != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    Kt(p) && u === !0, m = f.encodeLocation ? f.encodeLocation(p).pathname : p.pathname, g = d.pathname, y = v && v.navigation && v.navigation.location ? v.navigation.location.pathname : null;
    n || (g = g.toLowerCase(), y = y ? y.toLowerCase() : null, m = m.toLowerCase()), y && w && (y = M(y, w) || y);
    const R = m !== "/" && m.endsWith("/") ? m.length - 1 : m.length;
    let x = g === m || !r && g.startsWith(m) && g.charAt(R) === "/", C = y != null && (y === m || !r && y.startsWith(m) && y.charAt(m.length) === "/"), $ = {
      isActive: x,
      isPending: C,
      isTransitioning: E
    }, P = x ? t : void 0, S;
    typeof a == "function" ? S = a($) : S = [
      a,
      x ? "active" : null,
      C ? "pending" : null,
      E ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let D = typeof i == "function" ? i($) : i;
    return /* @__PURE__ */ o.createElement(
      Ne,
      {
        ...s,
        "aria-current": P,
        className: S,
        ref: h,
        style: D,
        to: c,
        viewTransition: u
      },
      typeof l == "function" ? l($) : l
    );
  }
);
Bt.displayName = "NavLink";
var Ht = o.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: a,
    replace: r,
    state: i,
    method: c = V,
    action: u,
    onSubmit: l,
    relative: s,
    preventScrollReset: h,
    viewTransition: p,
    ...d
  }, v) => {
    let f = Yt(), w = Jt(u, { relative: s }), E = c.toLowerCase() === "get" ? "get" : "post", m = typeof u == "string" && Te.test(u), g = (y) => {
      if (l && l(y), y.defaultPrevented) return;
      y.preventDefault();
      let R = y.nativeEvent.submitter, x = (R == null ? void 0 : R.getAttribute("formmethod")) || c;
      f(R || y.currentTarget, {
        fetcherKey: t,
        method: x,
        navigate: n,
        replace: r,
        state: i,
        relative: s,
        preventScrollReset: h,
        viewTransition: p
      });
    };
    return /* @__PURE__ */ o.createElement(
      "form",
      {
        ref: v,
        method: E,
        action: w,
        onSubmit: a ? l : g,
        ...d,
        "data-discover": !m && e === "render" ? "true" : void 0
      }
    );
  }
);
Ht.displayName = "Form";
function Wt(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Ae(e) {
  let t = o.useContext(I);
  return b(t, Wt(e)), t;
}
function zt(e, {
  target: t,
  replace: n,
  state: a,
  preventScrollReset: r,
  relative: i,
  viewTransition: c
} = {}) {
  let u = re(), l = N(), s = W(e, { relative: i });
  return o.useCallback(
    (h) => {
      if (xt(h, t)) {
        h.preventDefault();
        let p = n !== void 0 ? n : B(l) === B(s);
        u(e, {
          replace: p,
          state: a,
          preventScrollReset: r,
          relative: i,
          viewTransition: c
        });
      }
    },
    [
      l,
      u,
      s,
      n,
      a,
      t,
      e,
      r,
      i,
      c
    ]
  );
}
function dn(e) {
  L(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = o.useRef(Q(e)), n = o.useRef(!1), a = N(), r = o.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      Rt(
        a.search,
        n.current ? null : t.current
      )
    ),
    [a.search]
  ), i = re(), c = o.useCallback(
    (u, l) => {
      const s = Q(
        typeof u == "function" ? u(r) : u
      );
      n.current = !0, i("?" + s, l);
    },
    [i, r]
  );
  return [r, c];
}
var Vt = 0, jt = () => `__${String(++Vt)}__`;
function Yt() {
  let { router: e } = Ae(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = o.useContext(T), n = ft();
  return o.useCallback(
    async (a, r = {}) => {
      let { action: i, method: c, encType: u, formData: l, body: s } = Pt(
        a,
        t
      );
      if (r.navigate === !1) {
        let h = r.fetcherKey || jt();
        await e.fetch(h, n, r.action || i, {
          preventScrollReset: r.preventScrollReset,
          formData: l,
          body: s,
          formMethod: r.method || c,
          formEncType: r.encType || u,
          flushSync: r.flushSync
        });
      } else
        await e.navigate(r.action || i, {
          preventScrollReset: r.preventScrollReset,
          formData: l,
          body: s,
          formMethod: r.method || c,
          formEncType: r.encType || u,
          replace: r.replace,
          state: r.state,
          fromRouteId: n,
          flushSync: r.flushSync,
          viewTransition: r.viewTransition
        });
    },
    [e, t, n]
  );
}
function Jt(e, { relative: t } = {}) {
  let { basename: n } = o.useContext(T), a = o.useContext(k);
  b(a, "useFormAction must be used inside a RouteContext");
  let [r] = a.matches.slice(-1), i = { ...W(e || ".", { relative: t }) }, c = N();
  if (e == null) {
    i.search = c.search;
    let u = new URLSearchParams(i.search), l = u.getAll("index");
    if (l.some((h) => h === "")) {
      u.delete("index"), l.filter((p) => p).forEach((p) => u.append("index", p));
      let h = u.toString();
      i.search = h ? `?${h}` : "";
    }
  }
  return (!e || e === ".") && r.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (i.pathname = i.pathname === "/" ? n : A([n, i.pathname])), B(i);
}
function Kt(e, t = {}) {
  let n = o.useContext(J);
  b(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: a } = Ae(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), r = W(e, { relative: t.relative });
  if (!n.isTransitioning)
    return !1;
  let i = M(n.currentLocation.pathname, a) || n.currentLocation.pathname, c = M(n.nextLocation.pathname, a) || n.nextLocation.pathname;
  return H(r.pathname, c) != null || H(r.pathname, i) != null;
}
function hn({
  context: e,
  router: t,
  hydrate: n = !0,
  nonce: a
}) {
  b(
    t && e,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let r = {
    router: t,
    navigator: Xt(),
    static: !0,
    staticContext: e,
    basename: e.basename || "/"
  }, i = /* @__PURE__ */ new Map(), c = "";
  if (n !== !1) {
    let l = {
      loaderData: e.loaderData,
      actionData: e.actionData,
      errors: Gt(e.errors)
    };
    c = `window.__staticRouterHydrationData = JSON.parse(${rn(JSON.stringify(JSON.stringify(l)))});`;
  }
  let { state: u } = r.router;
  return /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement(I.Provider, { value: r }, /* @__PURE__ */ o.createElement(F.Provider, { value: u }, /* @__PURE__ */ o.createElement(te.Provider, { value: i }, /* @__PURE__ */ o.createElement(J.Provider, { value: { isTransitioning: !1 } }, /* @__PURE__ */ o.createElement(
    Se,
    {
      basename: r.basename,
      location: u.location,
      navigationType: u.historyAction,
      navigator: r.navigator,
      static: r.static
    },
    /* @__PURE__ */ o.createElement(
      qt,
      {
        routes: t.routes,
        future: t.future,
        state: u
      }
    )
  ))))), c ? /* @__PURE__ */ o.createElement(
    "script",
    {
      suppressHydrationWarning: !0,
      nonce: a,
      dangerouslySetInnerHTML: { __html: c }
    }
  ) : null);
}
function qt({
  routes: e,
  future: t,
  state: n
}) {
  return be(e, void 0, n, t);
}
function Gt(e) {
  if (!e) return null;
  let t = Object.entries(e), n = {};
  for (let [a, r] of t)
    we(r) ? n[a] = { ...r, __type: "RouteErrorResponse" } : r instanceof Error ? n[a] = {
      message: r.message,
      __type: "Error",
      // If this is a subclass (i.e., ReferenceError), send up the type so we
      // can re-create the same type during hydration.
      ...r.name !== "Error" ? {
        __subType: r.name
      } : {}
    } : n[a] = r;
  return n;
}
function Xt() {
  return {
    createHref: Qt,
    encodeLocation: Zt,
    push(e) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)})\` somewhere in your app.`
      );
    },
    replace(e) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(e) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${e})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        "You cannot use navigator.back() on the server because it is a stateless environment."
      );
    },
    forward() {
      throw new Error(
        "You cannot use navigator.forward() on the server because it is a stateless environment."
      );
    }
  };
}
function Qt(e) {
  return typeof e == "string" ? e : B(e);
}
function Zt(e) {
  let t = typeof e == "string" ? e : B(e);
  t = t.replace(/ $/, "%20");
  let n = en.test(t) ? new URL(t) : new URL(t, "http://localhost");
  return {
    pathname: n.pathname,
    search: n.search,
    hash: n.hash
  };
}
var en = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, tn = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, nn = /[&><\u2028\u2029]/g;
function rn(e) {
  return e.replace(nn, (t) => tn[t]);
}
new TextEncoder();
export {
  Ne as L,
  cn as N,
  fn as O,
  un as R,
  hn as S,
  re as a,
  dn as b,
  ln as c,
  on as d,
  dt as e,
  sn as f,
  Bt as g,
  et as h,
  we as i,
  H as m,
  an as r,
  N as u
};
//# sourceMappingURL=chunk-KNED5TY2-BUPjb3LQ.js.map
