import { j as B } from "./jsx-runtime-C5mzlN2N.js";
import { createContext as ro, useContext as uo, useRef as Ut, useEffect as bt, useCallback as Hi, useState as cr, useMemo as fu, memo as Ui } from "react";
import { d as io, g as Nr, u as Or, b as ao, h as so } from "./chunk-KNED5TY2-BUPjb3LQ.js";
import { c as vi } from "./index-CPNSgwSb.js";
import { ChevronRightIcon as oo, ExternalLinkIcon as lo } from "lucide-react";
import { N as co, j as fo, f as ho } from "./hook-pPrHCB6G.js";
import { c as vt } from "./cn-qaFjX9_3.js";
import * as Yn from "@radix-ui/react-collapsible";
import { B as mo } from "./Button-BBNrKpQd.js";
import { Slot as po } from "@radix-ui/react-slot";
import { Button as Eo } from "./ui/Button.js";
import { Callout as Ze } from "./ui/Callout.js";
import { Stepper as go } from "./ui/Stepper.js";
import { S as hu } from "./SyntaxHighlight-CxhyyMkF.js";
import { g as zi } from "./_commonjsHelpers-B4e78b8K.js";
import { e as To } from "./index-Bn6Lc9tq.js";
const Yi = -1, On = 0, An = 1, _n = 2, Lr = 3, Rr = 4, Dr = 5, Pr = 6, qi = 7, ji = 8, du = typeof self == "object" ? self : globalThis, bo = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case On:
      case Yi:
        return n(i, u);
      case An: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case _n: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case Lr:
        return n(new Date(i), u);
      case Rr: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case Dr: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case Pr: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case qi: {
        const { name: o, message: l } = i;
        return n(new du[o](l), u);
      }
      case ji:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
    }
    return n(new du[a](i), u);
  };
  return r;
}, mu = (e) => bo(/* @__PURE__ */ new Map(), e)(0), ct = "", { toString: Ao } = {}, { keys: _o } = Object, Rt = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [On, t];
  const n = Ao.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [An, ct];
    case "Object":
      return [_n, ct];
    case "Date":
      return [Lr, ct];
    case "RegExp":
      return [Rr, ct];
    case "Map":
      return [Dr, ct];
    case "Set":
      return [Pr, ct];
  }
  return n.includes("Array") ? [An, n] : n.includes("Error") ? [qi, n] : [_n, n];
}, on = ([e, t]) => e === On && (t === "function" || t === "symbol"), Co = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = Rt(i);
    switch (o) {
      case On: {
        let h = i;
        switch (l) {
          case "bigint":
            o = ji, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            h = null;
            break;
          case "undefined":
            return u([Yi], i);
        }
        return u([o, h], i);
      }
      case An: {
        if (l)
          return u([l, [...i]], i);
        const h = [], f = u([o, h], i);
        for (const p of i)
          h.push(a(p));
        return f;
      }
      case _n: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f = u([o, h], i);
        for (const p of _o(i))
          (e || !on(Rt(i[p]))) && h.push([a(p), a(i[p])]);
        return f;
      }
      case Lr:
        return u([o, i.toISOString()], i);
      case Rr: {
        const { source: h, flags: f } = i;
        return u([o, { source: h, flags: f }], i);
      }
      case Dr: {
        const h = [], f = u([o, h], i);
        for (const [p, d] of i)
          (e || !(on(Rt(p)) || on(Rt(d)))) && h.push([a(p), a(d)]);
        return f;
      }
      case Pr: {
        const h = [], f = u([o, h], i);
        for (const p of i)
          (e || !on(Rt(p))) && h.push(a(p));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, pu = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return Co(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Eu = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? mu(pu(e, t)) : structuredClone(e)
) : (e, t) => mu(pu(e, t));
let Zt = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
};
Zt.prototype.property = {};
Zt.prototype.normal = {};
Zt.prototype.space = null;
function Vi(e, t) {
  const n = {}, r = {};
  let u = -1;
  for (; ++u < e.length; )
    Object.assign(n, e[u].property), Object.assign(r, e[u].normal);
  return new Zt(n, r, t);
}
function $t(e) {
  return e.toLowerCase();
}
let ke = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
};
ke.prototype.space = null;
ke.prototype.boolean = !1;
ke.prototype.booleanish = !1;
ke.prototype.overloadedBoolean = !1;
ke.prototype.number = !1;
ke.prototype.commaSeparated = !1;
ke.prototype.spaceSeparated = !1;
ke.prototype.commaOrSpaceSeparated = !1;
ke.prototype.mustUseProperty = !1;
ke.prototype.defined = !1;
let So = 0;
const W = ut(), se = ut(), Wi = ut(), P = ut(), re = ut(), Et = ut(), Ce = ut();
function ut() {
  return 2 ** ++So;
}
const fr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: W,
  booleanish: se,
  commaOrSpaceSeparated: Ce,
  commaSeparated: Et,
  number: P,
  overloadedBoolean: Wi,
  spaceSeparated: re
}, Symbol.toStringTag, { value: "Module" })), qn = Object.keys(fr);
let wr = class extends ke {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, u) {
    let a = -1;
    if (super(t, n), gu(this, "space", u), typeof r == "number")
      for (; ++a < qn.length; ) {
        const i = qn[a];
        gu(this, qn[a], (r & fr[i]) === fr[i]);
      }
  }
};
wr.prototype.defined = !0;
function gu(e, t, n) {
  n && (e[t] = n);
}
const xo = {}.hasOwnProperty;
function Ct(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (xo.call(e.properties, r)) {
      const u = e.properties[r], a = new wr(
        r,
        e.transform(e.attributes || {}, r),
        u,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[$t(r)] = r, n[$t(a.attribute)] = r;
    }
  return new Zt(t, n, e.space);
}
const Gi = Ct({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Qi = Ct({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function $i(e, t) {
  return t in e ? e[t] : t;
}
function Xi(e, t) {
  return $i(e, t.toLowerCase());
}
const Ki = Ct({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Xi,
  properties: { xmlns: null, xmlnsXLink: null }
}), Ji = Ct({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: se,
    ariaAutoComplete: null,
    ariaBusy: se,
    ariaChecked: se,
    ariaColCount: P,
    ariaColIndex: P,
    ariaColSpan: P,
    ariaControls: re,
    ariaCurrent: null,
    ariaDescribedBy: re,
    ariaDetails: null,
    ariaDisabled: se,
    ariaDropEffect: re,
    ariaErrorMessage: null,
    ariaExpanded: se,
    ariaFlowTo: re,
    ariaGrabbed: se,
    ariaHasPopup: null,
    ariaHidden: se,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: re,
    ariaLevel: P,
    ariaLive: null,
    ariaModal: se,
    ariaMultiLine: se,
    ariaMultiSelectable: se,
    ariaOrientation: null,
    ariaOwns: re,
    ariaPlaceholder: null,
    ariaPosInSet: P,
    ariaPressed: se,
    ariaReadOnly: se,
    ariaRelevant: null,
    ariaRequired: se,
    ariaRoleDescription: re,
    ariaRowCount: P,
    ariaRowIndex: P,
    ariaRowSpan: P,
    ariaSelected: se,
    ariaSetSize: P,
    ariaSort: null,
    ariaValueMax: P,
    ariaValueMin: P,
    ariaValueNow: P,
    ariaValueText: null,
    role: null
  }
}), Io = Ct({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Xi,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Et,
    acceptCharset: re,
    accessKey: re,
    action: null,
    allow: null,
    allowFullScreen: W,
    allowPaymentRequest: W,
    allowUserMedia: W,
    alt: null,
    as: null,
    async: W,
    autoCapitalize: null,
    autoComplete: re,
    autoFocus: W,
    autoPlay: W,
    blocking: re,
    capture: null,
    charSet: null,
    checked: W,
    cite: null,
    className: re,
    cols: P,
    colSpan: null,
    content: null,
    contentEditable: se,
    controls: W,
    controlsList: re,
    coords: P | Et,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: W,
    defer: W,
    dir: null,
    dirName: null,
    disabled: W,
    download: Wi,
    draggable: se,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: W,
    formTarget: null,
    headers: re,
    height: P,
    hidden: W,
    high: P,
    href: null,
    hrefLang: null,
    htmlFor: re,
    httpEquiv: re,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: W,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: W,
    itemId: null,
    itemProp: re,
    itemRef: re,
    itemScope: W,
    itemType: re,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: W,
    low: P,
    manifest: null,
    max: null,
    maxLength: P,
    media: null,
    method: null,
    min: null,
    minLength: P,
    multiple: W,
    muted: W,
    name: null,
    nonce: null,
    noModule: W,
    noValidate: W,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: W,
    optimum: P,
    pattern: null,
    ping: re,
    placeholder: null,
    playsInline: W,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: W,
    referrerPolicy: null,
    rel: re,
    required: W,
    reversed: W,
    rows: P,
    rowSpan: P,
    sandbox: re,
    scope: null,
    scoped: W,
    seamless: W,
    selected: W,
    shadowRootClonable: W,
    shadowRootDelegatesFocus: W,
    shadowRootMode: null,
    shape: null,
    size: P,
    sizes: null,
    slot: null,
    span: P,
    spellCheck: se,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: P,
    step: null,
    style: null,
    tabIndex: P,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: W,
    useMap: null,
    value: se,
    width: P,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: re,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: P,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: P,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: W,
    // Lists. Use CSS to reduce space between items instead
    declare: W,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: P,
    // `<img>` and `<object>`
    leftMargin: P,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: P,
    // `<body>`
    marginWidth: P,
    // `<body>`
    noResize: W,
    // `<frame>`
    noHref: W,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: W,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: W,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: P,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: se,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: P,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: P,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: W,
    disableRemotePlayback: W,
    prefix: null,
    property: null,
    results: P,
    security: null,
    unselectable: null
  }
}), ko = Ct({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: $i,
  properties: {
    about: Ce,
    accentHeight: P,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: P,
    amplitude: P,
    arabicForm: null,
    ascent: P,
    attributeName: null,
    attributeType: null,
    azimuth: P,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: P,
    by: null,
    calcMode: null,
    capHeight: P,
    className: re,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: P,
    diffuseConstant: P,
    direction: null,
    display: null,
    dur: null,
    divisor: P,
    dominantBaseline: null,
    download: W,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: P,
    enableBackground: null,
    end: null,
    event: null,
    exponent: P,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: P,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Et,
    g2: Et,
    glyphName: Et,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: P,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: P,
    horizOriginX: P,
    horizOriginY: P,
    id: null,
    ideographic: P,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: P,
    k: P,
    k1: P,
    k2: P,
    k3: P,
    k4: P,
    kernelMatrix: Ce,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: P,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: P,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: P,
    overlineThickness: P,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: P,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: re,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: P,
    pointsAtY: P,
    pointsAtZ: P,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ce,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ce,
    rev: Ce,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ce,
    requiredFeatures: Ce,
    requiredFonts: Ce,
    requiredFormats: Ce,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: P,
    specularExponent: P,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: P,
    strikethroughThickness: P,
    string: null,
    stroke: null,
    strokeDashArray: Ce,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: P,
    strokeOpacity: P,
    strokeWidth: null,
    style: null,
    surfaceScale: P,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ce,
    tabIndex: P,
    tableValues: null,
    target: null,
    targetX: P,
    targetY: P,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ce,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: P,
    underlineThickness: P,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: P,
    values: null,
    vAlphabetic: P,
    vMathematical: P,
    vectorEffect: null,
    vHanging: P,
    vIdeographic: P,
    version: null,
    vertAdvY: P,
    vertOriginX: P,
    vertOriginY: P,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: P,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), yo = /^data[-\w.:]+$/i, Tu = /-[a-z]/g, No = /[A-Z]/g;
function Mr(e, t) {
  const n = $t(t);
  let r = t, u = ke;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && yo.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Tu, Lo);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Tu.test(a)) {
        let i = a.replace(No, Oo);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    u = wr;
  }
  return new u(r, t);
}
function Oo(e) {
  return "-" + e.toLowerCase();
}
function Lo(e) {
  return e.charAt(1).toUpperCase();
}
const Ln = Vi([Qi, Gi, Ki, Ji, Io], "html"), en = Vi([Qi, Gi, Ki, Ji, ko], "svg");
function bu(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), u = 0, a = !1;
  for (; !a; ) {
    r === -1 && (r = n.length, a = !0);
    const i = n.slice(u, r).trim();
    (i || !a) && t.push(i), u = r + 1, r = n.indexOf(",", u);
  }
  return t;
}
function Zi(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Au = /[#.]/g;
function Ro(e, t) {
  const n = e || "", r = {};
  let u = 0, a, i;
  for (; u < n.length; ) {
    Au.lastIndex = u;
    const o = Au.exec(n), l = n.slice(u, o ? o.index : n.length);
    l && (a ? a === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : i = l, u += l.length), o && (a = o[0], u++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t || "div",
    properties: r,
    children: []
  };
}
function _u(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function ea(e) {
  return e.join(" ").trim();
}
const hr = {}.hasOwnProperty;
function ta(e, t, n) {
  const r = n && Mo(n);
  function u(a, i, ...o) {
    let l = -1, c;
    if (a == null) {
      c = { type: "root", children: [] };
      const h = (
        /** @type {Child} */
        i
      );
      o.unshift(h);
    } else if (c = Ro(a, t), c.tagName = c.tagName.toLowerCase(), r && hr.call(r, c.tagName) && (c.tagName = r[c.tagName]), Do(i))
      o.unshift(i);
    else {
      let h;
      for (h in i)
        hr.call(i, h) && Po(e, c.properties, h, i[h]);
    }
    for (; ++l < o.length; )
      dr(c.children, o[l]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return u;
}
function Do(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const u = t[r];
    if (u && typeof u == "object") {
      if (!Array.isArray(u)) return !0;
      const a = (
        /** @type {Array<unknown>} */
        u
      );
      for (const i of a)
        if (typeof i != "number" && typeof i != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function Po(e, t, n, r) {
  const u = Mr(e, n);
  let a = -1, i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? u.spaceSeparated ? i = _u(r) : u.commaSeparated ? i = bu(r) : u.commaOrSpaceSeparated ? i = _u(bu(r).join(" ")) : i = Cu(u, u.property, r) : Array.isArray(r) ? i = r.concat() : i = u.property === "style" ? wo(r) : String(r);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++a < i.length; ) {
        const l = (
          /** @type {number | string} */
          Cu(u, u.property, i[a])
        );
        o[a] = l;
      }
      i = o;
    }
    if (u.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t.className.concat(o);
    }
    t[u.property] = i;
  }
}
function dr(e, t) {
  let n = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n < t.length; )
      dr(e, t[n]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? dr(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function Cu(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || $t(n) === $t(t)))
      return !0;
  }
  return n;
}
function wo(e) {
  const t = [];
  let n;
  for (n in e)
    hr.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function Mo(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const Bo = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], Fo = ta(Ln, "div"), Ho = ta(en, "g", Bo);
function Uo(e) {
  const t = String(e), n = [];
  return { toOffset: u, toPoint: r };
  function r(a) {
    if (typeof a == "number" && a > -1 && a <= t.length) {
      let i = 0;
      for (; ; ) {
        let o = n[i];
        if (o === void 0) {
          const l = Su(t, n[i - 1]);
          o = l === -1 ? t.length + 1 : l + 1, n[i] = o;
        }
        if (o > a)
          return {
            line: i + 1,
            column: a - (i > 0 ? n[i - 1] : 0) + 1,
            offset: a
          };
        i++;
      }
    }
  }
  function u(a) {
    if (a && typeof a.line == "number" && typeof a.column == "number" && !Number.isNaN(a.line) && !Number.isNaN(a.column)) {
      for (; n.length < a.line; ) {
        const o = n[n.length - 1], l = Su(t, o), c = l === -1 ? t.length + 1 : l + 1;
        if (o === c) break;
        n.push(c);
      }
      const i = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1;
      if (i < n[a.line - 1]) return i;
    }
  }
}
function Su(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const tt = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, na = {}.hasOwnProperty, vo = Object.prototype;
function zo(e, t) {
  const n = t || {};
  return Br(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? en : Ln,
      verbose: n.verbose || !1
    },
    e
  );
}
function Br(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return n = { type: "comment", value: r.data }, pn(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), u = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: ra(e, t.childNodes),
        data: { quirksMode: u }
      }, e.file && e.location) {
        const a = String(e.file), i = Uo(a), o = i.toPoint(0), l = i.toPoint(a.length);
        n.position = { start: o, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return n = { type: "doctype" }, pn(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return n = { type: "text", value: r.value }, pn(e, r, n), n;
    }
    // Element.
    default:
      return n = Yo(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), n;
  }
}
function ra(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const u = (
      /** @type {RootContent} */
      Br(e, t[n])
    );
    r.push(u);
  }
  return r;
}
function Yo(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === tt.svg ? en : Ln;
  let r = -1;
  const u = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], l = (o.prefix ? o.prefix + ":" : "") + o.name;
    na.call(vo, l) || (u[l] = o.value);
  }
  const i = (e.schema.space === "svg" ? Ho : Fo)(t.tagName, u, ra(e, t.childNodes));
  if (pn(e, t, i), i.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), l = o.sourceCodeLocation, c = l && l.startTag && pt(l.startTag), h = l && l.endTag && pt(l.endTag), f = (
      /** @type {Root} */
      Br(e, o.content)
    );
    c && h && e.file && (f.position = { start: c.end, end: h.start }), i.content = f;
  }
  return e.schema = n, i;
}
function pn(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = qo(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function qo(e, t, n) {
  const r = pt(n);
  if (t.type === "element") {
    const u = t.children[t.children.length - 1];
    if (r && !n.endTag && u && u.position && u.position.end && (r.end = Object.assign({}, u.position.end)), e.verbose) {
      const a = {};
      let i;
      if (n.attrs)
        for (i in n.attrs)
          na.call(n.attrs, i) && (a[Mr(e.schema, i).property] = pt(
            n.attrs[i]
          ));
      n.startTag;
      const o = pt(n.startTag), l = n.endTag ? pt(n.endTag) : void 0, c = { opening: o };
      l && (c.closing = l), c.properties = a, t.data = { position: c };
    }
  }
  return r;
}
function pt(e) {
  const t = xu({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = xu({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function xu(e) {
  return e.line && e.column ? e : void 0;
}
const Iu = {}.hasOwnProperty;
function ua(e, t) {
  const n = t || {};
  function r(u, ...a) {
    let i = r.invalid;
    const o = r.handlers;
    if (u && Iu.call(u, e)) {
      const l = String(u[e]);
      i = Iu.call(o, l) ? o[l] : r.unknown;
    }
    if (i)
      return i.call(this, u, ...a);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const jo = {}, Vo = {}.hasOwnProperty, ia = ua("type", { handlers: { root: Go, element: Jo, text: Xo, comment: Ko, doctype: $o } });
function Wo(e, t) {
  const r = (t || jo).space;
  return ia(e, r === "svg" ? en : Ln);
}
function Go(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Fr(e.children, n, t), St(e, n), n;
}
function Qo(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Fr(e.children, n, t), St(e, n), n;
}
function $o(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return St(e, t), t;
}
function Xo(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return St(e, t), t;
}
function Ko(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return St(e, t), t;
}
function Jo(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = en);
  const u = [];
  let a;
  if (e.properties) {
    for (a in e.properties)
      if (a !== "children" && Vo.call(e.properties, a)) {
        const l = Zo(
          r,
          a,
          e.properties[a]
        );
        l && u.push(l);
      }
  }
  const i = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: u,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: tt[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Fr(e.children, o, r), St(e, o), e.tagName === "template" && e.content && (o.content = Qo(e.content, r)), o;
}
function Zo(e, t, n) {
  const r = Mr(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? Zi(n) : ea(n));
  const u = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const a = u.name.indexOf(":");
    a < 0 ? u.prefix = "" : (u.name = u.name.slice(a + 1), u.prefix = r.attribute.slice(0, a)), u.namespace = tt[r.space];
  }
  return u;
}
function Fr(e, t, n) {
  let r = -1;
  const u = [];
  if (e)
    for (; ++r < e.length; ) {
      const a = ia(e[r], n);
      a.parentNode = t, u.push(a);
    }
  return u;
}
function St(e, t) {
  const n = e.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const el = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], tl = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), ie = "ï¿½";
var m;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(m || (m = {}));
const Te = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function aa(e) {
  return e >= 55296 && e <= 57343;
}
function nl(e) {
  return e >= 56320 && e <= 57343;
}
function rl(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function sa(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function oa(e) {
  return e >= 64976 && e <= 65007 || tl.has(e);
}
var x;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(x || (x = {}));
const ul = 65536;
class il {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = ul, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, n) {
    const { line: r, col: u, offset: a } = this, i = u + n, o = a + n;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: i,
      endCol: i,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (nl(n))
        return this.pos++, this._addGap(), rl(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, m.EOF;
    return this._err(x.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    const r = this.html.charCodeAt(n);
    return r === m.CARRIAGE_RETURN ? m.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === m.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, m.LINE_FEED) : t === m.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, aa(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === m.LINE_FEED || t === m.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    sa(t) ? this._err(x.controlCharacterInInputStream) : oa(t) && this._err(x.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var $;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})($ || ($ = {}));
function la(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const ca = new Uint16Array(
  // prettier-ignore
  'áµ<ÃÄ±ÊÒÕ»×ÙµÛÞ¢ßà à©àªà¶¡à¹­à¼à¼¦áá¨á¡ááááá¥\0\0\0\0\0\0á«áá¦á°á·á½¾â â°âââ»ââ ¤â¤â´â¹â¿ããºã¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à EMabcfglmnoprstu\\bfmsÂÂÂÂÂÂ¦Â³Â¹ÃÃligè»ÃäPè»&ä¦cuteè»Ãäreve;äÄiyx}rcè»Ãä;är;ìðraveè»Ãäpha;äacr;äd;æ©ÄgpÂÂ¡on;äf;ìð¸plyFunction;æ¡ingè»ÃäÄcsÂ¾Ãr;ìðign;æildeè»Ãämlè»ÃäÐaceforsuÃ¥Ã»Ã¾ÄÄÄ¢Ä§ÄªÄcrÃªÃ²kslash;æÅ¶Ã¶Ã¸;æ«§ed;æy;äÆcrtÄÄÄause;æµnoullis;æ¬a;är;ìðpf;ìð¹eve;äcÃ²Ämpeq;æÜHOacdefhilorsuÅÅÅÆÆÆ¢ÆµÆ·ÆºÇÈÉ³É¸É¾cy;ä§PYè»Â©ä©ÆcpyÅÅ¢Åºute;äÄ;iÅ§Å¨ætalDifferentialD;æleys;æ­ÈaeioÆÆÆÆron;ädilè»Ãärc;änint;æ°ot;äÄdnÆ§Æ­illa;ä¸terDot;ä·Ã²Å¿i;ä§rcleÈDMPTÇÇÇÇot;æinus;ælus;æimes;æoÄcsÇ¢Ç¸kwiseContourIntegral;æ²eCurlyÄDQÈÈoubleQuote;æuote;æÈlnpuÈÈ¨ÉÉonÄ;eÈ¥È¦æ·;æ©´ÆgitÈ¯È¶Èºruent;æ¡nt;æ¯ourIntegral;æ®ÄfrÉÉ;æoduct;ænterClockwiseContourIntegral;æ³oss;æ¨¯cr;ìðpÄ;CÊÊæap;æÖDJSZacefiosÊ Ê¬Ê°Ê´Ê¸ËËË¡Ë¦Ì³ÒÄ;oÅ¹Ê¥trahd;æ¤cy;äcy;äcy;äÆgrsÊ¿ËËger;æ¡r;æ¡hv;æ«¤ÄayËËron;ä;älÄ;tËËæa;är;ìðÄafË«Ì§ÄcmË°Ì¢riticalÈADGTÌÌÌÌcute;ä´oÅ´ÌÌ;äbleAcute;ärave;ä ilde;äond;æferentialD;æÑ°Ì½\0\0\0ÍÍ\0Ðf;ìð»Æ;DEÍÍÍä¨ot;æqual;æbleÌCDLRUVÍ£Í²ÎÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»ÍnArrow;æÄeoÎÎ¤ftÆARTÎÎÎ¡rrow;æightArrow;æeÃ¥ËngÄLRÎ«ÏeftÄARÎ³Î¹rrow;æ¸ightArrow;æºightArrow;æ¹ightÄATÏÏrrow;æee;æ¨pÉÏ©\0\0Ï¯rrow;æownArrow;æerticalBar;æ¥nÌABLRTaÐÐªÐ°ÑÑ¿Í¼rrowÆ;BUÐÐÐ¢æar;æ¤pArrow;æµreve;äeftËÐº\0Ñ\0ÑightVector;æ¥eeVector;æ¥ectorÄ;BÑÑæ½ar;æ¥ightÇÑ§\0Ñ±eeVector;æ¥ectorÄ;BÑºÑ»æar;æ¥eeÄ;AÒÒæ¤rrow;æ§ÄctÒÒr;ìðrok;äà NTacdfglmopqstuxÒ½ÓÓÓÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶ÕÕÕ Õ¥G;äHè»Ãäcuteè»ÃäÆaiyÓÓÓron;ärcè»Ãä;ä­ot;är;ìðraveè»Ãäement;æÄapÓºÓ¾cr;ätyÉÔ\0\0ÔmallSquare;æ»erySmallSquare;æ«ÄgpÔ¦Ôªon;äf;ìð¼silon;äuÄaiÔ¼ÕlÄ;TÕÕæ©µilde;ælibrium;æÄciÕÕr;æ°m;æ©³a;ämlè»ÃäÄipÕªÕ¯sts;æonentialE;æÊcfiosÖÖÖÖ²×y;ä¤r;ìðlledÉÖ\0\0Ö£mallSquare;æ¼erySmallSquare;æªÍ°Öº\0Ö¿\0\0×f;ìð½All;æriertrf;æ±cÃ²×ØJTabcdfgorst×¨×¬×¯×ºØØØØØØ£Ù¬Ù²cy;äè»>ä¾mmaÄ;d×·×¸ä;äreve;äÆeiyØØØdil;ä¢rc;ä;äot;ä r;ìð;æpf;ìð¾eaterÌEFGLSTØµÙÙÙÙÙ¦qualÄ;LØ¾Ø¿æ¥ess;æullEqual;æ§reater;æª¢ess;æ·lantEqual;æ©¾ilde;æ³cr;ìð¢;æ«ÐAacfiosuÚÚÚÚÚÚªÚ¾ÛRDcy;äªÄctÚÚek;ä;äirc;ä¤r;ælbertSpace;æÇ°Ú¯\0Ú²f;æizontalLine;æÄctÛÛÃ²Ú©rok;ä¦mpÅÛÛownHumÃ°Ä¯qual;æÜEJOacdfgmnostuÛºÛ¾ÜÜÜÜÜÜ¡Ü¨ÝÝ¸ÞÞÞcy;älig;ä²cy;äcuteè»ÃäÄiyÜÜrcè»Ãä;äot;ä°r;æraveè»ÃäÆ;apÜ Ü¯Ü¿ÄcgÜ´Ü·r;äªinaryI;ælieÃ³ÏÇ´Ý\0Ý¢Ä;eÝÝæ¬ÄgrÝÝral;æ«section;æisibleÄCTÝ¬Ý²omma;æ£imes;æ¢ÆgptÝ¿ÞÞon;ä®f;ìða;äcr;æilde;ä¨Ç«Þ\0Þcy;älè»ÃäÊcfosuÞ¬Þ·Þ¼ßßÄiyÞ±Þµrc;ä´;är;ìðpf;ìðÇ£ß\0ßr;ìð¥rcy;äkcy;äÎHJacfosß¤ß¨ß¬ß±ß½à à cy;ä¥cy;äppa;äÄeyß¶ß»dil;ä¶;är;ìðpf;ìðcr;ìð¦ÖJTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§à§à¨·à©cy;äè»<ä¼Êcmnprà ·à ¼à¡à¡à¡ute;ä¹bda;äg;æªlacetrf;ær;æÆaeyà¡à¡à¡¡ron;ä½dil;ä»;äÄfsà¡¨à¥°tÔACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥Îà¥ªÄnrà¢à¢gleBracket;æ¨rowÆ;BRà¢à¢à¢æar;æ¤ightArrow;æeiling;æoÇµà¢·\0à£bleBracket;æ¦nÇà£\0à£eeVector;æ¥¡ectorÄ;Bà£à£æar;æ¥loor;æightÄAVà£¯à£µrrow;æector;æ¥Äerà¤à¤eÆ;AVà¤à¤à¤æ£rrow;æ¤ector;æ¥iangleÆ;BEà¤¤à¤¥à¤©æ²ar;æ§qual;æ´pÆDTVà¤·à¥à¥ownVector;æ¥eeVector;æ¥ ectorÄ;Bà¥à¥æ¿ar;æ¥ectorÄ;Bà¥¥à¥¦æ¼ar;æ¥ightÃ¡ÎsÌEFGLSTà¥¾à¦à¦à¦à¦¢à¦­qualGreater;æullEqual;æ¦reater;æ¶ess;æª¡lantEqual;æ©½ilde;æ²r;ìðÄ;eà¦½à¦¾æftarrow;æidot;ä¿Ænpwà§à¨à¨gÈLRlrà§à§·à¨à¨eftÄARà§¦à§¬rrow;æµightArrow;æ·ightArrow;æ¶eftÄarÎ³à¨ightÃ¡Î¿ightÃ¡Ïf;ìðerÄLRà¨¢à¨¬eftArrow;æightArrow;æÆchtà¨¾à©à©Ã²à¡;æ°rok;ä;æªÐacefiosuà©à©à© à©·à©¼àªàªàªp;æ¤y;äÄdlà©¥à©¯iumSpace;ælintrf;æ³r;ìðnusPlus;æpf;ìðcÃ²à©¶;äÒJacefostuàª£àª§àª­à«à¬à¬à¶à¶à¶cy;äcute;äÆaeyàª´àª¹àª¾ron;ädil;ä;äÆgswà«à«°à¬ativeÆMTVà«à«à«¨ediumSpace;æhiÄcnà«¦à«Ã«à«eryThiÃ®à«tedÄGLà«¸à¬reaterGreateÃ²Ù³essLesÃ³à©Line;är;ìðÈBnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä f;æÚ;CDEGHLNPRSTVà­à­à­ªà­¼à®¡à¯«à°à±à²à²¦à³àµ¡à¶æ«¬Äouà­à­¤ngruent;æ¢pCap;æ­oubleVerticalBar;æ¦Ælqxà®à®à®ement;æualÄ;Tà®à®æ ilde;ìâÌ¸ists;æreaterÎ;EFGLSTà®¶à®·à®½à¯à¯à¯à¯¥æ¯qual;æ±ullEqual;ìâ§Ì¸reater;ìâ«Ì¸ess;æ¹lantEqual;ìâ©¾Ì¸ilde;æµumpÅà¯²à¯½ownHump;ìâÌ¸qual;ìâÌ¸eÄfsà°à°§tTriangleÆ;BEà°à°à°¡æªar;ìâ§Ì¸qual;æ¬sÌ;EGLSTà°µà°¶à°¼à±à±à±æ®qual;æ°reater;æ¸ess;ìâªÌ¸lantEqual;ìâ©½Ì¸ilde;æ´estedÄGLà±¨à±¹reaterGreater;ìâª¢Ì¸essLess;ìâª¡Ì¸recedesÆ;ESà²à²à²æqual;ìâª¯Ì¸lantEqual;æ Äeià²«à²¹verseElement;æghtTriangleÆ;BEà³à³à³æ«ar;ìâ§Ì¸qual;æ­Äquà³à´uareSuÄbpà³¨à³¹setÄ;Eà³°à³³ìâÌ¸qual;æ¢ersetÄ;Eà´à´ìâÌ¸qual;æ£Æbcpà´à´¤àµsetÄ;Eà´à´ìââqual;æceedsÈ;ESTà´²à´³à´»àµæqual;ìâª°Ì¸lantEqual;æ¡ilde;ìâ¿Ì¸ersetÄ;Eàµàµìââqual;æildeÈ;EFTàµ®àµ¯àµµàµ¿æqual;æullEqual;æilde;æerticalBar;æ¤cr;ìð©ildeè»Ãä;äÜEacdfgmoprstuvà¶½à·à·à·à·à· à·§à·¼à¸à¸ à¸¢à¸²à¸¿à¹lig;äcuteè»ÃäÄiyà·à·rcè»Ãä;äblac;är;ìðraveè»ÃäÆaeià·®à·²à·¶cr;äga;ä©cron;äpf;ìðenCurlyÄDQà¸à¸oubleQuote;æuote;æ;æ©Äclà¸§à¸¬r;ìðªashè»ÃäiÅ¬à¸·à¸¼deè»Ãäes;æ¨·mlè»ÃäerÄBPà¹à¹ Äarà¹à¹r;æ¾acÄekà¹à¹;æet;æ´arenthesis;æÒacfhilorsà¹¿àºàºàºàºàºàºàº°à»¼rtialD;æy;är;ìði;ä¦;ä usMinus;ä±Äipàº¢àº­ncareplanÃ¥Úf;æÈ;eioàº¹àººà» à»¤æª»cedesÈ;ESTà»à»à»à»æºqual;æª¯lantEqual;æ¼ilde;æ¾me;æ³Ädpà»©à»®uct;æortionÄ;aÈ¥à»¹l;æÄcià¼à¼r;ìð«;ä¨ÈUfosà¼à¼à¼à¼OTè»"ä¢r;ìðpf;æcr;ìð¬ØBEacefhiorsuà¼¾à½à½à½ à½³à¾§à¾ªà¾­áá©á´á¾arr;æ¤Gè»Â®ä®Æcnrà½à½à½ute;äg;æ«rÄ;tà½à½æ l;æ¤Æaeyà½§à½¬à½±ron;ädil;ä;ä Ä;và½¸à½¹æerseÄEUà¾à¾Älqà¾à¾ement;æuilibrium;æpEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtÐACDFTUVaà¿à¿«à¿³á¢á¨ááÏÄnrà¿à¿gleBracket;æ©rowÆ;BLà¿à¿à¿¡æar;æ¥eftArrow;æeiling;æoÇµà¿¹\0ábleBracket;æ§nÇá\0áeeVector;æ¥ectorÄ;Bááæar;æ¥loor;æÄerá­áeÆ;AVáµá¶á¼æ¢rrow;æ¦ector;æ¥iangleÆ;BEáááæ³ar;æ§qual;æµpÆDTVá£á®á¸ownVector;æ¥eeVector;æ¥ectorÄ;Bááæ¾ar;æ¥ectorÄ;Bááæar;æ¥Äpuááf;ændImplies;æ¥°ightarrow;æÄchá¹á¼r;æ;æ±leDelayed;æ§´ÚHOacfhimoqstuá¤á±á·á½ááááá¡á§áµá»á¿ÄCcá©á®Hcy;ä©y;ä¨FTcy;ä¬cute;äÊ;aeiyáááááæª¼ron;ä dil;ärc;ä;ä¡r;ìðortÈDLRUáªá´á¾áownArrowÂ»ÐeftArrowÂ»à¢ightArrowÂ»à¿pArrow;ægma;ä£allCircle;æpf;ìðÉ²á­\0\0á°t;æareÈ;ISUá»á¼áá¯æ¡ntersection;æuÄbpáásetÄ;Eááæqual;æersetÄ;Eá¨á©æqual;ænion;æcr;ìð®ar;æÈbcmpááááÄ;sááæetÄ;Eááqual;æÄchá áeedsÈ;ESTá­á®á´á¿æ»qual;æª°lantEqual;æ½ilde;æ¿ThÃ¡à¾;æÆ;esááá£ærsetÄ;Eááæqual;æetÂ»áÖHRSacfhiorsá¾ááááá±á¶ááááORNè»ÃäADE;æ¢ÄHcáácy;äy;ä¦Äbuáá;ä;ä¤Æaeyá¥áªá¯ron;ä¤dil;ä¢;ä¢r;ìðÄeiá»áÇ²á\0áefore;æ´a;äÄcnáákSpace;ìââSpace;ældeÈ;EFTá«á¬á²á¼æ¼qual;æullEqual;æilde;æpf;ìðipleDot;æÄctáár;ìð¯rok;ä¦à«¡á·ááá¦\0á¬á±\0\0\0\0\0á¸á½á·á\0á¿áááÄcrá»áuteè»ÃärÄ;oááæcir;æ¥rÇ£á\0áy;äve;ä¬Äiyáá£rcè»Ãä;ä£blac;ä°r;ìðraveè»Ãäacr;äªÄdiáá©erÄBPááÄaráár;äacÄekáá;æet;æµarenthesis;æonÄ;Pá°á±ælus;æÄgpá»á¿on;ä²f;ìðÐADETadpsáá®á¸áÏ¨ááá³rrowÆ;BDáá á¤ar;æ¤ownArrow;æownArrow;æquilibrium;æ¥®eeÄ;Aááæ¥rrow;æ¥ownÃ¡Ï³erÄLRáá¨eftArrow;æightArrow;æiÄ;lá¹áºäon;ä¥ing;ä®cr;ìð°ilde;ä¨mlè»ÃäÒDbcdefosvá§á¬á°á³á¾ááááash;æ«ar;æ««y;äashÄ;lá»á¼æ©;æ«¦Äeráá;æÆbtyáááºar;æÄ;iáácalÈBLSTá¡á¥áªá´ar;æ£ine;ä¼eparator;æilde;æThinSpace;ær;ìðpf;ìðcr;ìð±dash;æªÊcefosá§á¬á±á¶á¼irc;ä´dge;ær;ìðpf;ìðcr;ìð²Èfiosáááár;ìð;äpf;ìðcr;ìð³ÒAIUacfosuá±áµá¹á½ááááá cy;ä¯cy;äcy;ä®cuteè»ÃäÄiyáárc;ä¶;ä«r;ìðpf;ìðcr;ìð´ml;ä¸ÐHacdefosáµá¹á¿áááá á¤cy;äcute;ä¹Äayááron;ä½;äot;ä»Ç²á\0áoWidtÃ¨à«a;är;æ¨pf;æ¤cr;ìðµà¯¡ááá\0á°á¶á¿\0\0\0\0ááá«áá­\0ááá²á¹\0á¾cuteè»Ã¡ä¡reve;äÌ;Ediuyááá¡á£á¨á­æ¾;ìâ¾Ì³;æ¿rcè»Ã¢ä¢teè»Â´Ì;ä°ligè»Ã¦ä¦Ä;rÂ²áº;ìðraveè»Ã ä ÄepááÄfpáásym;æµÃ¨áha;ä±ÄapácÄclá¤á§r;äg;æ¨¿É¤á°\0\0áÊ;adsváºá»á¿ááæ§nd;æ©;æ©lope;æ©;æ©Î;elmrszááááá¿ááæ ;æ¦¤eÂ»ásdÄ;aá¥á¦æ¡Ñ¡á°á²á´á¶á¸áºá¼á¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ;vááæbÄ;dááæ¾;æ¦Äptááh;æ¢Â»Â¹arr;æ¼Ägpá£á§on;äf;ìðÎ;Eaeiopáá»á½áááá;æ©°cir;æ©¯;æd;æs;ä§roxÄ;eááÃ±áingè»Ã¥ä¥Æctyá¡á¦á¨r;ìð¶;äªmpÄ;eáá¯Ã±Êildeè»Ã£ä£mlè»Ã¤ä¤ÄciááoninÃ´É²nt;æ¨à Nabcdefiklnoprsuá­á±á°á¼ááá¸á½á á¦á ¹á¡áá¤½á¥á¥°ot;æ«­Äcrá¶ákÈcepsááááong;æpsilon;ä¶rime;æµimÄ;eááæ½q;æÅ¶á¢á¦ee;æ½edÄ;gá¬á­æeÂ»á­rkÄ;táá·brk;æ¶Äoyáá;ä±quo;æÊcmprtááá¡á¤á¨ausÄ;eÄÄptyv;æ¦°sÃ©ánoÃµÄÆahwá¯á±á³;ä²;æ¶een;æ¬r;ìðgÎcostuvwááá³ááááÆaiuáááÃ°Ý rc;æ¯pÂ»á±Ædptá¤á¨á­ot;æ¨lus;æ¨imes;æ¨É±á¹\0\0á¾cup;æ¨ar;æriangleÄduááown;æ½p;æ³plus;æ¨eÃ¥áÃ¥á­arow;æ¤Æakoá­á ¦á µÄcná²á £kÆlstáºÖ«á ozenge;æ§«riangleÈ;dlrá á á á æ´own;æ¾eft;æight;æ¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ;æ4;æck;æÄeoá ¾á¡Ä;qá¡á¡ì=â¥uiv;ìâ¡â¥t;æÈptwxá¡á¡á¡§á¡¬f;ìðÄ;táá¡£omÂ»átie;æØDHUVbdhmptuvá¢á¢á¢ªá¢»á£á£á£¬á£¿á¤á¤á¤á¤¡ÈLRlrá¢á¢á¢á¢;æ;æ;æ;æÊ;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ;æ¦;æ©;æ¤;æ§ÈLRlrá¢³á¢µá¢·á¢¹;æ;æ;æ;æÎ;HLRhlrá£á£á£á£á£á£á£æ;æ¬;æ£;æ ;æ«;æ¢;æox;æ§ÈLRlrá£¤á£¦á£¨á£ª;æ;æ;æ;æÊ;DUduÚ½á£·á£¹á£»á£½;æ¥;æ¨;æ¬;æ´inus;ælus;æimes;æ ÈLRlrá¤á¤á¤á¤;æ;æ;æ;æÎ;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ;æª;æ¡;æ;æ¼;æ¤;æÄevÄ£á¥barè»Â¦ä¦Èceioá¥á¥á¥á¥ r;ìð·mi;æmÄ;eáálÆ;bhá¥¨á¥©á¥«ä;æ§sub;æÅ¬á¥´á¥¾lÄ;eá¥¹á¥ºæ¢tÂ»á¥ºpÆ;EeÄ¯á¦á¦;æª®Ä;qÛÛà³¡á¦§\0á§¨á¨á¨á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­\0á¯½\0á°Æcprá¦­á¦²á§ute;äÌ;abcdsá¦¿á§á§á§á§á§æ©nd;æ©rcup;æ©Äauá§á§p;æ©p;æ©ot;æ©;ìâ©ï¸Äeoá§¢á§¥t;æÃ®ÚÈaeiuá§°á§»á¨á¨Ç°á§µ\0á§¸s;æ©on;ädilè»Ã§ä§rc;äpsÄ;sá¨á¨æ©m;æ©ot;äÆdmná¨á¨ á¨¦ilè»Â¸Æ­ptyv;æ¦²tèÂ¢;eá¨­á¨®ä¢rÃ¤Æ²r;ìð Æceiá¨½á©á©y;äckÄ;má©á©æarkÂ»á©;ärÎ;Ecefmsá©á© á©¢á©«áª¤áªªáª®æ;æ§Æ;elá©©á©ªá©­äq;æeÉ¡á©´\0\0áªrrowÄlrá©¼áªeft;æºight;æ»ÊRSacdáªáªáªáªáªÂ»à½;æst;æirc;æash;ænint;æ¨id;æ«¯cir;æ§ubsÄ;uáª»áª¼æ£itÂ»áª¼Ë¬á«á«á«º\0á¬onÄ;eá«á«äºÄ;qÃÃÉ­á«\0\0á«¢aÄ;tá«á«ä¬;äÆ;flá«¨á«©á««æÃ®á eÄmxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬Ä;dá»á¬ot;æ©­nÃ´ÉÆfryá¬á¬á¬;ìðoÃ¤ÉèÂ©;sÅá¬r;æÄaoá¬¥á¬©rr;æµss;æÄcuá¬²á¬·r;ìð¸Äbpá¬¼á­Ä;eá­á­æ«;æ«Ä;eá­á­æ«;æ«dot;æ¯Îdelprvwá­ á­¬á­·á®á®¬á¯á¯¹arrÄlrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æc;æarrÄ;pá­¿á®æ¶;æ¤½Ì;bcdosá®á®á®á®¡á®¥á®¨æªrcap;æ©Äauá®á®p;æ©p;æ©ot;ær;æ©;ìâªï¸Èalrvá®µá®¿á¯á¯£rrÄ;má®¼á®½æ·;æ¤¼yÆevwá¯á¯á¯qÉ°á¯\0\0á¯reÃ£á­³uÃ£á­µee;æedge;æenè»Â¤ä¤earrowÄlrá¯®á¯³eftÂ»á®ightÂ»á®½eÃ¤á¯Äciá°á°oninÃ´Ç·nt;æ±lcty;æ­à¦AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²á²á²¬á²·á³»á³¿á´áµ»á¶á¶«á¶»á·á·rÃ²Îar;æ¥¥Èglrsá±á±á±á±ger;æ eth;æ¸Ã²á³hÄ;vá±á±æÂ»à¤Å«á±¡á±§arow;æ¤aÃ£ÌÄayá±®á±³ron;ä;ä´Æ;aoÌ²á±¼á²ÄgrÊ¿á²r;ætseq;æ©·Æglmá²á²á²è»Â°ä°ta;ä´ptyv;æ¦±Äirá²£á²¨sht;æ¥¿;ìð¡arÄlrá²³á²µÂ»à£Â»áÊaegsvá³Í¸á³á³á³ mÆ;osÌ¦á³á³ndÄ;sÌ¦á³uit;æ¦amma;äin;æ²Æ;ioá³§á³¨á³¸ä·deèÃ·;oá³§á³°ntimes;ænÃ¸á³·cy;äcÉ¯á´\0\0á´rn;æop;æÊlptuwá´á´á´¢áµáµlar;ä¤f;ìðÊ;empsÌá´­á´·á´½áµqÄ;dÍá´³ot;æinus;æ¸lus;æquare;æ¡blebarwedgÃ¥ÃºnÆadhá®áµáµ§ownarrowÃ³á²arpoonÄlráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶karoÃ·à½É¯á¶\0\0á¶rn;æop;æÆcotá¶á¶£á¶¦Äryá¶á¶¡;ìð¹;äl;æ§¶rok;äÄdrá¶°á¶´ot;æ±iÄ;fá¶ºá æ¿Äahá·á·rÃ²Ð©aÃ²à¾¦angle;æ¦¦Äciá·á·y;ägrarr;æ¿à¤Dacdefglmnopqrstuxá¸á¸á¸á¸¸Õ¸á¸¼á¹á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½á½á½ÄDoá¸á´´oÃ´á²Äcsá¸á¸uteè»Ã©ä©ter;æ©®Èaioyá¸¢á¸§á¸±á¸¶ron;ärÄ;cá¸­á¸®æè»Ãªäªlon;æ;äot;äÄDrá¹á¹ot;æ;ìð¢Æ;rsá¹á¹á¹æªaveè»Ã¨ä¨Ä;dá¹á¹æªot;æªÈ;ilsá¹ªá¹«á¹²á¹´æªnters;æ§;æÄ;dá¹¹á¹ºæªot;æªÆapsáºáºáºcr;ätyÆ;sváºáºáºæetÂ»áºpÄ1;áºáº¤Ä³áº¡áº£;æ;ææÄgsáºªáº¬;äp;æÄgpáº´áº¸on;äf;ìðÆalsá»á»á»rÄ;sá»á»æl;æ§£us;æ©±iÆ;lvá»á»á»äµonÂ»á»;äµÈcsuvá»ªá»³á¼á¼£Äioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕantÄglá¼á¼trÂ»á¹essÂ»á¹ºÆaeiá¼á¼á¼ls;ä½st;ævÄ;DÈµá¼ D;æ©¸parsl;æ§¥ÄDaá¼¯á¼³ot;ærr;æ¥±Æcdiá¼¾á½á»¸r;æ¯oÃ´ÍÄahá½á½;ä·è»Ã°ä°Ämrá½á½lè»Ã«ä«o;æ¬Æcipá½¡á½¤á½§l;ä¡sÃ´Õ®Äeoá½¬á½´ctatioÃ®ÕnentialÃ¥Õ¹à§¡á¾\0á¾\0á¾¡á¾§\0\0á¿á¿\0á¿\0á¿¦á¿ªâ\0ââllingdotseÃ±á¹y;ämale;æÆilrá¾­á¾³á¿lig;èï¬É©á¾¹\0\0á¾½g;èï¬ig;èï¬;ìð£lig;èï¬lig;ìfjÆaltá¿á¿á¿¡t;æ­ig;èï¬ns;æ±of;äÇ°á¿®\0á¿³f;ìðÄakÖ¿á¿·Ä;vá¿¼á¿½æ;æ«artint;æ¨ÄaoââÄcsââÎ±ââ°â¸ââ\0âÎ²â¢â¥â§âªâ¬\0â®è»Â½ä½;æè»Â¼ä¼;æ;æ;æÆ³â´\0â¶;æ;æÊ´â¾â\0\0âè»Â¾ä¾;æ;æ5;æÆ¶â\0â;æ;æ8;æl;æwn;æ¢cr;ìð»à¢Eabcdefgijlnorstvââââ¥â°â´â°âµâºâ¿âââ¸Ìâ¾ââÄ;lÙâ;æªÆcmpâââute;äµmaÄ;dâá³ä³;æªreve;äÄiyâªâ®rc;ä;ä³ot;ä¡È;lqsØ¾Ùâ½âÆ;qsØ¾ÙâlanÃ´Ù¥È;cdlÙ¥âââ¥c;æª©otÄ;oââæªÄ;lâ¢â£æª;æªÄ;eâªâ­ìâï¸s;æªr;ìð¤Ä;gÙ³Ømel;æ·cy;äÈ;EajÙâââ;æª;æª¥;æª¤ÈEaesâââ©â´;æ©pÄ;pâ£â¤æªroxÂ»â¤Ä;qâ®â¯æªÄ;qâ®âim;æ§pf;ìðÄciââr;æmÆ;elÙ«ââ;æª;æªè>;cdlqr×®â âªâ®â³â¹Äciâ¥â§;æª§r;æ©ºot;æPar;æ¦uest;æ©¼ÊadelsââªâÙâÇ°â\0âproÃ¸âr;æ¥¸qÄlqØ¿âlesÃ³âiÃ­Ù«Äenâ£â­rtneqq;ìâ©ï¸ÃâªÔAabcefkosyâââ±âµâºâââ¯â¨â½rÃ²Î ÈilmrâââârsÃ°áfÂ»â¤ilÃ´Ú©Ädrâ â¤cy;äÆ;cwà£´â«â¯ir;æ¥;æ­ar;æirc;ä¥ÆalrââârtsÄ;uââæ¥itÂ»âlip;æ¦con;æ¹r;ìð¥sÄewâ£â©arow;æ¤¥arow;æ¤¦Êamoprâºâ¾âââ£rr;æ¿tht;æ»kÄlrââeftarrow;æ©ightarrow;æªf;ìðbar;æÆcltâ¯â´â¸r;ìð½asÃ¨â´rok;ä§Äbpââull;æhenÂ»á±à«¡â£\0âª\0â¸ââ\0ââ³\0\0â¸â¢â§â¢â¿\0ââªâ´cuteè»Ã­ä­Æ;iyÝ±â°âµrcè»Ã®ä®;ä¸Äcxâ¼â¿y;äµclè»Â¡ä¡ÄfrÎâ;ìð¦raveè»Ã¬ä¬È;inoÜ¾ââ©â®Äinâ¢â¦nt;æ¨t;æ­fin;æ§ta;æ©lig;ä³Æaopâ¾ââÆcgtâââr;ä«ÆelpÜââinÃ¥ÞarÃ´Ü h;ä±f;æ·ed;äµÊ;cfotÓ´â¬â±â½âare;æinÄ;tâ¸â¹æie;æ§doÃ´âÊ;celpÝââââ¡al;æºÄgrââerÃ³á£Ã£âarhk;æ¨rod;æ¨¼Ècgptâ¯â²â¶â»y;äon;ä¯f;ìða;ä¹uestè»Â¿ä¿Äciââr;ìð¾nÊ;EdsvÓ´âââ¡Ó³;æ¹ot;æµÄ;vâ¦â§æ´;æ³Ä;iÝ·â®lde;ä©Ç«â¸\0â¼cy;älè»Ã¯ä¯Ìcfmosuââââ¡â§âµÄiyâârc;äµ;ä¹r;ìð§ath;ä·pf;ìðÇ£â¬\0â±r;ìð¿rcy;äkcy;äÐacfghjosâââ¢â§â­â±âµâ»ppaÄ;vââäº;ä°Äeyââ dil;ä·;äºr;ìð¨reen;ä¸cy;äcy;äpf;ìðcr;ìðà®ABEHabcdefghjlmnoprstuvâ°ââââââ½âââââ¥â¹â½ââ²âââ¨âââ â Æartâ·âºâ¼rÃ²à§Ã²Îail;æ¤arr;æ¤Ä;gà¦â;æªar;æ¥¢à¥£â¥\0âª\0â±\0\0\0\0\0âµâº\0âââ\0â¹ute;äºmptyv;æ¦´raÃ®à¡bda;ä»gÆ;dlà¢ââ;æ¦Ã¥à¢;æªuoè»Â«ä«rÐ;bfhlpstà¢ââ¦â©â«â®â±âµÄ;fà¢â£s;æ¤s;æ¤Ã«âp;æ«l;æ¤¹im;æ¥³l;æ¢Æ;aeâ¿ââæª«il;æ¤Ä;sââæª­;ìâª­ï¸Æabrââârr;æ¤rk;æ²Äakâ¢â¬cÄekâ¨âª;ä»;äÄesâ±â³;æ¦lÄduâ¹â»;æ¦;æ¦Èaeuyââââron;ä¾Ädiââil;ä¼Ã¬à¢°Ã¢â©;ä»Ècqrsâ£â¦â­â½a;æ¤¶uoÄ;rà¸áÄduâ²â·har;æ¥§shar;æ¥h;æ²Ê;fgqsââà¦â³â¿æ¤tÊahlrtââ¤â·ââ¨rrowÄ;tà¢â¡aÃ©â¶arpoonÄduâ¯â´ownÂ»ÑpÂ»à¥¦eftarrows;æightÆahsââârrowÄ;sà£´à¢§arpoonÃ³à¾quigarroÃ·â°hreetimes;æÆ;qsâà¦âºlanÃ´à¦¬Ê;cdgsà¦¬ââââ¨c;æª¨otÄ;oââæ©¿Ä;rââæª;æªÄ;eâ¢â¥ìâï¸s;æªÊadegsâ³â¹â½ââpproÃ¸âot;æqÄgqââÃ´à¦gtÃ²âÃ´à¦iÃ­à¦²Æilrâà£¡âsht;æ¥¼;ìð©Ä;Eà¦â£;æªÅ¡â©â¶rÄduâ²â®Ä;là¥¥â³;æ¥ªlk;æcy;äÊ;achtà©âââârÃ²âorneÃ²á´ard;æ¥«ri;æºÄioââ¤dot;äustÄ;aâ¬â­æ°cheÂ»â­ÈEaesâ»â½ââ;æ¨pÄ;pââæªroxÂ»âÄ;qââæªÄ;qââ»im;æ¦Ðabnoptwzâ©â´â·ââ¯âââÄnrâ®â±g;æ¬r;æ½rÃ«à£gÆlmrâ¿ââeftÄarà§¦âightÃ¡à§²apsto;æ¼ightÃ¡à§½parrowÄlrâ¥â©efÃ´â­ight;æ¬Æaflâ¶â¹â½r;æ¦;ìðus;æ¨­imes;æ¨´Å¡ââst;æÃ¡áÆ;efââá ængeÂ»âarÄ;lâ¤â¥ä¨t;æ¦Êachmtâ³â¶â¼âârÃ²à¢¨orneÃ²á¶arÄ;dà¾â;æ¥­;æri;æ¿Ìachiqtââà©â¢â®â»quo;æ¹r;ìðmÆ;egà¦²âªâ¬;æª;æªÄbuâªâ³oÄ;rà¸â¹;ærok;äè<;cdhilqrà «ââ¹ââ â¥âªâ°Äciââ;æª¦r;æ©¹reÃ¥â²mes;æarr;æ¥¶uest;æ©»ÄPiâµâ¹ar;æ¦Æ;efâ à¤­á ærÄduâ â shar;æ¥har;æ¥¦Äenâ â ¡rtneqq;ìâ¨ï¸Ãâ ÜDacdefhilnopsuâ¡â¡â¢â¢â¢â¢ â¢¥â¢¨â£â£¢â£¤àªâ£³â¤Dot;æºÈclprâ¡â¡â¡£â¡½rè»Â¯ä¯Äetâ¡â¡;æÄ;eâ¡â¡æ seÂ»â¡Ä;sá»â¡¨toÈ;dluá»â¡³â¡·â¡»owÃ®ÒefÃ´à¤Ã°áker;æ®Äoyâ¢â¢mma;æ¨©;ä¼ash;æasuredangleÂ»á¦r;ìðªo;æ§Æcdnâ¢¯â¢´â£roè»ÂµäµÈ;acdá¤â¢½â£â£sÃ´á§ir;æ«°otè»Â·ÆµusÆ;bdâ£á¤â£æÄ;uá´¼â£;æ¨ªÅ£â£â£¡p;æ«Ã²âÃ°àªÄdpâ£©â£®els;æ§f;ìðÄctâ£¸â£½r;ìðposÂ»áÆ;lmâ¤â¤â¤ä¼timap;æ¸à°GLRVabcdefghijlmoprstuvwâ¥â¥â¥¾â¦â¦â§â§©â¨â¨â©â©âªâªâª¤âª¨â¬â¬â­â­¿â®®â°´â±§â±¼â³©Ägtâ¥â¥;ìâÌ¸Ä;vâ¥à¯ìâ«âÆeltâ¥â¥²â¥¶ftÄarâ¥¡â¥§rrow;æightarrow;æ;ìâÌ¸Ä;vâ¥»à±ìâªâightarrow;æÄDdâ¦â¦ash;æ¯ash;æ®Êbcnptâ¦£â¦§â¦¬â¦±â§laÂ»Ëute;äg;ìâ âÊ;Eiopà¶â¦¼â§â§â§;ìâ©°Ì¸d;ìâÌ¸s;äroÃ¸à¶urÄ;aâ§â§æ®lÄ;sâ§à¬¸Ç³â§\0â§£pè»Â à¬·mpÄ;eà¯¹à°Êaeouyâ§´â§¾â¨â¨â¨Ç°â§¹\0â§»;æ©on;ädil;ängÄ;dàµ¾â¨ot;ìâ©­Ì¸p;æ©;ä½ash;æÎ;Aadqsxà®â¨©â¨­â¨»â©â©â©rr;ærÄhrâ¨³â¨¶k;æ¤¤Ä;oá²á°ot;ìâÌ¸uiÃ¶à­£Äeiâ©â©ar;æ¤¨Ã­à®istÄ;sà® à®r;ìð«ÈEestà¯â©¦â©¹â©¼Æ;qsà®¼â©­à¯¡Æ;qsà®¼à¯â©´lanÃ´à¯¢iÃ­à¯ªÄ;rà®¶âªÂ»à®·ÆAapâªâªâªrÃ²â¥±rr;æ®ar;æ«²Æ;svà¾âªà¾Ä;dâª¡âª¢æ¼;æºcy;äÎAEadestâª·âªºâª¾â«â«â«¶â«¹rÃ²â¥¦;ìâ¦Ì¸rr;ær;æ¥È;fqsà°»â«â«£â«¯tÄarâ«â«rroÃ·â«ightarroÃ·âªÆ;qsà°»âªºâ«ªlanÃ´à±Ä;sà±â«´Â»à°¶iÃ­à±Ä;rà°µâ«¾iÄ;eà°à°¥iÃ¤à¶Äptâ¬â¬f;ìðèÂ¬;inâ¬â¬â¬¶ä¬nÈ;Edvà®â¬¤â¬¨â¬®;ìâ¹Ì¸ot;ìâµÌ¸Ç¡à®â¬³â¬µ;æ·;æ¶iÄ;và²¸â¬¼Ç¡à²¸â­â­;æ¾;æ½Æaorâ­â­£â­©rÈ;astà­»â­â­â­lleÃ¬à­»l;ìâ«½â¥;ìâÌ¸lint;æ¨Æ;ceà²â­°â­³uÃ¥à²¥Ä;cà²â­¸Ä;eà²â­½Ã±à²ÈAaitâ®â®â®â®§rÃ²â¦rrÆ;cwâ®â®â®æ;ìâ¤³Ì¸;ìâÌ¸ghtarrowÂ»â®riÄ;eà³à³Îchimpquâ®½â¯â¯â¬à­¸â¯¤â¯¯È;cerà´²â¯à´·â¯uÃ¥àµ;ìðortÉ­â¬\0\0â¯arÃ¡â­mÄ;eàµ®â¯Ä;qàµ´àµ³suÄbpâ¯«â¯­Ã¥à³¸Ã¥à´Æbcpâ¯¶â°â°È;Eesâ¯¿â°à´¢â°æ;ìâ«Ì¸etÄ;eà´â°qÄ;qà´£â°cÄ;eà´²â°Ã±à´¸È;Eesâ°¢â°£àµâ°§æ;ìâ«Ì¸etÄ;eàµâ°®qÄ;qàµ â°£Ègilrâ°½â°¿â±â±Ã¬à¯ldeè»Ã±ä±Ã§à±iangleÄlrâ±â±eftÄ;eà°â±Ã±à°¦ightÄ;eà³â±¥Ã±à³Ä;mâ±¬â±­ä½Æ;esâ±´â±µâ±¹ä£ro;æp;æÒDHadgilrsâ²â²â²â²â²£â²°â²¶â³â³£ash;æ­arr;æ¤p;ìââash;æ¬Äetâ²¨â²¬;ìâ¥â;ì>ânfin;æ§ÆAetâ²½â³â³rr;æ¤;ìâ¤âÄ;râ³â³ì<âie;ìâ´âÄAtâ³â³rr;æ¤rie;ìâµâim;ìâ¼âÆAanâ³°â³´â´rr;ærÄhrâ³ºâ³½k;æ¤£Ä;oá§á¥ear;æ¤§ááª\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµâµ âµ¥âµ²â¶á¬\0\0â¶â¶«\0â·â·\0â·â¸â¸«â¸¾â¹Äcsâ´±áªuteè»Ã³ä³Äiyâ´¼âµrÄ;cáªâµè»Ã´ä´;ä¾Êabiosáª âµâµÇâµlac;äv;æ¨¸old;æ¦¼lig;äÄcrâµ©âµ­ir;æ¦¿;ìð¬Í¯âµ¹\0\0âµ¼\0â¶n;äaveè»Ã²ä²;æ§Äbmâ¶à·´ar;æ¦µÈacitâ¶â¶â¶¥â¶¨rÃ²áªÄirâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹;æ§Æaeiâ¶±â¶µâ¶¹cr;äga;äÆcdnâ·â·Çron;ä¿;æ¦¶pf;ìð Æaelâ·â·Çr;æ¦·rp;æ¦¹Î;adiosvâ·ªâ·«â·®â¸â¸â¸â¸æ¨rÃ²áªÈ;efmâ··â·¸â¸â¸æ©rÄ;oâ·¾â·¿æ´fÂ»â·¿è»Âªäªè»Âºäºgof;æ¶r;æ©lope;æ©;æ©Æcloâ¸â¸¡â¸§Ã²â¸ashè»Ã¸ä¸l;æiÅ¬â¸¯â¸´deè»ÃµäµesÄ;aÇâ¸ºs;æ¨¶mlè»Ã¶ä¶bar;æ½à«¡â¹\0â¹½\0âºâº\0âº¢âº¹\0\0â»àº\0â¼\0\0â¼«â¾¼\0â¿rÈ;astÐâ¹§â¹²àºèÂ¶;lâ¹­â¹®ä¶leÃ¬ÐÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊcimptâºâºâºá¡¥âºnt;ä¥od;ä®il;æ°enk;æ±r;ìð­Æimoâº¨âº°âº´Ä;vâº­âº®ä;ämaÃ´à©¶ne;æÆ;tvâº¿â»â»ächforkÂ»á¿½;äÄauâ»â»nÄckâ»â»kÄ;hâ´â»;æÃ¶â´sÒ;abcdemstâ»³â»´á¤â»¹â»½â¼â¼â¼â¼ä«cir;æ¨£ir;æ¨¢Äouáµâ¼;æ¨¥;æ©²nè»Â±àºim;æ¨¦wo;æ¨§Æipuâ¼â¼ â¼¥ntint;æ¨f;ìð¡ndè»Â£ä£Ô;Eaceinosuà»â¼¿â½â½â½â¾â¾â¾â½¾â¾¶;æª³p;æª·uÃ¥à»Ä;cà»â½Ì;acensà»â½â½â½¦â½¨â½¾pproÃ¸â½urlyeÃ±à»Ã±à»Æaesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ¨iÃ­à»meÄ;sâ¾àº®æ²ÆEasâ½¸â¾â½ºÃ°â½µÆdfpà»¬â¾â¾¯Æalsâ¾ â¾¥â¾ªlar;æ®ine;æurf;æÄ;tà»»â¾´Ã¯à»»rel;æ°Äciâ¿â¿r;ìð;äncsp;æÌfiopsuâ¿â¢â¿â¿¥â¿«â¿±r;ìð®pf;ìð¢rime;æcr;ìðÆaeoâ¿¸ããtÄeiâ¿¾ãrnionÃ³Ú°nt;æ¨stÄ;eããä¿Ã±á¼Ã´à¼àªABHabcdefhilmnoprstuxããããã ãã«ãã¢ã²ãããã¤ã©ãã®ã²ãã°ã·ÆartãããrÃ²á³Ã²Ïail;æ¤arÃ²á±¥ar;æ¥¤Îcdenqrtã¨ãµã¸ã¿ãããÄeuã­ã±;ìâ½Ì±te;äiÃ£á®mptyv;æ¦³gÈ;delà¿ããã;æ¦;æ¦¥Ã¥à¿uoè»Â»ä»rÖ;abcfhlpstwà¿ã¬ã¯ã·ã¹ã¼ã¾ããããp;æ¥µÄ;fà¿ ã´s;æ¤ ;æ¤³s;æ¤Ã«âÃ°â®l;æ¥im;æ¥´l;æ£;æÄaiããil;æ¤oÄ;nããæ¶alÃ³à¼Æabrã§ãªã®rÃ²á¥rk;æ³Äakã³ã½cÄekã¹ã»;ä½;äÄesãã;æ¦lÄduãã;æ¦;æ¦Èaeuyããã§ã©ron;äÄdiã¡ã¥il;äÃ¬à¿²Ã¢ãº;äÈclqsã´ã·ã½ãa;æ¤·dhar;æ¥©uoÄ;rÈÈh;æ³Æacgããà½lÈ;ipsà½¸ããánÃ¥á»arÃ´à¾©t;æ­Æilrã©á£ã®sht;æ¥½;ìð¯Äaoã·ãrÄduã½ã¿Â»Ñ»Ä;láã;æ¥¬Ä;vããä;ä±Ægnsãã¹ã¼htÌahlrstã¤ã°ããã¤ã®rrowÄ;tà¿ã­aÃ©ãarpoonÄduã»ã¿owÃ®ã¾pÂ»áeftÄahããrrowÃ³à¿ªarpoonÃ³Õightarrows;æquigarroÃ·ãhreetimes;æg;äingdotseÃ±á¼²ÆahmãããrÃ²à¿ªaÃ²Õ;æoustÄ;aããæ±cheÂ»ãmid;æ«®Èabptã²ã½ããÄnrã·ãºg;æ­r;æ¾rÃ«áÆaflãããr;æ¦;ìð£us;æ¨®imes;æ¨µÄapãã§rÄ;gã£ã¤ä©t;æ¦olint;æ¨arÃ²ã£Èachqã»ãá¼ãquo;æºr;ìðÄbuã»ãoÄ;rÈÈÆhirããã reÃ¥ã¸mes;æiÈ;eflãªáá ¡ã«æ¹tri;æ§luhar;æ¥¨;æàµ¡ãããã¬ã¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ããã­ã±ãã±\0ã\0\0ã³cute;äquÃ¯âºÔ;Eaceinpsyá­ã³ãµã¿ããããã¦ã©;æª´Ç°ãº\0ã¼;æª¸on;ä¡uÃ¥á¾Ä;dá³ãil;ärc;äÆEasããã;æª¶p;æªºim;æ©olint;æ¨iÃ­á;äotÆ;beã´áµãµæ;æ©¦ÎAacmstxãããããã£ã­rr;ærÄhrããÃ«â¨Ä;oà¨¶à¨´tè»Â§ä§i;ä»war;æ¤©mÄinã©Ã°nuÃ³Ã±t;æ¶rÄ;oã¶âìð°Èacoyãããã rp;æ¯Ähyããcy;ä;ärtÉ­ã\0\0ãiÃ¤á¤araÃ¬â¹¯è»Â­ä­Ägmã¨ã´maÆ;fvã±ã²ã²ä;äÐ;deglnprá«ãããããã¡ã¦ot;æ©ªÄ;qá±á°Ä;Eããæª;æª Ä;Eããæª;æªe;ælus;æ¨¤arr;æ¥²arÃ²á½Èaeitã¸ãããÄlsã½ãlsetmÃ©ãªhp;æ¨³parsl;æ§¤Ädlá£ãe;æ£Ä;eããæªªÄ;sã¢ã£æª¬;ìâª¬ï¸Æflpã®ã³ãtcy;äÄ;bã¸ã¹ä¯Ä;aã¾ã¿æ§r;æ¿f;ìð¤aÄdrãÐesÄ;uããæ itÂ»ãÆcsuã ã¹ãÄauã¥ã¯pÄ;sáã«;ìâï¸pÄ;sá´ãµ;ìâï¸uÄbpã¿ãÆ;esááãetÄ;eáãÃ±áÆ;esá¨á­ãetÄ;eá¨ãÃ±á®Æ;afá»ã¦Ö°rÅ¥ã«Ö±Â»á¼arÃ²áÈcemtã¹ã¾ããr;ìðtmÃ®Ã±iÃ¬ãarÃ¦á¾ÄarããrÄ;fãá¿æÄanãã­ightÄepã£ãªpsiloÃ®á» hÃ©âº¯sÂ»â¡Êbcmnpã»ãáããÒ;Edemnprsãããããã£ã¬ã±ã¶æ;æ«ot;æª½Ä;dáãot;æ«ult;æ«ÄEeã¨ãª;æ«;ælus;æª¿arr;æ¥¹Æeiuã½ããtÆ;enãããqÄ;qáãeqÄ;qã«ã¨m;æ«Äbpãã;æ«;æ«cÌ;acensá­ã¬ã²ã¹ã»ã¦pproÃ¸ãºurlyeÃ±á¾Ã±á³ÆaesãããpproÃ¸ãqÃ±ãg;æªÚ123;Edehlmnpsã©ã¬ã¯áã²ã´ãããããã¨ã­è»Â¹ä¹è»Â²ä²è»Â³ä³;æ«Äosã¹ã¼t;æª¾ub;æ«Ä;dá¢ãot;æ«sÄouããl;æb;æ«arr;æ¥»ult;æ«ÄEeã¤ã¦;æ«;ælus;æ«Æeiuã´ããtÆ;enáã¼ãqÄ;qá¢ã²eqÄ;qã§ã¤m;æ«Äbpãã;æ«;æ«ÆAanãã ã­rr;ærÄhrã¦ã¨Ã«â®Ä;oà¨«à¨©war;æ¤ªligè»Ãäà¯¡ããã áã³ã¹\0ã¾ã\0\0\0\0\0ãã\0ãã¬\0\0\0ãÉ²ã\0\0ãget;æ;ärÃ«à¹Æaeyã¦ã«ã°ron;ä¥dil;ä£;älrec;ær;ìð±Èeikoãããµã¼Ç²ã\0ãeÄ4fááaÆ;svãããä¸ym;äÄcnã¢ã²kÄasã¨ã®pproÃ¸áimÂ»á¬sÃ°áÄasãºã®Ã°árnè»Ã¾ä¾Ç¬Ìãâ§esèÃ;bdãããäÄ;aá¤ãr;æ¨±;æ¨°Æepsã¡ã£ãÃ¡â©È;bcfÒã¬ã°ã´ot;æ¶ir;æ«±Ä;oã¹ã¼ìð¥rk;æ«Ã¡ã¢rime;æ´Æaipããã¤dÃ¥áÎadempstã¡ããããããngleÊ;dlqrã°ã±ã¶ããæµownÂ»á¶»eftÄ;eâ ã¾Ã±à¤®;æightÄ;eãªãÃ±áot;æ¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æchtã²ã½ãÄryã·ã»;ìð;äcy;ärok;ä§ÄioããxÃ´á·headÄlrãã eftarroÃ·à¡ightarrowÂ»à½à¤AHabcdfghlmoprstuwãããã¤ã°ã¼ã ã ã £ã ´ã¡ã¡ã¡«ã¢©ã£ã£ã£ªã£¶rÃ²Ï­ar;æ¥£Äcrãã¢uteè»ÃºäºÃ²árÇ£ãª\0ã­y;äve;ä­Äiyãµãºrcè»Ã»ä»;äÆabhã ã ã rÃ²á­lac;ä±aÃ²áÄirã ã sht;æ¥¾;ìð²raveè»Ã¹ä¹Å¡ã §ã ±rÄlrã ¬ã ®Â»à¥Â»álk;æÄctã ¹ã¡É¯ã ¿\0\0ã¡rnÄ;eã¡ã¡ærÂ»ã¡op;æri;æ¸Äalã¡ã¡cr;ä«è»Â¨ÍÄgpã¡¢ã¡¦on;ä³f;ìð¦Ìadhlsuáã¡¸ã¡½á²ã¢ã¢ ownÃ¡á³arpoonÄlrã¢ã¢efÃ´ã ­ighÃ´ã ¯iÆ;hlã¢ã¢ã¢äÂ»áºonÂ»ã¢parrows;æÆcitã¢°ã£ã£É¯ã¢¶\0\0ã£rnÄ;eã¢¼ã¢½ærÂ»ã¢½op;æng;ä¯ri;æ¹cr;ìðÆdirã£ã£ã£¢ot;æ°lde;ä©iÄ;fã°ã£¨Â»á Äamã£¯ã£²rÃ²ã¢¨lè»Ã¼ä¼angle;æ¦§ÞABDacdeflnoprszã¤ã¤ã¤©ã¤­ã¦µã¦¸ã¦½ã§ã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Änrã¤²ã¤·grt;æ¦Îeknprstã£ã¥ã¥ã¥ã¥ã¥¤ã¦appÃ¡âothinÃ§áºÆhirã«â»ã¥opÃ´â¾µÄ;há·ã¥¢Ã¯ãÄiuã¥©ã¥­gmÃ¡ã³Äbpã¥²ã¦setneqÄ;qã¥½ã¦ìâï¸;ìâ«ï¸setneqÄ;qã¦ã¦ìâï¸;ìâ«ï¸Ährã¦ã¦etÃ¡ãiangleÄlrã¦ªã¦¯eftÂ»à¤¥ightÂ»áy;ä²ashÂ»á¶Æelrã§ã§ã§Æ;beâ·ªã§ã§ar;æ»q;ælip;æ®Äbtã§á¨aÃ²á©r;ìð³trÃ©ã¦®suÄbpã§¯ã§±Â»à´Â»àµpf;ìð§roÃ°à»»trÃ©ã¦´Äcuã¨ã¨r;ìðÄbpã¨ã¨nÄEeã¦ã¨Â»ã¥¾nÄEeã¦ã¨Â»ã¦igzag;æ¦Îcefoprsã¨¶ã¨»ã©ã©ã©ã©¡ã©ªirc;äµÄdiã©ã©Äbgã©ã©ar;æ©eÄ;qáºã©;æerp;ær;ìð´pf;ìð¨Ä;eá¹ã©¦atÃ¨á¹cr;ìðà«£áãª\0ãª\0ãªãª\0\0ãªãª¨ãª«ãª¯\0\0ã«ã«\0ã«áátrÃ©ár;ìðµÄAaãªãªrÃ²ÏrÃ²à§¶;ä¾ÄAaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âis;æ»Ædptá¤ãªµãª¾Äflãªºá©;ìð©imÃ¥á²ÄAaã«ã«rÃ²ÏrÃ²à¨Äcqã«á¸r;ìðÄptáã«rÃ©áÐacefiosuã«°ã«½ã¬ã¬ã¬ã¬ã¬ã¬¡cÄuyã«¶ã«»teè»Ã½ä½;äÄiyã¬ã¬rc;ä·;änè»Â¥ä¥r;ìð¶cy;äpf;ìðªcr;ìðÄcmã¬¦ã¬©y;älè»Ã¿ä¿Ôacdefhioswã­ã­ã­ã­ã­¤ã­©ã­­ã­´ã­ºã®cute;äºÄayã­ã­ron;ä¾;ä·ot;ä¼Äetã­ã­¡trÃ¦áa;ä¶r;ìð·cy;ä¶grarr;æpf;ìð«cr;ìðÄjnã®ã®;æj;æ'.split("").map((e) => e.charCodeAt(0))
), al = new Uint16Array(
  // prettier-ignore
  "Èaglq	\x1BÉ­\0\0p;ä¦os;ä§t;ä¾t;ä¼uot;ä¢".split("").map((e) => e.charCodeAt(0))
);
var jn;
const sl = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), ol = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (jn = String.fromCodePoint) !== null && jn !== void 0 ? jn : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function ll(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = sl.get(e)) !== null && t !== void 0 ? t : e;
}
var fe;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(fe || (fe = {}));
const cl = 32;
var Ge;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ge || (Ge = {}));
function mr(e) {
  return e >= fe.ZERO && e <= fe.NINE;
}
function fl(e) {
  return e >= fe.UPPER_A && e <= fe.UPPER_F || e >= fe.LOWER_A && e <= fe.LOWER_F;
}
function hl(e) {
  return e >= fe.UPPER_A && e <= fe.UPPER_Z || e >= fe.LOWER_A && e <= fe.LOWER_Z || mr(e);
}
function dl(e) {
  return e === fe.EQUALS || hl(e);
}
var ce;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(ce || (ce = {}));
var ze;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(ze || (ze = {}));
class fa {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = ce.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ze.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = ce.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case ce.EntityStart:
        return t.charCodeAt(n) === fe.NUM ? (this.state = ce.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = ce.NamedEntity, this.stateNamedEntity(t, n));
      case ce.NumericStart:
        return this.stateNumericStart(t, n);
      case ce.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case ce.NumericHex:
        return this.stateNumericHex(t, n);
      case ce.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | cl) === fe.LOWER_X ? (this.state = ce.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = ce.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, u) {
    if (n !== r) {
      const a = r - n;
      this.result = this.result * Math.pow(u, a) + parseInt(t.substr(n, a), u), this.consumed += a;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (mr(u) || fl(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(u, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (mr(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(u, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === fe.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === ze.Strict)
      return 0;
    return this.emitCodePoint(ll(this.result), this.consumed), this.errors && (t !== fe.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let u = r[this.treeIndex], a = (u & Ge.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const i = t.charCodeAt(n);
      if (this.treeIndex = ml(r, u, this.treeIndex + Math.max(1, a), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === ze.Attribute && // We shouldn't have consumed any characters after the entity,
        (a === 0 || // And there should be no invalid characters.
        dl(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (u = r[this.treeIndex], a = (u & Ge.VALUE_LENGTH) >> 14, a !== 0) {
        if (i === fe.SEMI)
          return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess);
        this.decodeMode !== ze.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, u = (r[n] & Ge.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, u, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: u } = this;
    return this.emitCodePoint(n === 1 ? u[t] & ~Ge.VALUE_LENGTH : u[t + 1], r), n === 3 && this.emitCodePoint(u[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case ce.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ze.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case ce.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case ce.NumericHex:
        return this.emitNumericEntity(0, 3);
      case ce.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case ce.EntityStart:
        return 0;
    }
  }
}
function ha(e) {
  let t = "";
  const n = new fa(e, (r) => t += ol(r));
  return function(u, a) {
    let i = 0, o = 0;
    for (; (o = u.indexOf("&", o)) >= 0; ) {
      t += u.slice(i, o), n.startEntity(a);
      const c = n.write(
        u,
        // Skip the "&"
        o + 1
      );
      if (c < 0) {
        i = o + n.end();
        break;
      }
      i = o + c, o = c === 0 ? i + 1 : i;
    }
    const l = t + u.slice(i);
    return t = "", l;
  };
}
function ml(e, t, n, r) {
  const u = (t & Ge.BRANCH_LENGTH) >> 7, a = t & Ge.JUMP_TABLE;
  if (u === 0)
    return a !== 0 && r === a ? n : -1;
  if (a) {
    const l = r - a;
    return l < 0 || l >= u ? -1 : e[n + l] - 1;
  }
  let i = n, o = i + u - 1;
  for (; i <= o; ) {
    const l = i + o >>> 1, c = e[l];
    if (c < r)
      i = l + 1;
    else if (c > r)
      o = l - 1;
    else
      return e[l + u];
  }
  return -1;
}
ha(ca);
ha(al);
var R;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(R || (R = {}));
var nt;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(nt || (nt = {}));
var xe;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(xe || (xe = {}));
var _;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(_ || (_ = {}));
var s;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(s || (s = {}));
const pl = /* @__PURE__ */ new Map([
  [_.A, s.A],
  [_.ADDRESS, s.ADDRESS],
  [_.ANNOTATION_XML, s.ANNOTATION_XML],
  [_.APPLET, s.APPLET],
  [_.AREA, s.AREA],
  [_.ARTICLE, s.ARTICLE],
  [_.ASIDE, s.ASIDE],
  [_.B, s.B],
  [_.BASE, s.BASE],
  [_.BASEFONT, s.BASEFONT],
  [_.BGSOUND, s.BGSOUND],
  [_.BIG, s.BIG],
  [_.BLOCKQUOTE, s.BLOCKQUOTE],
  [_.BODY, s.BODY],
  [_.BR, s.BR],
  [_.BUTTON, s.BUTTON],
  [_.CAPTION, s.CAPTION],
  [_.CENTER, s.CENTER],
  [_.CODE, s.CODE],
  [_.COL, s.COL],
  [_.COLGROUP, s.COLGROUP],
  [_.DD, s.DD],
  [_.DESC, s.DESC],
  [_.DETAILS, s.DETAILS],
  [_.DIALOG, s.DIALOG],
  [_.DIR, s.DIR],
  [_.DIV, s.DIV],
  [_.DL, s.DL],
  [_.DT, s.DT],
  [_.EM, s.EM],
  [_.EMBED, s.EMBED],
  [_.FIELDSET, s.FIELDSET],
  [_.FIGCAPTION, s.FIGCAPTION],
  [_.FIGURE, s.FIGURE],
  [_.FONT, s.FONT],
  [_.FOOTER, s.FOOTER],
  [_.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [_.FORM, s.FORM],
  [_.FRAME, s.FRAME],
  [_.FRAMESET, s.FRAMESET],
  [_.H1, s.H1],
  [_.H2, s.H2],
  [_.H3, s.H3],
  [_.H4, s.H4],
  [_.H5, s.H5],
  [_.H6, s.H6],
  [_.HEAD, s.HEAD],
  [_.HEADER, s.HEADER],
  [_.HGROUP, s.HGROUP],
  [_.HR, s.HR],
  [_.HTML, s.HTML],
  [_.I, s.I],
  [_.IMG, s.IMG],
  [_.IMAGE, s.IMAGE],
  [_.INPUT, s.INPUT],
  [_.IFRAME, s.IFRAME],
  [_.KEYGEN, s.KEYGEN],
  [_.LABEL, s.LABEL],
  [_.LI, s.LI],
  [_.LINK, s.LINK],
  [_.LISTING, s.LISTING],
  [_.MAIN, s.MAIN],
  [_.MALIGNMARK, s.MALIGNMARK],
  [_.MARQUEE, s.MARQUEE],
  [_.MATH, s.MATH],
  [_.MENU, s.MENU],
  [_.META, s.META],
  [_.MGLYPH, s.MGLYPH],
  [_.MI, s.MI],
  [_.MO, s.MO],
  [_.MN, s.MN],
  [_.MS, s.MS],
  [_.MTEXT, s.MTEXT],
  [_.NAV, s.NAV],
  [_.NOBR, s.NOBR],
  [_.NOFRAMES, s.NOFRAMES],
  [_.NOEMBED, s.NOEMBED],
  [_.NOSCRIPT, s.NOSCRIPT],
  [_.OBJECT, s.OBJECT],
  [_.OL, s.OL],
  [_.OPTGROUP, s.OPTGROUP],
  [_.OPTION, s.OPTION],
  [_.P, s.P],
  [_.PARAM, s.PARAM],
  [_.PLAINTEXT, s.PLAINTEXT],
  [_.PRE, s.PRE],
  [_.RB, s.RB],
  [_.RP, s.RP],
  [_.RT, s.RT],
  [_.RTC, s.RTC],
  [_.RUBY, s.RUBY],
  [_.S, s.S],
  [_.SCRIPT, s.SCRIPT],
  [_.SEARCH, s.SEARCH],
  [_.SECTION, s.SECTION],
  [_.SELECT, s.SELECT],
  [_.SOURCE, s.SOURCE],
  [_.SMALL, s.SMALL],
  [_.SPAN, s.SPAN],
  [_.STRIKE, s.STRIKE],
  [_.STRONG, s.STRONG],
  [_.STYLE, s.STYLE],
  [_.SUB, s.SUB],
  [_.SUMMARY, s.SUMMARY],
  [_.SUP, s.SUP],
  [_.TABLE, s.TABLE],
  [_.TBODY, s.TBODY],
  [_.TEMPLATE, s.TEMPLATE],
  [_.TEXTAREA, s.TEXTAREA],
  [_.TFOOT, s.TFOOT],
  [_.TD, s.TD],
  [_.TH, s.TH],
  [_.THEAD, s.THEAD],
  [_.TITLE, s.TITLE],
  [_.TR, s.TR],
  [_.TRACK, s.TRACK],
  [_.TT, s.TT],
  [_.U, s.U],
  [_.UL, s.UL],
  [_.SVG, s.SVG],
  [_.VAR, s.VAR],
  [_.WBR, s.WBR],
  [_.XMP, s.XMP]
]);
function xt(e) {
  var t;
  return (t = pl.get(e)) !== null && t !== void 0 ? t : s.UNKNOWN;
}
const D = s, El = {
  [R.HTML]: /* @__PURE__ */ new Set([
    D.ADDRESS,
    D.APPLET,
    D.AREA,
    D.ARTICLE,
    D.ASIDE,
    D.BASE,
    D.BASEFONT,
    D.BGSOUND,
    D.BLOCKQUOTE,
    D.BODY,
    D.BR,
    D.BUTTON,
    D.CAPTION,
    D.CENTER,
    D.COL,
    D.COLGROUP,
    D.DD,
    D.DETAILS,
    D.DIR,
    D.DIV,
    D.DL,
    D.DT,
    D.EMBED,
    D.FIELDSET,
    D.FIGCAPTION,
    D.FIGURE,
    D.FOOTER,
    D.FORM,
    D.FRAME,
    D.FRAMESET,
    D.H1,
    D.H2,
    D.H3,
    D.H4,
    D.H5,
    D.H6,
    D.HEAD,
    D.HEADER,
    D.HGROUP,
    D.HR,
    D.HTML,
    D.IFRAME,
    D.IMG,
    D.INPUT,
    D.LI,
    D.LINK,
    D.LISTING,
    D.MAIN,
    D.MARQUEE,
    D.MENU,
    D.META,
    D.NAV,
    D.NOEMBED,
    D.NOFRAMES,
    D.NOSCRIPT,
    D.OBJECT,
    D.OL,
    D.P,
    D.PARAM,
    D.PLAINTEXT,
    D.PRE,
    D.SCRIPT,
    D.SECTION,
    D.SELECT,
    D.SOURCE,
    D.STYLE,
    D.SUMMARY,
    D.TABLE,
    D.TBODY,
    D.TD,
    D.TEMPLATE,
    D.TEXTAREA,
    D.TFOOT,
    D.TH,
    D.THEAD,
    D.TITLE,
    D.TR,
    D.TRACK,
    D.UL,
    D.WBR,
    D.XMP
  ]),
  [R.MATHML]: /* @__PURE__ */ new Set([D.MI, D.MO, D.MN, D.MS, D.MTEXT, D.ANNOTATION_XML]),
  [R.SVG]: /* @__PURE__ */ new Set([D.TITLE, D.FOREIGN_OBJECT, D.DESC]),
  [R.XLINK]: /* @__PURE__ */ new Set(),
  [R.XML]: /* @__PURE__ */ new Set(),
  [R.XMLNS]: /* @__PURE__ */ new Set()
}, pr = /* @__PURE__ */ new Set([D.H1, D.H2, D.H3, D.H4, D.H5, D.H6]);
_.STYLE, _.SCRIPT, _.XMP, _.IFRAME, _.NOEMBED, _.NOFRAMES, _.PLAINTEXT;
var E;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(E || (E = {}));
const ae = {
  DATA: E.DATA,
  RCDATA: E.RCDATA,
  RAWTEXT: E.RAWTEXT,
  SCRIPT_DATA: E.SCRIPT_DATA,
  PLAINTEXT: E.PLAINTEXT,
  CDATA_SECTION: E.CDATA_SECTION
};
function gl(e) {
  return e >= m.DIGIT_0 && e <= m.DIGIT_9;
}
function Ht(e) {
  return e >= m.LATIN_CAPITAL_A && e <= m.LATIN_CAPITAL_Z;
}
function Tl(e) {
  return e >= m.LATIN_SMALL_A && e <= m.LATIN_SMALL_Z;
}
function Ve(e) {
  return Tl(e) || Ht(e);
}
function ku(e) {
  return Ve(e) || gl(e);
}
function ln(e) {
  return e + 32;
}
function da(e) {
  return e === m.SPACE || e === m.LINE_FEED || e === m.TABULATION || e === m.FORM_FEED;
}
function yu(e) {
  return da(e) || e === m.SOLIDUS || e === m.GREATER_THAN_SIGN;
}
function bl(e) {
  return e === m.NULL ? x.nullCharacterReference : e > 1114111 ? x.characterReferenceOutsideUnicodeRange : aa(e) ? x.surrogateCharacterReference : oa(e) ? x.noncharacterCharacterReference : sa(e) || e === m.CARRIAGE_RETURN ? x.controlCharacterReference : null;
}
class Al {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = E.DATA, this.returnState = E.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new il(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new fa(ca, (r, u) => {
      this.preprocessor.pos = this.entityStartPos + u - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(x.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(x.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const u = bl(r);
        u && this._err(u, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, n = 0) {
    var r, u;
    (u = (r = this.handler).onParseError) === null || u === void 0 || u.call(r, this.preprocessor.getError(t, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: $.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: $.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: $.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: $.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (la(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const u = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        u[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(x.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = xt(t.tagName), t.type === $.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(x.endTagWithAttributes), t.selfClosing && this._err(x.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case $.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case $.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case $.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: $.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = da(t) ? $.WHITESPACE_CHARACTER : t === m.NULL ? $.NULL_CHARACTER : $.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken($.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = E.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? ze.Attribute : ze.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === E.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case E.DATA: {
        this._stateData(t);
        break;
      }
      case E.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case E.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case E.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case E.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case E.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case E.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case E.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case E.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case E.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case E.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case E.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case E.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case E.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case E.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case E.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case E.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case E.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case E.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case E.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case E.COMMENT: {
        this._stateComment(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case E.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case E.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case E.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case E.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case E.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case E.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case E.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case E.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case E.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case E.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case E.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case E.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.TAG_OPEN;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Ve(t))
      this._createStartTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case m.EXCLAMATION_MARK: {
          this.state = E.MARKUP_DECLARATION_OPEN;
          break;
        }
        case m.SOLIDUS: {
          this.state = E.END_TAG_OPEN;
          break;
        }
        case m.QUESTION_MARK: {
          this._err(x.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case m.EOF: {
          this._err(x.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(x.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = E.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Ve(t))
      this._createEndTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case m.GREATER_THAN_SIGN: {
          this._err(x.missingEndTagName), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(x.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(x.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.tagName += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Ht(t) ? ln(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Ve(t) ? (this.state = E.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.BEFORE_ATTRIBUTE_NAME, !1;
      case m.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.SELF_CLOSING_START_TAG, !1;
      case m.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = E.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Ve(t) ? (this.state = E.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case m.SOLIDUS: {
        this.state = E.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = E.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Ve(t) ? (this.state = E.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ve(t) ? (this._emitChars("<"), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Ve(t) ? (this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(Te.SCRIPT, !1) && yu(this.preprocessor.peek(Te.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Te.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === m.SOLIDUS ? (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(Te.SCRIPT, !1) && yu(this.preprocessor.peek(Te.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Te.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case m.EQUALS_SIGN: {
        this._err(x.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = E.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this._leaveAttrName(), this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case m.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN: {
        this._err(x.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.name += ie;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Ht(t) ? ln(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.EQUALS_SIGN: {
        this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        this.state = E.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this.state = E.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingAttributeValue), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = E.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN:
      case m.EQUALS_SIGN:
      case m.GRAVE_ACCENT: {
        this._err(x.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this._leaveAttrValue(), this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingWhitespaceBetweenAttributes), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.unexpectedSolidusInTag), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.data += ie;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(Te.DASH_DASH, !0) ? (this._createCommentToken(Te.DASH_DASH.length + 1), this.state = E.COMMENT_START) : this._consumeSequenceIfMatch(Te.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(Te.DOCTYPE.length + 1), this.state = E.DOCTYPE) : this._consumeSequenceIfMatch(Te.CDATA_START, !0) ? this.inForeignNode ? this.state = E.CDATA_SECTION : (this._err(x.cdataInHtmlContent), this._createCommentToken(Te.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = E.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(x.incorrectlyOpenedComment), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_START_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptClosingOfEmptyComment), this.state = E.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptClosingOfEmptyComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<", this.state = E.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.data += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case m.EXCLAMATION_MARK: {
        n.data += "!", this.state = E.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = E.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = E.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== m.GREATER_THAN_SIGN && t !== m.EOF && this._err(x.nestedComment), this.state = E.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.COMMENT_END_BANG;
        break;
      }
      case m.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        n.data += "--!", this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.incorrectlyClosedComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingWhitespaceBeforeDoctypeName), this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (Ht(t))
      this._createDoctypeToken(String.fromCharCode(ln(t))), this.state = E.DOCTYPE_NAME;
    else
      switch (t) {
        case m.SPACE:
        case m.LINE_FEED:
        case m.TABULATION:
        case m.FORM_FEED:
          break;
        case m.NULL: {
          this._err(x.unexpectedNullCharacter), this._createDoctypeToken(ie), this.state = E.DOCTYPE_NAME;
          break;
        }
        case m.GREATER_THAN_SIGN: {
          this._err(x.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(x.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = E.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.AFTER_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.name += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Ht(t) ? ln(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Te.PUBLIC, !1) ? this.state = E.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Te.SYSTEM, !1) ? this.state = E.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(x.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.publicId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.publicId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.systemId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.systemId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter);
        break;
      }
      case m.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case m.RIGHT_SQUARE_BRACKET: {
        this.state = E.CDATA_SECTION_BRACKET;
        break;
      }
      case m.EOF: {
        this._err(x.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === m.RIGHT_SQUARE_BRACKET ? this.state = E.CDATA_SECTION_END : (this._emitChars("]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA;
        break;
      }
      case m.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(m.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && ku(this.preprocessor.peek(1)) ? E.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    ku(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === m.SEMICOLON && this._err(x.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const ma = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]), Nu = /* @__PURE__ */ new Set([
  ...ma,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]), Cn = /* @__PURE__ */ new Set([
  s.APPLET,
  s.CAPTION,
  s.HTML,
  s.MARQUEE,
  s.OBJECT,
  s.TABLE,
  s.TD,
  s.TEMPLATE,
  s.TH
]), _l = /* @__PURE__ */ new Set([...Cn, s.OL, s.UL]), Cl = /* @__PURE__ */ new Set([...Cn, s.BUTTON]), Ou = /* @__PURE__ */ new Set([s.ANNOTATION_XML, s.MI, s.MN, s.MO, s.MS, s.MTEXT]), Lu = /* @__PURE__ */ new Set([s.DESC, s.FOREIGN_OBJECT, s.TITLE]), Sl = /* @__PURE__ */ new Set([s.TR, s.TEMPLATE, s.HTML]), xl = /* @__PURE__ */ new Set([s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML]), Il = /* @__PURE__ */ new Set([s.TABLE, s.TEMPLATE, s.HTML]), kl = /* @__PURE__ */ new Set([s.TD, s.TH]);
class yl {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === R.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const u = this._indexOf(t) + 1;
    this.items.splice(u, 0, n), this.tagIDs.splice(u, 0, r), this.stackTop++, u === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, u === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== R.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(pr, R.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(kl, R.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Il, R.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(xl, R.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(Sl, R.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const u = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case R.HTML: {
          if (u === t)
            return !0;
          if (n.has(u))
            return !1;
          break;
        }
        case R.SVG: {
          if (Lu.has(u))
            return !1;
          break;
        }
        case R.MATHML: {
          if (Ou.has(u))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, Cn);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, _l);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, Cl);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case R.HTML: {
          if (pr.has(n))
            return !0;
          if (Cn.has(n))
            return !1;
          break;
        }
        case R.SVG: {
          if (Lu.has(n))
            return !1;
          break;
        }
        case R.MATHML: {
          if (Ou.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === R.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === R.HTML)
        switch (this.tagIDs[t]) {
          case s.TBODY:
          case s.THEAD:
          case s.TFOOT:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === R.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.OPTION:
          case s.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; ma.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Nu.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && Nu.has(this.currentTagId); )
      this.pop();
  }
}
const Vn = 3;
var Pe;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(Pe || (Pe = {}));
const Ru = { type: Pe.Marker };
class Nl {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], u = n.length, a = this.treeAdapter.getTagName(t), i = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const l = this.entries[o];
      if (l.type === Pe.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === a && this.treeAdapter.getNamespaceURI(c) === i) {
        const h = this.treeAdapter.getAttrList(c);
        h.length === u && r.push({ idx: o, attrs: h });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < Vn)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < Vn)
      return;
    const u = new Map(n.map((i) => [i.name, i.value]));
    let a = 0;
    for (let i = 0; i < r.length; i++) {
      const o = r[i];
      o.attrs.every((l) => u.get(l.name) === l.value) && (a += 1, a >= Vn && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Ru);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: Pe.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: Pe.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Ru);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === Pe.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === Pe.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === Pe.Element && n.element === t);
  }
}
const We = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: xe.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const u = e.childNodes.find((a) => a.nodeName === "#documentType");
    if (u)
      u.name = t, u.publicId = n, u.systemId = r;
    else {
      const a = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      We.appendChild(e, a);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (We.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    We.appendChild(e, We.createTextNode(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && We.isTextNode(r) ? r.value += t : We.insertBefore(e, We.createTextNode(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, pa = "html", Ol = "about:legacy-compat", Ll = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", Ea = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], Rl = [
  ...Ea,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], Dl = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), ga = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], Pl = [
  ...ga,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function Du(e, t) {
  return t.some((n) => e.startsWith(n));
}
function wl(e) {
  return e.name === pa && e.publicId === null && (e.systemId === null || e.systemId === Ol);
}
function Ml(e) {
  if (e.name !== pa)
    return xe.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === Ll)
    return xe.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), Dl.has(n))
      return xe.QUIRKS;
    let r = t === null ? Rl : Ea;
    if (Du(n, r))
      return xe.QUIRKS;
    if (r = t === null ? ga : Pl, Du(n, r))
      return xe.LIMITED_QUIRKS;
  }
  return xe.NO_QUIRKS;
}
const Pu = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, Bl = "definitionurl", Fl = "definitionURL", Hl = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), Ul = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: R.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: R.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: R.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: R.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: R.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: R.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: R.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: R.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: R.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: R.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: R.XMLNS }]
]), vl = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), zl = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function Yl(e) {
  const t = e.tagID;
  return t === s.FONT && e.attrs.some(({ name: r }) => r === nt.COLOR || r === nt.SIZE || r === nt.FACE) || zl.has(t);
}
function Ta(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === Bl) {
      e.attrs[t].name = Fl;
      break;
    }
}
function ba(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = Hl.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function Hr(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = Ul.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function ql(e) {
  const t = vl.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = xt(e.tagName));
}
function jl(e, t) {
  return t === R.MATHML && (e === s.MI || e === s.MO || e === s.MN || e === s.MS || e === s.MTEXT);
}
function Vl(e, t, n) {
  if (t === R.MATHML && e === s.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === nt.ENCODING) {
        const u = n[r].value.toLowerCase();
        return u === Pu.TEXT_HTML || u === Pu.APPLICATION_XML;
      }
  }
  return t === R.SVG && (e === s.FOREIGN_OBJECT || e === s.DESC || e === s.TITLE);
}
function Wl(e, t, n, r) {
  return (!r || r === R.HTML) && Vl(e, t, n) || (!r || r === R.MATHML) && jl(e, t);
}
const Gl = "hidden", Ql = 8, $l = 3;
var g;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(g || (g = {}));
const Xl = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, Aa = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]), wu = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: We,
  onParseError: null
};
class Mu {
  constructor(t, n, r = null, u = null) {
    this.fragmentContext = r, this.scriptHandler = u, this.currentToken = null, this.stopped = !1, this.insertionMode = g.INITIAL, this.originalInsertionMode = g.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...wu,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Al(this.options, this), this.activeFormattingElements = new Nl(this.treeAdapter), this.fragmentContextID = r ? xt(this.treeAdapter.getTagName(r)) : s.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new yl(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...wu,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(_.TEMPLATE, R.HTML, []));
    const u = r.treeAdapter.createElement("documentmock", R.HTML, []), a = new this(r, u, t);
    return a.fragmentContextID === s.TEMPLATE && a.tmplInsertionModeStack.unshift(g.IN_TEMPLATE), a._initTokenizerForFragmentParsing(), a._insertFakeRootElement(), a._resetInsertionMode(), a._findFormInFragmentContext(), a;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  /** @internal */
  _err(t, n, r) {
    var u;
    if (!this.onParseError)
      return;
    const a = (u = t.location) !== null && u !== void 0 ? u : Xl, i = {
      code: n,
      startLine: a.startLine,
      startCol: a.startCol,
      startOffset: a.startOffset,
      endLine: r ? a.startLine : a.endLine,
      endCol: r ? a.startCol : a.endCol,
      endOffset: r ? a.startOffset : a.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  /** @internal */
  onItemPush(t, n, r) {
    var u, a;
    (a = (u = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(u, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  /** @internal */
  onItemPop(t, n) {
    var r, u;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (u = (r = this.treeAdapter).onItemPop) === null || u === void 0 || u.call(r, t, this.openElements.current), n) {
      let a, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, i = this.fragmentContextID) : { current: a, currentTagId: i } = this.openElements, this._setContextModes(a, i);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === R.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  /** @protected */
  _switchToTextParsing(t, n) {
    this._insertElement(t, R.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = g.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = g.TEXT, this.originalInsertionMode = g.IN_BODY, this.tokenizer.state = ae.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === _.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== R.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = ae.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = ae.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = ae.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = ae.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", u = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, u), t.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  /** @protected */
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, R.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, R.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(_.HTML, R.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, s.HTML);
  }
  /** @protected */
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const u = this.treeAdapter.getChildNodes(n), a = r ? u.lastIndexOf(r) : u.length, i = u[a - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: l, endCol: c, endOffset: h } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: l, endCol: c, endOffset: h });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  /** @protected */
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, u = this.treeAdapter.getTagName(t), a = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === $.END_TAG && u === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, a);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === s.SVG && this.treeAdapter.getTagName(n) === _.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === R.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === s.MGLYPH || t.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r, n, R.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case $.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case $.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case $.COMMENT: {
        this.onComment(t);
        break;
      }
      case $.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case $.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case $.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case $.EOF: {
        this.onEof(t);
        break;
      }
      case $.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, n, r) {
    const u = this.treeAdapter.getNamespaceURI(n), a = this.treeAdapter.getAttrList(n);
    return Wl(t, u, a, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((u) => u.type === Pe.Marker || this.openElements.contains(u.element)), r = n < 0 ? t - 1 : n - 1;
      for (let u = r; u >= 0; u--) {
        const a = this.activeFormattingElements.entries[u];
        this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)), a.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = g.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case s.TR: {
          this.insertionMode = g.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = g.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = g.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = g.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = g.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = g.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = g.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? g.AFTER_HEAD : g.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t > 0) {
            this.insertionMode = g.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t > 0) {
            this.insertionMode = g.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = g.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === s.TEMPLATE)
          break;
        if (r === s.TABLE) {
          this.insertionMode = g.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = g.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return Aa.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === R.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return El[r].has(n);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      k0(this, t);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t);
        break;
      }
      case g.IN_BODY:
      case g.IN_CAPTION:
      case g.IN_CELL:
      case g.IN_TEMPLATE: {
        Ca(this, t);
        break;
      }
      case g.TEXT:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Na(this, t);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        Sn(this, t);
        break;
      }
      case g.AFTER_BODY: {
        xn(this, t);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      I0(this, t);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t);
        break;
      }
      case g.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        Sn(this, t);
        break;
      }
      case g.AFTER_BODY: {
        xn(this, t);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      Er(this, t);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL:
      case g.BEFORE_HTML:
      case g.BEFORE_HEAD:
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD:
      case g.IN_BODY:
      case g.IN_TABLE:
      case g.IN_CAPTION:
      case g.IN_COLUMN_GROUP:
      case g.IN_TABLE_BODY:
      case g.IN_ROW:
      case g.IN_CELL:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE:
      case g.IN_TEMPLATE:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET: {
        Er(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t);
        break;
      }
      case g.AFTER_BODY: {
        rc(this, t);
        break;
      }
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        uc(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case g.INITIAL: {
        ic(this, t);
        break;
      }
      case g.BEFORE_HEAD:
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD: {
        this._err(t, x.misplacedDoctype);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, x.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? y0(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t);
        break;
      }
      case g.BEFORE_HTML: {
        ac(this, t);
        break;
      }
      case g.BEFORE_HEAD: {
        oc(this, t);
        break;
      }
      case g.IN_HEAD: {
        Re(this, t);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        fc(this, t);
        break;
      }
      case g.AFTER_HEAD: {
        dc(this, t);
        break;
      }
      case g.IN_BODY: {
        pe(this, t);
        break;
      }
      case g.IN_TABLE: {
        At(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t);
        break;
      }
      case g.IN_CAPTION: {
        l0(this, t);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        zr(this, t);
        break;
      }
      case g.IN_TABLE_BODY: {
        Pn(this, t);
        break;
      }
      case g.IN_ROW: {
        wn(this, t);
        break;
      }
      case g.IN_CELL: {
        h0(this, t);
        break;
      }
      case g.IN_SELECT: {
        Ra(this, t);
        break;
      }
      case g.IN_SELECT_IN_TABLE: {
        m0(this, t);
        break;
      }
      case g.IN_TEMPLATE: {
        E0(this, t);
        break;
      }
      case g.AFTER_BODY: {
        T0(this, t);
        break;
      }
      case g.IN_FRAMESET: {
        b0(this, t);
        break;
      }
      case g.AFTER_FRAMESET: {
        _0(this, t);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        S0(this, t);
        break;
      }
      case g.AFTER_AFTER_FRAMESET: {
        x0(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? N0(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t);
        break;
      }
      case g.BEFORE_HTML: {
        sc(this, t);
        break;
      }
      case g.BEFORE_HEAD: {
        lc(this, t);
        break;
      }
      case g.IN_HEAD: {
        cc(this, t);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        hc(this, t);
        break;
      }
      case g.AFTER_HEAD: {
        mc(this, t);
        break;
      }
      case g.IN_BODY: {
        Dn(this, t);
        break;
      }
      case g.TEXT: {
        Zc(this, t);
        break;
      }
      case g.IN_TABLE: {
        Xt(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t);
        break;
      }
      case g.IN_CAPTION: {
        c0(this, t);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        f0(this, t);
        break;
      }
      case g.IN_TABLE_BODY: {
        gr(this, t);
        break;
      }
      case g.IN_ROW: {
        La(this, t);
        break;
      }
      case g.IN_CELL: {
        d0(this, t);
        break;
      }
      case g.IN_SELECT: {
        Da(this, t);
        break;
      }
      case g.IN_SELECT_IN_TABLE: {
        p0(this, t);
        break;
      }
      case g.IN_TEMPLATE: {
        g0(this, t);
        break;
      }
      case g.AFTER_BODY: {
        wa(this, t);
        break;
      }
      case g.IN_FRAMESET: {
        A0(this, t);
        break;
      }
      case g.AFTER_FRAMESET: {
        C0(this, t);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t);
        break;
      }
      case g.IN_BODY:
      case g.IN_TABLE:
      case g.IN_CAPTION:
      case g.IN_COLUMN_GROUP:
      case g.IN_TABLE_BODY:
      case g.IN_ROW:
      case g.IN_CELL:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE: {
        ka(this, t);
        break;
      }
      case g.TEXT: {
        e0(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t);
        break;
      }
      case g.IN_TEMPLATE: {
        Pa(this, t);
        break;
      }
      case g.AFTER_BODY:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET:
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        vr(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === m.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD:
      case g.TEXT:
      case g.IN_COLUMN_GROUP:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case g.IN_BODY:
      case g.IN_CAPTION:
      case g.IN_CELL:
      case g.IN_TEMPLATE:
      case g.AFTER_BODY:
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        _a(this, t);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t);
        break;
      }
      case g.IN_TABLE_TEXT: {
        ya(this, t);
        break;
      }
    }
  }
}
function Kl(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Ia(e, t), n;
}
function Jl(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const u = e.openElements.items[r];
    if (u === t.element)
      break;
    e._isSpecialElement(u, e.openElements.tagIDs[r]) && (n = u);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function Zl(e, t, n) {
  let r = t, u = e.openElements.getCommonAncestor(t);
  for (let a = 0, i = u; i !== n; a++, i = u) {
    u = e.openElements.getCommonAncestor(i);
    const o = e.activeFormattingElements.getElementEntry(i), l = o && a >= $l;
    !o || l ? (l && e.activeFormattingElements.removeEntry(o), e.openElements.remove(i)) : (i = ec(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(i, r), r = i);
  }
  return r;
}
function ec(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function tc(e, t, n) {
  const r = e.treeAdapter.getTagName(t), u = xt(r);
  if (e._isElementCausesFosterParenting(u))
    e._fosterParentElement(n);
  else {
    const a = e.treeAdapter.getNamespaceURI(t);
    u === s.TEMPLATE && a === R.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function nc(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: u } = n, a = e.treeAdapter.createElement(u.tagName, r, u.attrs);
  e._adoptNodes(t, a), e.treeAdapter.appendChild(t, a), e.activeFormattingElements.insertElementAfterBookmark(a, u), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, a, u.tagID);
}
function Ur(e, t) {
  for (let n = 0; n < Ql; n++) {
    const r = Kl(e, t);
    if (!r)
      break;
    const u = Jl(e, r);
    if (!u)
      break;
    e.activeFormattingElements.bookmark = r;
    const a = Zl(e, u, r.element), i = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(a), i && tc(e, i, a), nc(e, u, r);
  }
}
function Er(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function rc(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function uc(e, t) {
  e._appendCommentNode(t, e.document);
}
function vr(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], u = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (u && !u.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const a = e.openElements.items[1], i = e.treeAdapter.getNodeSourceCodeLocation(a);
        i && !i.endTag && e._setEndLocation(a, t);
      }
    }
  }
}
function ic(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? xe.QUIRKS : Ml(t);
  wl(t) || e._err(t, x.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = g.BEFORE_HTML;
}
function Dt(e, t) {
  e._err(t, x.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, xe.QUIRKS), e.insertionMode = g.BEFORE_HTML, e._processToken(t);
}
function ac(e, t) {
  t.tagID === s.HTML ? (e._insertElement(t, R.HTML), e.insertionMode = g.BEFORE_HEAD) : zt(e, t);
}
function sc(e, t) {
  const n = t.tagID;
  (n === s.HTML || n === s.HEAD || n === s.BODY || n === s.BR) && zt(e, t);
}
function zt(e, t) {
  e._insertFakeRootElement(), e.insertionMode = g.BEFORE_HEAD, e._processToken(t);
}
function oc(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.HEAD: {
      e._insertElement(t, R.HTML), e.headElement = e.openElements.current, e.insertionMode = g.IN_HEAD;
      break;
    }
    default:
      Yt(e, t);
  }
}
function lc(e, t) {
  const n = t.tagID;
  n === s.HEAD || n === s.BODY || n === s.HTML || n === s.BR ? Yt(e, t) : e._err(t, x.endTagWithoutMatchingOpenElement);
}
function Yt(e, t) {
  e._insertFakeElement(_.HEAD, s.HEAD), e.headElement = e.openElements.current, e.insertionMode = g.IN_HEAD, e._processToken(t);
}
function Re(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e._appendElement(t, R.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TITLE: {
      e._switchToTextParsing(t, ae.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, ae.RAWTEXT) : (e._insertElement(t, R.HTML), e.insertionMode = g.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e._switchToTextParsing(t, ae.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e._switchToTextParsing(t, ae.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = g.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(g.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e._err(t, x.misplacedStartTagForHeadElement);
      break;
    }
    default:
      qt(e, t);
  }
}
function cc(e, t) {
  switch (t.tagID) {
    case s.HEAD: {
      e.openElements.pop(), e.insertionMode = g.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      qt(e, t);
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
    default:
      e._err(t, x.endTagWithoutMatchingOpenElement);
  }
}
function it(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== s.TEMPLATE && e._err(t, x.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, x.endTagWithoutMatchingOpenElement);
}
function qt(e, t) {
  e.openElements.pop(), e.insertionMode = g.AFTER_HEAD, e._processToken(t);
}
function fc(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Re(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e._err(t, x.nestedNoscriptInHead);
      break;
    }
    default:
      jt(e, t);
  }
}
function hc(e, t) {
  switch (t.tagID) {
    case s.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = g.IN_HEAD;
      break;
    }
    case s.BR: {
      jt(e, t);
      break;
    }
    default:
      e._err(t, x.endTagWithoutMatchingOpenElement);
  }
}
function jt(e, t) {
  const n = t.type === $.EOF ? x.openElementsLeftAfterEof : x.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = g.IN_HEAD, e._processToken(t);
}
function dc(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.BODY: {
      e._insertElement(t, R.HTML), e.framesetOk = !1, e.insertionMode = g.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, R.HTML), e.insertionMode = g.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e._err(t, x.abandonedHeadElementChild), e.openElements.push(e.headElement, s.HEAD), Re(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case s.HEAD: {
      e._err(t, x.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Vt(e, t);
  }
}
function mc(e, t) {
  switch (t.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      Vt(e, t);
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
    default:
      e._err(t, x.endTagWithoutMatchingOpenElement);
  }
}
function Vt(e, t) {
  e._insertFakeElement(_.BODY, s.BODY), e.insertionMode = g.IN_BODY, Rn(e, t);
}
function Rn(e, t) {
  switch (t.type) {
    case $.CHARACTER: {
      Ca(e, t);
      break;
    }
    case $.WHITESPACE_CHARACTER: {
      _a(e, t);
      break;
    }
    case $.COMMENT: {
      Er(e, t);
      break;
    }
    case $.START_TAG: {
      pe(e, t);
      break;
    }
    case $.END_TAG: {
      Dn(e, t);
      break;
    }
    case $.EOF: {
      ka(e, t);
      break;
    }
  }
}
function _a(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function Ca(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function pc(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function Ec(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function gc(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_FRAMESET);
}
function Tc(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML);
}
function bc(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), pr.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, R.HTML);
}
function Ac(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function _c(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML), n || (e.formElement = e.openElements.current));
}
function Cc(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const u = e.openElements.tagIDs[r];
    if (n === s.LI && u === s.LI || (n === s.DD || n === s.DT) && (u === s.DD || u === s.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(u), e.openElements.popUntilTagNamePopped(u);
      break;
    }
    if (u !== s.ADDRESS && u !== s.DIV && u !== s.P && e._isSpecialElement(e.openElements.items[r], u))
      break;
  }
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML);
}
function Sc(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML), e.tokenizer.state = ae.PLAINTEXT;
}
function xc(e, t) {
  e.openElements.hasInScope(s.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML), e.framesetOk = !1;
}
function Ic(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(_.A);
  n && (Ur(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function kc(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function yc(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(s.NOBR) && (Ur(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, R.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Nc(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function Oc(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== xe.QUIRKS && e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, R.HTML), e.framesetOk = !1, e.insertionMode = g.IN_TABLE;
}
function Sa(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, R.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function xa(e) {
  const t = la(e, nt.TYPE);
  return t != null && t.toLowerCase() === Gl;
}
function Lc(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, R.HTML), xa(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function Rc(e, t) {
  e._appendElement(t, R.HTML), t.ackSelfClosing = !0;
}
function Dc(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._appendElement(t, R.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Pc(e, t) {
  t.tagName = _.IMG, t.tagID = s.IMG, Sa(e, t);
}
function wc(e, t) {
  e._insertElement(t, R.HTML), e.skipNextNewLine = !0, e.tokenizer.state = ae.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = g.TEXT;
}
function Mc(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, ae.RAWTEXT);
}
function Bc(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, ae.RAWTEXT);
}
function Bu(e, t) {
  e._switchToTextParsing(t, ae.RAWTEXT);
}
function Fc(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === g.IN_TABLE || e.insertionMode === g.IN_CAPTION || e.insertionMode === g.IN_TABLE_BODY || e.insertionMode === g.IN_ROW || e.insertionMode === g.IN_CELL ? g.IN_SELECT_IN_TABLE : g.IN_SELECT;
}
function Hc(e, t) {
  e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML);
}
function Uc(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, R.HTML);
}
function vc(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e._insertElement(t, R.HTML);
}
function zc(e, t) {
  e._reconstructActiveFormattingElements(), Ta(t), Hr(t), t.selfClosing ? e._appendElement(t, R.MATHML) : e._insertElement(t, R.MATHML), t.ackSelfClosing = !0;
}
function Yc(e, t) {
  e._reconstructActiveFormattingElements(), ba(t), Hr(t), t.selfClosing ? e._appendElement(t, R.SVG) : e._insertElement(t, R.SVG), t.ackSelfClosing = !0;
}
function Fu(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, R.HTML);
}
function pe(e, t) {
  switch (t.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      kc(e, t);
      break;
    }
    case s.A: {
      Ic(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      bc(e, t);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Tc(e, t);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      Cc(e, t);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      Sa(e, t);
      break;
    }
    case s.HR: {
      Dc(e, t);
      break;
    }
    case s.RB:
    case s.RTC: {
      Uc(e, t);
      break;
    }
    case s.RT:
    case s.RP: {
      vc(e, t);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Ac(e, t);
      break;
    }
    case s.XMP: {
      Mc(e, t);
      break;
    }
    case s.SVG: {
      Yc(e, t);
      break;
    }
    case s.HTML: {
      pc(e, t);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Re(e, t);
      break;
    }
    case s.BODY: {
      Ec(e, t);
      break;
    }
    case s.FORM: {
      _c(e, t);
      break;
    }
    case s.NOBR: {
      yc(e, t);
      break;
    }
    case s.MATH: {
      zc(e, t);
      break;
    }
    case s.TABLE: {
      Oc(e, t);
      break;
    }
    case s.INPUT: {
      Lc(e, t);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      Rc(e, t);
      break;
    }
    case s.IMAGE: {
      Pc(e, t);
      break;
    }
    case s.BUTTON: {
      xc(e, t);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Nc(e, t);
      break;
    }
    case s.IFRAME: {
      Bc(e, t);
      break;
    }
    case s.SELECT: {
      Fc(e, t);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      Hc(e, t);
      break;
    }
    case s.NOEMBED:
    case s.NOFRAMES: {
      Bu(e, t);
      break;
    }
    case s.FRAMESET: {
      gc(e, t);
      break;
    }
    case s.TEXTAREA: {
      wc(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? Bu(e, t) : Fu(e, t);
      break;
    }
    case s.PLAINTEXT: {
      Sc(e, t);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      Fu(e, t);
  }
}
function qc(e, t) {
  if (e.openElements.hasInScope(s.BODY) && (e.insertionMode = g.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function jc(e, t) {
  e.openElements.hasInScope(s.BODY) && (e.insertionMode = g.AFTER_BODY, wa(e, t));
}
function Vc(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function Wc(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(s.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(s.FORM) : n && e.openElements.remove(n));
}
function Gc(e) {
  e.openElements.hasInButtonScope(s.P) || e._insertFakeElement(_.P, s.P), e._closePElement();
}
function Qc(e) {
  e.openElements.hasInListItemScope(s.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(s.LI), e.openElements.popUntilTagNamePopped(s.LI));
}
function $c(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function Xc(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function Kc(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function Jc(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(_.BR, s.BR), e.openElements.pop(), e.framesetOk = !1;
}
function Ia(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let u = e.openElements.stackTop; u > 0; u--) {
    const a = e.openElements.items[u], i = e.openElements.tagIDs[u];
    if (r === i && (r !== s.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= u && e.openElements.shortenToLength(u);
      break;
    }
    if (e._isSpecialElement(a, i))
      break;
  }
}
function Dn(e, t) {
  switch (t.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Ur(e, t);
      break;
    }
    case s.P: {
      Gc(e);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Vc(e, t);
      break;
    }
    case s.LI: {
      Qc(e);
      break;
    }
    case s.DD:
    case s.DT: {
      $c(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      Xc(e);
      break;
    }
    case s.BR: {
      Jc(e);
      break;
    }
    case s.BODY: {
      qc(e, t);
      break;
    }
    case s.HTML: {
      jc(e, t);
      break;
    }
    case s.FORM: {
      Wc(e);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Kc(e, t);
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
    default:
      Ia(e, t);
  }
}
function ka(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Pa(e, t) : vr(e, t);
}
function Zc(e, t) {
  var n;
  t.tagID === s.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function e0(e, t) {
  e._err(t, x.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Wn(e, t) {
  if (Aa.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = g.IN_TABLE_TEXT, t.type) {
      case $.CHARACTER: {
        Na(e, t);
        break;
      }
      case $.WHITESPACE_CHARACTER: {
        ya(e, t);
        break;
      }
    }
  else
    tn(e, t);
}
function t0(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_CAPTION;
}
function n0(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_COLUMN_GROUP;
}
function r0(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(_.COLGROUP, s.COLGROUP), e.insertionMode = g.IN_COLUMN_GROUP, zr(e, t);
}
function u0(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_TABLE_BODY;
}
function i0(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(_.TBODY, s.TBODY), e.insertionMode = g.IN_TABLE_BODY, Pn(e, t);
}
function a0(e, t) {
  e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function s0(e, t) {
  xa(t) ? e._appendElement(t, R.HTML) : tn(e, t), t.ackSelfClosing = !0;
}
function o0(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, R.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function At(e, t) {
  switch (t.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      i0(e, t);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Re(e, t);
      break;
    }
    case s.COL: {
      r0(e, t);
      break;
    }
    case s.FORM: {
      o0(e, t);
      break;
    }
    case s.TABLE: {
      a0(e, t);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      u0(e, t);
      break;
    }
    case s.INPUT: {
      s0(e, t);
      break;
    }
    case s.CAPTION: {
      t0(e, t);
      break;
    }
    case s.COLGROUP: {
      n0(e, t);
      break;
    }
    default:
      tn(e, t);
  }
}
function Xt(e, t) {
  switch (t.tagID) {
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      tn(e, t);
  }
}
function tn(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Rn(e, t), e.fosterParentingEnabled = n;
}
function ya(e, t) {
  e.pendingCharacterTokens.push(t);
}
function Na(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Pt(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      tn(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const Oa = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function l0(e, t) {
  const n = t.tagID;
  Oa.has(n) ? e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = g.IN_TABLE, At(e, t)) : pe(e, t);
}
function c0(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.CAPTION:
    case s.TABLE: {
      e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = g.IN_TABLE, n === s.TABLE && Xt(e, t));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Dn(e, t);
  }
}
function zr(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.COL: {
      e._appendElement(t, R.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TEMPLATE: {
      Re(e, t);
      break;
    }
    default:
      Sn(e, t);
  }
}
function f0(e, t) {
  switch (t.tagID) {
    case s.COLGROUP: {
      e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = g.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
    case s.COL:
      break;
    default:
      Sn(e, t);
  }
}
function Sn(e, t) {
  e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = g.IN_TABLE, e._processToken(t));
}
function Pn(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(_.TR, s.TR), e.insertionMode = g.IN_ROW, wn(e, t);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE, At(e, t));
      break;
    }
    default:
      At(e, t);
  }
}
function gr(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE, Xt(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      Xt(e, t);
  }
}
function wn(e, t) {
  switch (t.tagID) {
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, R.HTML), e.insertionMode = g.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE_BODY, Pn(e, t));
      break;
    }
    default:
      At(e, t);
  }
}
function La(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE_BODY, gr(e, t));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(s.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = g.IN_TABLE_BODY, gr(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      Xt(e, t);
  }
}
function h0(e, t) {
  const n = t.tagID;
  Oa.has(n) ? (e.openElements.hasInTableScope(s.TD) || e.openElements.hasInTableScope(s.TH)) && (e._closeTableCell(), wn(e, t)) : pe(e, t);
}
function d0(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.TD:
    case s.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = g.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), La(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Dn(e, t);
  }
}
function Ra(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._insertElement(t, R.HTML);
      break;
    }
    case s.OPTGROUP: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._insertElement(t, R.HTML);
      break;
    }
    case s.HR: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._appendElement(t, R.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), t.tagID !== s.SELECT && e._processStartTag(t));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Re(e, t);
      break;
    }
  }
}
function Da(e, t) {
  switch (t.tagID) {
    case s.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === s.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === s.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop();
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop();
      break;
    }
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      it(e, t);
      break;
    }
  }
}
function m0(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : Ra(e, t);
}
function p0(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : Da(e, t);
}
function E0(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Re(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.tmplInsertionModeStack[0] = g.IN_TABLE, e.insertionMode = g.IN_TABLE, At(e, t);
      break;
    }
    case s.COL: {
      e.tmplInsertionModeStack[0] = g.IN_COLUMN_GROUP, e.insertionMode = g.IN_COLUMN_GROUP, zr(e, t);
      break;
    }
    case s.TR: {
      e.tmplInsertionModeStack[0] = g.IN_TABLE_BODY, e.insertionMode = g.IN_TABLE_BODY, Pn(e, t);
      break;
    }
    case s.TD:
    case s.TH: {
      e.tmplInsertionModeStack[0] = g.IN_ROW, e.insertionMode = g.IN_ROW, wn(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = g.IN_BODY, e.insertionMode = g.IN_BODY, pe(e, t);
  }
}
function g0(e, t) {
  t.tagID === s.TEMPLATE && it(e, t);
}
function Pa(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : vr(e, t);
}
function T0(e, t) {
  t.tagID === s.HTML ? pe(e, t) : xn(e, t);
}
function wa(e, t) {
  var n;
  if (t.tagID === s.HTML) {
    if (e.fragmentContext || (e.insertionMode = g.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === s.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    xn(e, t);
}
function xn(e, t) {
  e.insertionMode = g.IN_BODY, Rn(e, t);
}
function b0(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, R.HTML);
      break;
    }
    case s.FRAME: {
      e._appendElement(t, R.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.NOFRAMES: {
      Re(e, t);
      break;
    }
  }
}
function A0(e, t) {
  t.tagID === s.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== s.FRAMESET && (e.insertionMode = g.AFTER_FRAMESET));
}
function _0(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.NOFRAMES: {
      Re(e, t);
      break;
    }
  }
}
function C0(e, t) {
  t.tagID === s.HTML && (e.insertionMode = g.AFTER_AFTER_FRAMESET);
}
function S0(e, t) {
  t.tagID === s.HTML ? pe(e, t) : En(e, t);
}
function En(e, t) {
  e.insertionMode = g.IN_BODY, Rn(e, t);
}
function x0(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      pe(e, t);
      break;
    }
    case s.NOFRAMES: {
      Re(e, t);
      break;
    }
  }
}
function I0(e, t) {
  t.chars = ie, e._insertCharacters(t);
}
function k0(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function Ma(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== R.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function y0(e, t) {
  if (Yl(t))
    Ma(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === R.MATHML ? Ta(t) : r === R.SVG && (ql(t), ba(t)), Hr(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function N0(e, t) {
  if (t.tagID === s.P || t.tagID === s.BR) {
    Ma(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === R.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const u = e.treeAdapter.getTagName(r);
    if (u.toLowerCase() === t.tagName) {
      t.tagName = u, e.openElements.shortenToLength(n);
      break;
    }
  }
}
_.AREA, _.BASE, _.BASEFONT, _.BGSOUND, _.BR, _.COL, _.EMBED, _.FRAME, _.HR, _.IMG, _.INPUT, _.KEYGEN, _.LINK, _.META, _.PARAM, _.SOURCE, _.TRACK, _.WBR;
const Mn = Ba("end"), Me = Ba("start");
function Ba(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function O0(e) {
  const t = Me(e), n = Mn(e);
  if (t && n)
    return { start: t, end: n };
}
const Bn = (
  // Note: overloads in JSDoc canât yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return P0;
    if (typeof e == "function")
      return Fn(e);
    if (typeof e == "object")
      return Array.isArray(e) ? L0(e) : R0(e);
    if (typeof e == "string")
      return D0(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function L0(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Bn(e[n]);
  return Fn(r);
  function r(...u) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, u)) return !0;
    return !1;
  }
}
function R0(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Fn(n);
  function n(r) {
    const u = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (u[a] !== t[a]) return !1;
    return !0;
  }
}
function D0(e) {
  return Fn(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Fn(e) {
  return t;
  function t(n, r, u) {
    return !!(w0(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      u || void 0
    ));
  }
}
function P0() {
  return !0;
}
function w0(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Fa = [], M0 = !0, Tr = !1, B0 = "skip";
function Ha(e, t, n, r) {
  let u;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : u = t;
  const a = Bn(u), i = r ? -1 : 1;
  o(e, void 0, [])();
  function o(l, c, h) {
    const f = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof f.type == "string") {
      const d = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let d = Fa, A, C, y;
      if ((!t || a(l, c, h[h.length - 1] || void 0)) && (d = F0(n(l, h)), d[0] === Tr))
        return d;
      if ("children" in l && l.children) {
        const S = (
          /** @type {UnistParent} */
          l
        );
        if (S.children && d[0] !== B0)
          for (C = (r ? S.children.length : -1) + i, y = h.concat(S); C > -1 && C < S.children.length; ) {
            const O = S.children[C];
            if (A = o(O, C, y)(), A[0] === Tr)
              return A;
            C = typeof A[1] == "number" ? A[1] : C + i;
          }
      }
      return d;
    }
  }
}
function F0(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [M0, e] : e == null ? Fa : [e];
}
function nn(e, t, n, r) {
  let u, a, i;
  typeof t == "function" && typeof n != "function" ? (a = void 0, i = t, u = n) : (a = t, i = n, u = r), Ha(e, a, o, u);
  function o(l, c) {
    const h = c[c.length - 1], f = h ? h.children.indexOf(l) : void 0;
    return i(l, f, h);
  }
}
const H0 = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, U0 = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Hu = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function Ua(e, t) {
  const n = $0(e), r = ua("type", {
    handlers: { root: v0, element: z0, text: Y0, comment: za, doctype: q0, raw: V0 },
    unknown: W0
  }), u = {
    parser: n ? new Mu(Hu) : Mu.getFragmentParser(void 0, Hu),
    handle(o) {
      r(o, u);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, u), It(u, Me());
  const a = n ? u.parser.document : u.parser.getFragment(), i = zo(a, {
    // To do: support `space`?
    file: u.options.file
  });
  return u.stitches && nn(i, "comment", function(o, l, c) {
    const h = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (h.value.stitch && c && l !== void 0) {
      const f = c.children;
      return f[l] = h.value.stitch, l;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e.type ? i.children[0] : i;
}
function va(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function v0(e, t) {
  va(e.children, t);
}
function z0(e, t) {
  G0(e, t), va(e.children, t), Q0(e, t);
}
function Y0(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n = {
    type: $.CHARACTER,
    chars: e.value,
    location: rn(e)
  };
  It(t, Me(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function q0(e, t) {
  const n = {
    type: $.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: rn(e)
  };
  It(t, Me(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function j0(e, t) {
  t.stitches = !0;
  const n = X0(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      Ua({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  za({ type: "comment", value: { stitch: n } }, t);
}
function za(e, t) {
  const n = e.value, r = {
    type: $.COMMENT,
    data: n,
    location: rn(e)
  };
  It(t, Me(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function V0(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, Ya(t, Me(e)), t.parser.tokenizer.write(
    t.options.tagfilter ? e.value.replace(H0, "&lt;$1$2") : e.value,
    !1
  ), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function W0(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    j0(n, t);
  else {
    let r = "";
    throw U0.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function It(e, t) {
  Ya(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = ae.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function Ya(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function G0(e, t) {
  const n = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === ae.PLAINTEXT) return;
  It(t, Me(e));
  const r = t.parser.openElements.current;
  let u = "namespaceURI" in r ? r.namespaceURI : tt.html;
  u === tt.html && n === "svg" && (u = tt.svg);
  const a = Wo(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: u === tt.svg ? "svg" : "html" }
  ), i = {
    type: $.START_TAG,
    tagName: n,
    tagID: xt(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in a ? a.attrs : [],
    location: rn(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n;
}
function Q0(e, t) {
  const n = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && el.includes(n) || t.parser.tokenizer.state === ae.PLAINTEXT) return;
  It(t, Mn(e));
  const r = {
    type: $.END_TAG,
    tagName: n,
    tagID: xt(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: rn(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === ae.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === ae.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === ae.SCRIPT_DATA) && (t.parser.tokenizer.state = ae.DATA);
}
function $0(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function rn(e) {
  const t = Me(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = Mn(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function X0(e) {
  return "children" in e ? Eu({ ...e, children: [] }) : Eu(e);
}
function K0(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      Ua(t, { ...e, file: n })
    );
  };
}
function Uu(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, u = n.indexOf(t);
  for (; u !== -1; )
    r++, u = n.indexOf(t, u + t.length);
  return r;
}
const ge = Qe(/[A-Za-z]/), me = Qe(/[\dA-Za-z]/), J0 = Qe(/[#-'*+\--9=?A-Z^-~]/);
function In(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const br = Qe(/\d/), Z0 = Qe(/[\dA-Fa-f]/), ef = Qe(/[!-/:-@[-`{-~]/);
function z(e) {
  return e !== null && e < -2;
}
function ne(e) {
  return e !== null && (e < 0 || e === 32);
}
function X(e) {
  return e === -2 || e === -1 || e === 32;
}
const Hn = Qe(new RegExp("\\p{P}|\\p{S}", "u")), rt = Qe(/\s/);
function Qe(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function tf(e, t, n) {
  const u = Bn((n || {}).ignore || []), a = nf(t);
  let i = -1;
  for (; ++i < a.length; )
    Ha(e, "text", o);
  function o(c, h) {
    let f = -1, p;
    for (; ++f < h.length; ) {
      const d = h[f], A = p ? p.children : void 0;
      if (u(
        d,
        A ? A.indexOf(d) : void 0,
        p
      ))
        return;
      p = d;
    }
    if (p)
      return l(c, h);
  }
  function l(c, h) {
    const f = h[h.length - 1], p = a[i][0], d = a[i][1];
    let A = 0;
    const y = f.children.indexOf(c);
    let S = !1, O = [];
    p.lastIndex = 0;
    let L = p.exec(c.value);
    for (; L; ) {
      const Y = L.index, q = {
        index: L.index,
        input: L.input,
        stack: [...h, c]
      };
      let k = d(...L, q);
      if (typeof k == "string" && (k = k.length > 0 ? { type: "text", value: k } : void 0), k === !1 ? p.lastIndex = Y + 1 : (A !== Y && O.push({
        type: "text",
        value: c.value.slice(A, Y)
      }), Array.isArray(k) ? O.push(...k) : k && O.push(k), A = Y + L[0].length, S = !0), !p.global)
        break;
      L = p.exec(c.value);
    }
    return S ? (A < c.value.length && O.push({ type: "text", value: c.value.slice(A) }), f.children.splice(y, 1, ...O)) : O = [c], y + O.length;
  }
}
function nf(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const u = n[r];
    t.push([rf(u[0]), uf(u[1])]);
  }
  return t;
}
function rf(e) {
  return typeof e == "string" ? new RegExp(To(e), "g") : e;
}
function uf(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Gn = "phrasing", Qn = ["autolink", "link", "image", "label"];
function af() {
  return {
    transforms: [df],
    enter: {
      literalAutolink: of,
      literalAutolinkEmail: $n,
      literalAutolinkHttp: $n,
      literalAutolinkWww: $n
    },
    exit: {
      literalAutolink: hf,
      literalAutolinkEmail: ff,
      literalAutolinkHttp: lf,
      literalAutolinkWww: cf
    }
  };
}
function sf() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Gn,
        notInConstruct: Qn
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Gn,
        notInConstruct: Qn
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Gn,
        notInConstruct: Qn
      }
    ]
  };
}
function of(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function $n(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function lf(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function cf(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function ff(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function hf(e) {
  this.exit(e);
}
function df(e) {
  tf(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, mf],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), pf]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function mf(e, t, n, r, u) {
  let a = "";
  if (!qa(u) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !Ef(n)))
    return !1;
  const i = gf(n + r);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function pf(e, t, n, r) {
  return (
    // Not an expected previous character.
    !qa(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Ef(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function gf(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const u = Uu(e, "(");
  let a = Uu(e, ")");
  for (; r !== -1 && u > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function qa(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || rt(n) || Hn(n)) && // If itâs an email, the previous character should not be a slash.
  (!t || n !== 47);
}
function un(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
ja.peek = kf;
function Tf() {
  this.buffer();
}
function bf(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Af() {
  this.buffer();
}
function _f(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Cf(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = un(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Sf(e) {
  this.exit(e);
}
function xf(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = un(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function If(e) {
  this.exit(e);
}
function kf() {
  return "[";
}
function ja(e, t, n, r) {
  const u = n.createTracker(r);
  let a = u.move("[^");
  const i = n.enter("footnoteReference"), o = n.enter("reference");
  return a += u.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), o(), i(), a += u.move("]"), a;
}
function yf() {
  return {
    enter: {
      gfmFootnoteCallString: Tf,
      gfmFootnoteCall: bf,
      gfmFootnoteDefinitionLabelString: Af,
      gfmFootnoteDefinition: _f
    },
    exit: {
      gfmFootnoteCallString: Cf,
      gfmFootnoteCall: Sf,
      gfmFootnoteDefinitionLabelString: xf,
      gfmFootnoteDefinition: If
    }
  };
}
function Nf(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: ja },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, u, a, i) {
    const o = a.createTracker(i);
    let l = o.move("[^");
    const c = a.enter("footnoteDefinition"), h = a.enter("label");
    return l += o.move(
      a.safe(a.associationId(r), { before: l, after: "]" })
    ), h(), l += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), l += o.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, o.current()),
        t ? Va : Of
      )
    )), c(), l;
  }
}
function Of(e, t, n) {
  return t === 0 ? e : Va(e, t, n);
}
function Va(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Lf = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Wa.peek = Mf;
function Rf() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Pf },
    exit: { strikethrough: wf }
  };
}
function Df() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Lf
      }
    ],
    handlers: { delete: Wa }
  };
}
function Pf(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function wf(e) {
  this.exit(e);
}
function Wa(e, t, n, r) {
  const u = n.createTracker(r), a = n.enter("strikethrough");
  let i = u.move("~~");
  return i += n.containerPhrasing(e, {
    ...u.current(),
    before: i,
    after: "~"
  }), i += u.move("~~"), a(), i;
}
function Mf() {
  return "~";
}
function Bf(e) {
  return e.length;
}
function Ff(e, t) {
  const n = t || {}, r = (n.align || []).concat(), u = n.stringLength || Bf, a = [], i = [], o = [], l = [];
  let c = 0, h = -1;
  for (; ++h < e.length; ) {
    const C = [], y = [];
    let S = -1;
    for (e[h].length > c && (c = e[h].length); ++S < e[h].length; ) {
      const O = Hf(e[h][S]);
      if (n.alignDelimiters !== !1) {
        const L = u(O);
        y[S] = L, (l[S] === void 0 || L > l[S]) && (l[S] = L);
      }
      C.push(O);
    }
    i[h] = C, o[h] = y;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < c; )
      a[f] = vu(r[f]);
  else {
    const C = vu(r);
    for (; ++f < c; )
      a[f] = C;
  }
  f = -1;
  const p = [], d = [];
  for (; ++f < c; ) {
    const C = a[f];
    let y = "", S = "";
    C === 99 ? (y = ":", S = ":") : C === 108 ? y = ":" : C === 114 && (S = ":");
    let O = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - y.length - S.length
    );
    const L = y + "-".repeat(O) + S;
    n.alignDelimiters !== !1 && (O = y.length + O + S.length, O > l[f] && (l[f] = O), d[f] = O), p[f] = L;
  }
  i.splice(1, 0, p), o.splice(1, 0, d), h = -1;
  const A = [];
  for (; ++h < i.length; ) {
    const C = i[h], y = o[h];
    f = -1;
    const S = [];
    for (; ++f < c; ) {
      const O = C[f] || "";
      let L = "", Y = "";
      if (n.alignDelimiters !== !1) {
        const q = l[f] - (y[f] || 0), k = a[f];
        k === 114 ? L = " ".repeat(q) : k === 99 ? q % 2 ? (L = " ".repeat(q / 2 + 0.5), Y = " ".repeat(q / 2 - 0.5)) : (L = " ".repeat(q / 2), Y = L) : Y = " ".repeat(q);
      }
      n.delimiterStart !== !1 && !f && S.push("|"), n.padding !== !1 && // Donât add the opening space if weâre not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && O === "") && (n.delimiterStart !== !1 || f) && S.push(" "), n.alignDelimiters !== !1 && S.push(L), S.push(O), n.alignDelimiters !== !1 && S.push(Y), n.padding !== !1 && S.push(" "), (n.delimiterEnd !== !1 || f !== c - 1) && S.push("|");
    }
    A.push(
      n.delimiterEnd === !1 ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return A.join(`
`);
}
function Hf(e) {
  return e == null ? "" : String(e);
}
function vu(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Uf(e, t, n, r) {
  const u = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const i = n.indentLines(
    n.containerFlow(e, a.current()),
    vf
  );
  return u(), i;
}
function vf(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function zf(e, t) {
  return zu(e, t.inConstruct, !0) && !zu(e, t.notInConstruct, !1);
}
function zu(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Yu(e, t, n, r) {
  let u = -1;
  for (; ++u < n.unsafe.length; )
    if (n.unsafe[u].character === `
` && zf(n.stack, n.unsafe[u]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Yf(e, t) {
  const n = String(e);
  let r = n.indexOf(t), u = r, a = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === u ? ++a > i && (i = a) : a = 1, u = r + t.length, r = n.indexOf(t, u);
  return i;
}
function qf(e, t) {
  return !!(t.options.fences === !1 && e.value && // If thereâs no infoâ¦
  !e.lang && // And thereâs a non-whitespace characterâ¦
  /[^ \r\n]/.test(e.value) && // And the value doesnât start or end in a blankâ¦
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function jf(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Vf(e, t, n, r) {
  const u = jf(n), a = e.value || "", i = u === "`" ? "GraveAccent" : "Tilde";
  if (qf(e, n)) {
    const f = n.enter("codeIndented"), p = n.indentLines(a, Wf);
    return f(), p;
  }
  const o = n.createTracker(r), l = u.repeat(Math.max(Yf(a, u) + 1, 3)), c = n.enter("codeFenced");
  let h = o.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${i}`);
    h += o.move(
      n.safe(e.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${i}`);
    h += o.move(" "), h += o.move(
      n.safe(e.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  return h += o.move(`
`), a && (h += o.move(a + `
`)), h += o.move(l), c(), h;
}
function Wf(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Yr(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Gf(e, t, n, r) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), o(), // If thereâs no url, orâ¦
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), i(), c;
}
function Qf(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Kt(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function _t(e) {
  if (e === null || ne(e) || rt(e))
    return 1;
  if (Hn(e))
    return 2;
}
function kn(e, t, n) {
  const r = _t(e), u = _t(t);
  return r === void 0 ? u === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Ga.peek = $f;
function Ga(e, t, n, r) {
  const u = Qf(n), a = n.enter("emphasis"), i = n.createTracker(r), o = i.move(u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), h = kn(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  h.inside && (l = Kt(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), p = kn(r.after.charCodeAt(0), f, u);
  p.inside && (l = l.slice(0, -1) + Kt(f));
  const d = i.move(u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: h.outside
  }, o + l + d;
}
function $f(e, t, n) {
  return n.options.emphasis || "*";
}
const Xf = {};
function qr(e, t) {
  const n = Xf, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, u = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return Qa(e, r, u);
}
function Qa(e, t, n) {
  if (Kf(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return qu(e.children, t, n);
  }
  return Array.isArray(e) ? qu(e, t, n) : "";
}
function qu(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; )
    r[u] = Qa(e[u], t, n);
  return r.join("");
}
function Kf(e) {
  return !!(e && typeof e == "object");
}
function Jf(e, t) {
  let n = !1;
  return nn(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Tr;
  }), !!((!e.depth || e.depth < 3) && qr(e) && (t.options.setext || n));
}
function Zf(e, t, n, r) {
  const u = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (Jf(e, n)) {
    const h = n.enter("headingSetext"), f = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f(), h(), p + `
` + (u === 1 ? "=" : "-").repeat(
      // The whole sizeâ¦
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â¦
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(u), o = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(i + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = Kt(c.charCodeAt(0)) + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), l(), o(), c;
}
$a.peek = eh;
function $a(e) {
  return e.value || "";
}
function eh() {
  return "<";
}
Xa.peek = th;
function Xa(e, t, n, r) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), o(), // If thereâs no url but there is a titleâ¦
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), c += l.move(")"), i(), c;
}
function th() {
  return "!";
}
Ka.peek = nh;
function Ka(e, t, n, r) {
  const u = e.referenceType, a = n.enter("imageReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function nh() {
  return "!";
}
Ja.peek = rh;
function Ja(e, t, n) {
  let r = e.value || "", u = "`", a = -1;
  for (; new RegExp("(^|[^`])" + u + "([^`]|$)").test(r); )
    u += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const i = n.unsafe[a], o = n.compilePattern(i);
    let l;
    if (i.atBreak)
      for (; l = o.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return u + r + u;
}
function rh() {
  return "`";
}
function Za(e, t) {
  const n = qr(e);
  return !!(!t.options.resourceLink && // If thereâs a urlâ¦
  e.url && // And thereâs a no titleâ¦
  !e.title && // And the content of `node` is a single text nodeâ¦
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the contentâ¦
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocolâ¦
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnât contain ASCII control codes (character escapes and
  // references donât work), space, or angle bracketsâ¦
  !/[\0- <>\u007F]/.test(e.url));
}
es.peek = uh;
function es(e, t, n, r) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r);
  let o, l;
  if (Za(e, n)) {
    const h = n.stack;
    n.stack = [], o = n.enter("autolink");
    let f = i.move("<");
    return f += i.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...i.current()
      })
    ), f += i.move(">"), o(), n.stack = h, f;
  }
  o = n.enter("link"), l = n.enter("label");
  let c = i.move("[");
  return c += i.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...i.current()
    })
  ), c += i.move("]("), l(), // If thereâs no url but there is a titleâ¦
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
    n.safe(e.url, { before: c, after: ">", ...i.current() })
  ), c += i.move(">")) : (l = n.enter("destinationRaw"), c += i.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += i.move(" " + u), c += i.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...i.current()
    })
  ), c += i.move(u), l()), c += i.move(")"), o(), c;
}
function uh(e, t, n) {
  return Za(e, n) ? "<" : "[";
}
ts.peek = ih;
function ts(e, t, n, r) {
  const u = e.referenceType, a = n.enter("linkReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function ih() {
  return "[";
}
function jr(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function ah(e) {
  const t = jr(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function sh(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function ns(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function oh(e, t, n, r) {
  const u = n.enter("list"), a = n.bulletCurrent;
  let i = e.ordered ? sh(n) : jr(n);
  const o = e.ordered ? i === "." ? ")" : "." : ah(n);
  let l = t && n.bulletLastUsed ? i === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const h = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), ns(n) === i && h
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const p = e.children[f];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (i = o), n.bulletCurrent = i;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = i, n.bulletCurrent = a, u(), c;
}
function lh(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function ch(e, t, n, r) {
  const u = lh(n);
  let a = n.bulletCurrent || jr(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let i = a.length + 1;
  (u === "tab" || u === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(i - a.length)), o.shift(i);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    h
  );
  return l(), c;
  function h(f, p, d) {
    return p ? (d ? "" : " ".repeat(i)) + f : (d ? a : a + " ".repeat(i - a.length)) + f;
  }
}
function fh(e, t, n, r) {
  const u = n.enter("paragraph"), a = n.enter("phrasing"), i = n.containerPhrasing(e, r);
  return a(), u(), i;
}
const hh = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Bn([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function dh(e, t, n, r) {
  return (e.children.some(function(i) {
    return hh(i);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function mh(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
rs.peek = ph;
function rs(e, t, n, r) {
  const u = mh(n), a = n.enter("strong"), i = n.createTracker(r), o = i.move(u + u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), h = kn(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  h.inside && (l = Kt(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), p = kn(r.after.charCodeAt(0), f, u);
  p.inside && (l = l.slice(0, -1) + Kt(f));
  const d = i.move(u + u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: h.outside
  }, o + l + d;
}
function ph(e, t, n) {
  return n.options.strong || "*";
}
function Eh(e, t, n, r) {
  return n.safe(e.value, r);
}
function gh(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Th(e, t, n) {
  const r = (ns(n) + (n.options.ruleSpaces ? " " : "")).repeat(gh(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const us = {
  blockquote: Uf,
  break: Yu,
  code: Vf,
  definition: Gf,
  emphasis: Ga,
  hardBreak: Yu,
  heading: Zf,
  html: $a,
  image: Xa,
  imageReference: Ka,
  inlineCode: Ja,
  link: es,
  linkReference: ts,
  list: oh,
  listItem: ch,
  paragraph: fh,
  root: dh,
  strong: rs,
  text: Eh,
  thematicBreak: Th
};
function bh() {
  return {
    enter: {
      table: Ah,
      tableData: ju,
      tableHeader: ju,
      tableRow: Ch
    },
    exit: {
      codeText: Sh,
      table: _h,
      tableData: Xn,
      tableHeader: Xn,
      tableRow: Xn
    }
  };
}
function Ah(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function _h(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Ch(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Xn(e) {
  this.exit(e);
}
function ju(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Sh(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, xh));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function xh(e, t) {
  return t === "|" ? t : e;
}
function Ih(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, u = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: i,
      tableCell: l,
      tableRow: o
    }
  };
  function i(d, A, C, y) {
    return c(h(d, C, y), d.align);
  }
  function o(d, A, C, y) {
    const S = f(d, C, y), O = c([S]);
    return O.slice(0, O.indexOf(`
`));
  }
  function l(d, A, C, y) {
    const S = C.enter("tableCell"), O = C.enter("phrasing"), L = C.containerPhrasing(d, {
      ...y,
      before: a,
      after: a
    });
    return O(), S(), L;
  }
  function c(d, A) {
    return Ff(d, {
      align: A,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: u
    });
  }
  function h(d, A, C) {
    const y = d.children;
    let S = -1;
    const O = [], L = A.enter("table");
    for (; ++S < y.length; )
      O[S] = f(y[S], A, C);
    return L(), O;
  }
  function f(d, A, C) {
    const y = d.children;
    let S = -1;
    const O = [], L = A.enter("tableRow");
    for (; ++S < y.length; )
      O[S] = l(y[S], d, A, C);
    return L(), O;
  }
  function p(d, A, C) {
    let y = us.inlineCode(d, A, C);
    return C.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function kh() {
  return {
    exit: {
      taskListCheckValueChecked: Vu,
      taskListCheckValueUnchecked: Vu,
      paragraph: Nh
    }
  };
}
function yh() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Oh }
  };
}
function Vu(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Nh(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const u = t.children;
      let a = -1, i;
      for (; ++a < u.length; ) {
        const o = u[a];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function Oh(e, t, n, r) {
  const u = e.children[0], a = typeof e.checked == "boolean" && u && u.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(i);
  let l = us.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(h) {
    return h + i;
  }
}
function Lh() {
  return [
    af(),
    yf(),
    Rf(),
    bh(),
    kh()
  ];
}
function Rh(e) {
  return {
    extensions: [
      sf(),
      Nf(e),
      Df(),
      Ih(e),
      yh()
    ]
  };
}
function gn(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
const Wu = {}.hasOwnProperty;
function Dh(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Ph(t, e[n]);
  return t;
}
function Ph(e, t) {
  let n;
  for (n in t) {
    const u = (Wu.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        Wu.call(u, i) || (u[i] = []);
        const o = a[i];
        wh(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function wh(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  gn(e, 0, 0, r);
}
const Mh = {
  tokenize: zh,
  partial: !0
}, is = {
  tokenize: Yh,
  partial: !0
}, as = {
  tokenize: qh,
  partial: !0
}, ss = {
  tokenize: jh,
  partial: !0
}, Bh = {
  tokenize: Vh,
  partial: !0
}, os = {
  name: "wwwAutolink",
  tokenize: Uh,
  previous: cs
}, ls = {
  name: "protocolAutolink",
  tokenize: vh,
  previous: fs
}, Ye = {
  name: "emailAutolink",
  tokenize: Hh,
  previous: hs
}, Be = {};
function Fh() {
  return {
    text: Be
  };
}
let et = 48;
for (; et < 123; )
  Be[et] = Ye, et++, et === 58 ? et = 65 : et === 91 && (et = 97);
Be[43] = Ye;
Be[45] = Ye;
Be[46] = Ye;
Be[95] = Ye;
Be[72] = [Ye, ls];
Be[104] = [Ye, ls];
Be[87] = [Ye, os];
Be[119] = [Ye, os];
function Hh(e, t, n) {
  const r = this;
  let u, a;
  return i;
  function i(f) {
    return !Ar(f) || !hs.call(r, r.previous) || Vr(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(f));
  }
  function o(f) {
    return Ar(f) ? (e.consume(f), o) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(Bh, h, c)(f) : f === 45 || f === 95 || me(f) ? (a = !0, e.consume(f), l) : h(f);
  }
  function c(f) {
    return e.consume(f), u = !0, l;
  }
  function h(f) {
    return a && u && ge(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function Uh(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i !== 87 && i !== 119 || !cs.call(r, r.previous) || Vr(r.events) ? n(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Mh, e.attempt(is, e.attempt(as, a), n), n)(i));
  }
  function a(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function vh(e, t, n) {
  const r = this;
  let u = "", a = !1;
  return i;
  function i(f) {
    return (f === 72 || f === 104) && fs.call(r, r.previous) && !Vr(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), u += String.fromCodePoint(f), e.consume(f), o) : n(f);
  }
  function o(f) {
    if (ge(f) && u.length < 5)
      return u += String.fromCodePoint(f), e.consume(f), o;
    if (f === 58) {
      const p = u.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), a ? c : (a = !0, l)) : n(f);
  }
  function c(f) {
    return f === null || In(f) || ne(f) || rt(f) || Hn(f) ? n(f) : e.attempt(is, e.attempt(as, h), n)(f);
  }
  function h(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function zh(e, t, n) {
  let r = 0;
  return u;
  function u(i) {
    return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), u) : i === 46 && r === 3 ? (e.consume(i), a) : n(i);
  }
  function a(i) {
    return i === null ? n(i) : t(i);
  }
}
function Yh(e, t, n) {
  let r, u, a;
  return i;
  function i(c) {
    return c === 46 || c === 95 ? e.check(ss, l, o)(c) : c === null || ne(c) || rt(c) || c !== 45 && Hn(c) ? l(c) : (a = !0, e.consume(c), i);
  }
  function o(c) {
    return c === 95 ? r = !0 : (u = r, r = void 0), e.consume(c), i;
  }
  function l(c) {
    return u || r || !a ? n(c) : t(c);
  }
}
function qh(e, t) {
  let n = 0, r = 0;
  return u;
  function u(i) {
    return i === 40 ? (n++, e.consume(i), u) : i === 41 && r < n ? a(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(ss, t, a)(i) : i === null || ne(i) || rt(i) ? t(i) : (e.consume(i), u);
  }
  function a(i) {
    return i === 41 && r++, e.consume(i), u;
  }
}
function jh(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), u) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || ne(o) || rt(o) ? t(o) : n(o)
    );
  }
  function u(o) {
    return o === null || o === 40 || o === 91 || ne(o) || rt(o) ? t(o) : r(o);
  }
  function a(o) {
    return ge(o) ? i(o) : n(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), r) : ge(o) ? (e.consume(o), i) : n(o);
  }
}
function Vh(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), u;
  }
  function u(a) {
    return me(a) ? n(a) : t(a);
  }
}
function cs(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ne(e);
}
function fs(e) {
  return !ge(e);
}
function hs(e) {
  return !(e === 47 || Ar(e));
}
function Ar(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || me(e);
}
function Vr(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function kt(e) {
  const t = [];
  let n = -1, r = 0, u = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let i = "";
    if (a === 37 && me(e.charCodeAt(n + 1)) && me(e.charCodeAt(n + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(a, o), u = 1) : i = "ï¿½";
    } else
      i = String.fromCharCode(a);
    i && (t.push(e.slice(r, n), encodeURIComponent(i)), r = n + u + 1, i = ""), u && (n += u, u = 0);
  }
  return t.join("") + e.slice(r);
}
function Wh(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
function J(e, t, n, r) {
  const u = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(l) {
    return X(l) ? (e.enter(n), o(l)) : t(l);
  }
  function o(l) {
    return X(l) && a++ < u ? (e.consume(l), o) : (e.exit(n), t(l));
  }
}
const Gh = {
  partial: !0,
  tokenize: Qh
};
function Qh(e, t, n) {
  return r;
  function r(a) {
    return X(a) ? J(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? t(a) : n(a);
  }
}
function Wt(e, t) {
  let n;
  return r;
  function r(u) {
    return z(u) ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), n = !0, r) : X(u) ? J(e, r, n ? "linePrefix" : "lineSuffix")(u) : t(u);
  }
}
const $h = {
  tokenize: rd,
  partial: !0
};
function Xh() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: ed,
        continuation: {
          tokenize: td
        },
        exit: nd
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: Zh
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Kh,
        resolveTo: Jh
      }
    }
  };
}
function Kh(e, t, n) {
  const r = this;
  let u = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const l = r.events[u][1];
    if (l.type === "labelImage") {
      i = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!i || !i._balanced)
      return n(l);
    const c = un(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function Jh(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", u, t],
    ["exit", u, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function Zh(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, i;
  return o;
  function o(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(f) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || ne(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return u.includes(un(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return ne(f) || (i = !0), a++, e.consume(f), f === 92 ? h : c;
  }
  function h(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), a++, c) : c(f);
  }
}
function ed(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, i = 0, o;
  return l;
  function l(A) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(A) {
    return A === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", h) : n(A);
  }
  function h(A) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      A === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      A === null || A === 91 || ne(A)
    )
      return n(A);
    if (A === 93) {
      e.exit("chunkString");
      const C = e.exit("gfmFootnoteDefinitionLabelString");
      return a = un(r.sliceSerialize(C)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return ne(A) || (o = !0), i++, e.consume(A), A === 92 ? f : h;
  }
  function f(A) {
    return A === 91 || A === 92 || A === 93 ? (e.consume(A), i++, h) : h(A);
  }
  function p(A) {
    return A === 58 ? (e.enter("definitionMarker"), e.consume(A), e.exit("definitionMarker"), u.includes(a) || u.push(a), J(e, d, "gfmFootnoteDefinitionWhitespace")) : n(A);
  }
  function d(A) {
    return t(A);
  }
}
function td(e, t, n) {
  return e.check(Gh, t, e.attempt($h, t, n));
}
function nd(e) {
  e.exit("gfmFootnoteDefinition");
}
function rd(e, t, n) {
  const r = this;
  return J(e, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(a) : n(a);
  }
}
function ud(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, o) {
    let l = -1;
    for (; ++l < i.length; )
      if (i[l][0] === "enter" && i[l][1].type === "strikethroughSequenceTemporary" && i[l][1]._close) {
        let c = l;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[l][1].end.offset - i[l][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[l][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[l][1].start)
            }, p = [["enter", h, o], ["enter", i[c][1], o], ["exit", i[c][1], o], ["enter", f, o]], d = o.parser.constructs.insideSpan.null;
            d && gn(p, p.length, 0, Wh(d, i.slice(c + 1, l), o)), gn(p, p.length, 0, [["exit", f, o], ["enter", i[l][1], o], ["exit", i[l][1], o], ["exit", h, o]]), gn(i, c - 1, l - c + 3, p), l = c + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i.length; )
      i[l][1].type === "strikethroughSequenceTemporary" && (i[l][1].type = "data");
    return i;
  }
  function a(i, o, l) {
    const c = this.previous, h = this.events;
    let f = 0;
    return p;
    function p(A) {
      return c === 126 && h[h.length - 1][1].type !== "characterEscape" ? l(A) : (i.enter("strikethroughSequenceTemporary"), d(A));
    }
    function d(A) {
      const C = _t(c);
      if (A === 126)
        return f > 1 ? l(A) : (i.consume(A), f++, d);
      if (f < 2 && !n) return l(A);
      const y = i.exit("strikethroughSequenceTemporary"), S = _t(A);
      return y._open = !S || S === 2 && !!C, y._close = !C || C === 2 && !!S, o(A);
    }
  }
}
class id {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    ad(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let u = r.pop();
    for (; u; ) {
      for (const a of u)
        t.push(a);
      u = r.pop();
    }
    this.map.length = 0;
  }
}
function ad(e, t, n, r) {
  let u = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; u < e.map.length; ) {
      if (e.map[u][0] === t) {
        e.map[u][1] += n, e.map[u][2].push(...r);
        return;
      }
      u += 1;
    }
    e.map.push([t, n, r]);
  }
}
function sd(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const u = e[t];
    if (n) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function od() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: ld,
        resolveAll: cd
      }
    }
  };
}
function ld(e, t, n) {
  const r = this;
  let u = 0, a = 0, i;
  return o;
  function o(I) {
    let H = r.events.length - 1;
    for (; H > -1; ) {
      const F = r.events[H][1].type;
      if (F === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      F === "linePrefix") H--;
      else break;
    }
    const U = H > -1 ? r.events[H][1].type : null, v = U === "tableHead" || U === "tableRow" ? k : l;
    return v === k && r.parser.lazy[r.now().line] ? n(I) : v(I);
  }
  function l(I) {
    return e.enter("tableHead"), e.enter("tableRow"), c(I);
  }
  function c(I) {
    return I === 124 || (i = !0, a += 1), h(I);
  }
  function h(I) {
    return I === null ? n(I) : z(I) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), d) : n(I) : X(I) ? J(e, h, "whitespace")(I) : (a += 1, i && (i = !1, u += 1), I === 124 ? (e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), i = !0, h) : (e.enter("data"), f(I)));
  }
  function f(I) {
    return I === null || I === 124 || ne(I) ? (e.exit("data"), h(I)) : (e.consume(I), I === 92 ? p : f);
  }
  function p(I) {
    return I === 92 || I === 124 ? (e.consume(I), f) : f(I);
  }
  function d(I) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(I) : (e.enter("tableDelimiterRow"), i = !1, X(I) ? J(e, A, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : A(I));
  }
  function A(I) {
    return I === 45 || I === 58 ? y(I) : I === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), C) : q(I);
  }
  function C(I) {
    return X(I) ? J(e, y, "whitespace")(I) : y(I);
  }
  function y(I) {
    return I === 58 ? (a += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(I), e.exit("tableDelimiterMarker"), S) : I === 45 ? (a += 1, S(I)) : I === null || z(I) ? Y(I) : q(I);
  }
  function S(I) {
    return I === 45 ? (e.enter("tableDelimiterFiller"), O(I)) : q(I);
  }
  function O(I) {
    return I === 45 ? (e.consume(I), O) : I === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(I), e.exit("tableDelimiterMarker"), L) : (e.exit("tableDelimiterFiller"), L(I));
  }
  function L(I) {
    return X(I) ? J(e, Y, "whitespace")(I) : Y(I);
  }
  function Y(I) {
    return I === 124 ? A(I) : I === null || z(I) ? !i || u !== a ? q(I) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(I)) : q(I);
  }
  function q(I) {
    return n(I);
  }
  function k(I) {
    return e.enter("tableRow"), Q(I);
  }
  function Q(I) {
    return I === 124 ? (e.enter("tableCellDivider"), e.consume(I), e.exit("tableCellDivider"), Q) : I === null || z(I) ? (e.exit("tableRow"), t(I)) : X(I) ? J(e, Q, "whitespace")(I) : (e.enter("data"), Z(I));
  }
  function Z(I) {
    return I === null || I === 124 || ne(I) ? (e.exit("data"), Q(I)) : (e.consume(I), I === 92 ? ee : Z);
  }
  function ee(I) {
    return I === 92 || I === 124 ? (e.consume(I), Z) : Z(I);
  }
}
function cd(e, t) {
  let n = -1, r = !0, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, l = 0, c, h, f;
  const p = new id();
  for (; ++n < e.length; ) {
    const d = e[n], A = d[1];
    d[0] === "enter" ? A.type === "tableHead" ? (o = !1, l !== 0 && (Gu(p, t, l, c, h), h = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p.add(n, 0, [["enter", c, t]])) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (r = !0, f = void 0, a = [0, 0, 0, 0], i = [0, n + 1, 0, 0], o && (o = !1, h = {
      type: "tableBody",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p.add(n, 0, [["enter", h, t]])), u = A.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], f = cn(p, t, a, u, void 0, f), a = [0, 0, 0, 0]), i[2] = n)) : A.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], f = cn(p, t, a, u, void 0, f)), a = i, i = [a[1], n, 0, 0])) : A.type === "tableHead" ? (o = !0, l = n) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (i[0] = i[1], f = cn(p, t, a, u, n, f)) : i[1] !== 0 && (f = cn(p, t, i, u, n, f)), u = 0) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") && (i[3] = n);
  }
  for (l !== 0 && Gu(p, t, l, c, h), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const d = t.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = sd(t.events, n));
  }
  return e;
}
function cn(e, t, n, r, u, a) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, mt(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = mt(t.events, n[1]);
  if (a = {
    type: i,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = mt(t.events, n[2]), h = mt(t.events, n[3]), f = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, h)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const p = t.events[n[2]], d = t.events[n[3]];
      if (p[1].end = Object.assign({}, d[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const A = n[2] + 1, C = n[3] - n[2] - 1;
        e.add(A, C, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, mt(t.events, u)), e.add(u, 0, [["exit", a, t]]), a = void 0), a;
}
function Gu(e, t, n, r, u) {
  const a = [], i = mt(t.events, n);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, t])), r.end = Object.assign({}, i), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function mt(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const fd = {
  name: "tasklistCheck",
  tokenize: dd
};
function hd() {
  return {
    text: {
      91: fd
    }
  };
}
function dd(e, t, n) {
  const r = this;
  return u;
  function u(l) {
    return (
      // Exit if thereâs stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return ne(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), i) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), i) : n(l);
  }
  function i(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(l);
  }
  function o(l) {
    return z(l) ? t(l) : X(l) ? e.check({
      tokenize: md
    }, t, n)(l) : n(l);
  }
}
function md(e, t, n) {
  return J(e, r, "whitespace");
  function r(u) {
    return u === null ? n(u) : t(u);
  }
}
function pd(e) {
  return Dh([
    Fh(),
    Xh(),
    ud(e),
    od(),
    hd()
  ]);
}
const Ed = {};
function gd(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || Ed, r = t.data(), u = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  u.push(pd(n)), a.push(Lh()), i.push(Rh(n));
}
const ds = ro(
  void 0
), Wr = () => {
  const e = uo(ds);
  if (!e)
    throw new Error(
      "useViewportAnchor must be used within a CurrentAnchorProvider"
    );
  return e;
}, Td = () => {
  const e = Ut(null), { observe: t, unobserve: n } = Wr();
  return bt(() => {
    const u = e.current;
    if (u)
      return t(u), () => n(u);
  }, [t, n]), { ref: Hi((u) => {
    u && (e.current = u);
  }, []) };
}, Ng = ({ children: e }) => {
  const [t, n] = cr(""), r = Ut(null), u = Ut(/* @__PURE__ */ new Set()), a = Ut(/* @__PURE__ */ new Set());
  bt(() => (r.current = new IntersectionObserver(
    (l) => {
      for (const c of l)
        c.isIntersecting && c.target.id && n(c.target.id);
    },
    {
      rootMargin: "0px 0px -80% 0px",
      threshold: 0.75
    }
  ), a.current.forEach((l) => {
    var c;
    u.current.add(l), (c = r.current) == null || c.observe(l);
  }), a.current.clear(), () => {
    var l;
    return (l = r.current) == null ? void 0 : l.disconnect();
  }), []), bt(() => {
    const l = u.current, c = () => {
      const h = window.scrollY === 0, f = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      if (h)
        n("");
      else if (f) {
        const p = Array.from(l).pop(), d = (p == null ? void 0 : p.id) ?? "";
        n(d);
      }
    };
    return document.addEventListener("scroll", c), () => {
      l.clear(), document.removeEventListener("scroll", c);
    };
  }, []);
  const i = fu(() => ({
    observe: (l) => {
      if (l) {
        if (!r.current) {
          a.current.add(l);
          return;
        }
        u.current.add(l), r.current.observe(l);
      }
    },
    unobserve: (l) => {
      var c;
      l && (a.current.delete(l), u.current.delete(l), (c = r.current) == null || c.unobserve(l));
    }
  }), []), o = fu(
    () => ({ activeAnchor: t, setActiveAnchor: n, ...i }),
    [t, n, i]
  );
  return /* @__PURE__ */ B.jsx(ds, { value: o, children: e });
}, bd = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600",
  outline: "border border-border rounded-md text-foreground"
}, Ad = {
  green: "text-green-500 dark:text-green-600",
  blue: "text-sky-400 dark:text-sky-600",
  yellow: "text-yellow-400 dark:text-yellow-600",
  red: "text-red-400 dark:text-red-600",
  purple: "text-purple-400 dark:text-purple-600",
  indigo: "text-indigo-400 dark:text-indigo-600",
  gray: "text-gray-400 dark:text-gray-600",
  outline: ""
}, Qu = ({
  color: e,
  label: t,
  className: n,
  invert: r
}) => /* @__PURE__ */ B.jsx(
  "span",
  {
    className: vt(
      "flex items-center duration-200 transition-opacity text-center uppercase text-[0.65rem] font-bold rounded text-background dark:text-zinc-50 h-full",
      e === "outline" ? "px-3" : "mt-0.5 px-1",
      r ? Ad[e] : bd[e],
      n
    ),
    children: t
  }
);
var _d = Object.getOwnPropertyNames, Cd = Object.getOwnPropertySymbols, Sd = Object.prototype.hasOwnProperty;
function $u(e, t) {
  return function(r, u, a) {
    return e(r, u, a) && t(r, u, a);
  };
}
function fn(e) {
  return function(n, r, u) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, u);
    var a = u.cache, i = a.get(n), o = a.get(r);
    if (i && o)
      return i === r && o === n;
    a.set(n, r), a.set(r, n);
    var l = e(n, r, u);
    return a.delete(n), a.delete(r), l;
  };
}
function Xu(e) {
  return _d(e).concat(Cd(e));
}
var xd = Object.hasOwn || function(e, t) {
  return Sd.call(e, t);
};
function at(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
var Id = "__v", kd = "__o", yd = "_owner", Ku = Object.getOwnPropertyDescriptor, Ju = Object.keys;
function Nd(e, t, n) {
  var r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function Od(e, t) {
  return at(e.getTime(), t.getTime());
}
function Ld(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function Rd(e, t) {
  return e === t;
}
function Zu(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.entries(), i, o, l = 0; (i = a.next()) && !i.done; ) {
    for (var c = t.entries(), h = !1, f = 0; (o = c.next()) && !o.done; ) {
      if (u[f]) {
        f++;
        continue;
      }
      var p = i.value, d = o.value;
      if (n.equals(p[0], d[0], l, f, e, t, n) && n.equals(p[1], d[1], p[0], d[0], e, t, n)) {
        h = u[f] = !0;
        break;
      }
      f++;
    }
    if (!h)
      return !1;
    l++;
  }
  return !0;
}
var Dd = at;
function Pd(e, t, n) {
  var r = Ju(e), u = r.length;
  if (Ju(t).length !== u)
    return !1;
  for (; u-- > 0; )
    if (!ms(e, t, n, r[u]))
      return !1;
  return !0;
}
function wt(e, t, n) {
  var r = Xu(e), u = r.length;
  if (Xu(t).length !== u)
    return !1;
  for (var a, i, o; u-- > 0; )
    if (a = r[u], !ms(e, t, n, a) || (i = Ku(e, a), o = Ku(t, a), (i || o) && (!i || !o || i.configurable !== o.configurable || i.enumerable !== o.enumerable || i.writable !== o.writable)))
      return !1;
  return !0;
}
function wd(e, t) {
  return at(e.valueOf(), t.valueOf());
}
function Md(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function ei(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.values(), i, o; (i = a.next()) && !i.done; ) {
    for (var l = t.values(), c = !1, h = 0; (o = l.next()) && !o.done; ) {
      if (!u[h] && n.equals(i.value, o.value, i.value, o.value, e, t, n)) {
        c = u[h] = !0;
        break;
      }
      h++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function Bd(e, t) {
  var n = e.length;
  if (t.length !== n)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Fd(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function ms(e, t, n, r) {
  return (r === yd || r === kd || r === Id) && (e.$$typeof || t.$$typeof) ? !0 : xd(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
var Hd = "[object Arguments]", Ud = "[object Boolean]", vd = "[object Date]", zd = "[object Error]", Yd = "[object Map]", qd = "[object Number]", jd = "[object Object]", Vd = "[object RegExp]", Wd = "[object Set]", Gd = "[object String]", Qd = "[object URL]", $d = Array.isArray, ti = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, ni = Object.assign, Xd = Object.prototype.toString.call.bind(Object.prototype.toString);
function Kd(e) {
  var t = e.areArraysEqual, n = e.areDatesEqual, r = e.areErrorsEqual, u = e.areFunctionsEqual, a = e.areMapsEqual, i = e.areNumbersEqual, o = e.areObjectsEqual, l = e.arePrimitiveWrappersEqual, c = e.areRegExpsEqual, h = e.areSetsEqual, f = e.areTypedArraysEqual, p = e.areUrlsEqual;
  return function(A, C, y) {
    if (A === C)
      return !0;
    if (A == null || C == null)
      return !1;
    var S = typeof A;
    if (S !== typeof C)
      return !1;
    if (S !== "object")
      return S === "number" ? i(A, C, y) : S === "function" ? u(A, C, y) : !1;
    var O = A.constructor;
    if (O !== C.constructor)
      return !1;
    if (O === Object)
      return o(A, C, y);
    if ($d(A))
      return t(A, C, y);
    if (ti != null && ti(A))
      return f(A, C, y);
    if (O === Date)
      return n(A, C, y);
    if (O === RegExp)
      return c(A, C, y);
    if (O === Map)
      return a(A, C, y);
    if (O === Set)
      return h(A, C, y);
    var L = Xd(A);
    return L === vd ? n(A, C, y) : L === Vd ? c(A, C, y) : L === Yd ? a(A, C, y) : L === Wd ? h(A, C, y) : L === jd ? typeof A.then != "function" && typeof C.then != "function" && o(A, C, y) : L === Qd ? p(A, C, y) : L === zd ? r(A, C, y) : L === Hd ? o(A, C, y) : L === Ud || L === qd || L === Gd ? l(A, C, y) : !1;
  };
}
function Jd(e) {
  var t = e.circular, n = e.createCustomConfig, r = e.strict, u = {
    areArraysEqual: r ? wt : Nd,
    areDatesEqual: Od,
    areErrorsEqual: Ld,
    areFunctionsEqual: Rd,
    areMapsEqual: r ? $u(Zu, wt) : Zu,
    areNumbersEqual: Dd,
    areObjectsEqual: r ? wt : Pd,
    arePrimitiveWrappersEqual: wd,
    areRegExpsEqual: Md,
    areSetsEqual: r ? $u(ei, wt) : ei,
    areTypedArraysEqual: r ? wt : Bd,
    areUrlsEqual: Fd
  };
  if (n && (u = ni({}, u, n(u))), t) {
    var a = fn(u.areArraysEqual), i = fn(u.areMapsEqual), o = fn(u.areObjectsEqual), l = fn(u.areSetsEqual);
    u = ni({}, u, {
      areArraysEqual: a,
      areMapsEqual: i,
      areObjectsEqual: o,
      areSetsEqual: l
    });
  }
  return u;
}
function Zd(e) {
  return function(t, n, r, u, a, i, o) {
    return e(t, n, o);
  };
}
function em(e) {
  var t = e.circular, n = e.comparator, r = e.createState, u = e.equals, a = e.strict;
  if (r)
    return function(l, c) {
      var h = r(), f = h.cache, p = f === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : f, d = h.meta;
      return n(l, c, {
        cache: p,
        equals: u,
        meta: d,
        strict: a
      });
    };
  if (t)
    return function(l, c) {
      return n(l, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: u,
        meta: void 0,
        strict: a
      });
    };
  var i = {
    cache: void 0,
    equals: u,
    meta: void 0,
    strict: a
  };
  return function(l, c) {
    return n(l, c, i);
  };
}
var tm = $e();
$e({ strict: !0 });
$e({ circular: !0 });
$e({
  circular: !0,
  strict: !0
});
$e({
  createInternalComparator: function() {
    return at;
  }
});
$e({
  strict: !0,
  createInternalComparator: function() {
    return at;
  }
});
$e({
  circular: !0,
  createInternalComparator: function() {
    return at;
  }
});
$e({
  circular: !0,
  createInternalComparator: function() {
    return at;
  },
  strict: !0
});
function $e(e) {
  e === void 0 && (e = {});
  var t = e.circular, n = t === void 0 ? !1 : t, r = e.createInternalComparator, u = e.createState, a = e.strict, i = a === void 0 ? !1 : a, o = Jd(e), l = Kd(o), c = r ? r(l) : Zd(l);
  return em({ circular: n, comparator: l, createState: u, equals: c, strict: i });
}
const nm = ({
  category: e,
  onRequestClose: t
}) => {
  var A, C;
  const n = co(e), [r, u] = cr(!1), a = e.collapsible ?? !0, i = e.collapsed ?? !0, o = !!(!a || !i || n), [l, c] = cr(o), h = io(((A = e.link) == null ? void 0 : A.id) ?? "");
  bt(() => {
    n && c(!0);
  }, [n]);
  const f = a && /* @__PURE__ */ B.jsx(
    mo,
    {
      onClick: (y) => {
        y.preventDefault(), c((S) => !S), u(!0);
      },
      variant: "ghost",
      size: "icon",
      className: "size-6 hover:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l-5))] hover:dark:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l+5))]",
      children: /* @__PURE__ */ B.jsx(
        oo,
        {
          size: 16,
          className: vt(
            r && "transition",
            "shrink-0 group-data-[state=open]:rotate-90"
          )
        }
      )
    }
  ), p = e.icon && /* @__PURE__ */ B.jsx(
    e.icon,
    {
      size: 16,
      className: vt("align-[-0.125em] ", h && "text-primary")
    }
  ), d = Tn({
    className: [
      "group text-start font-medium",
      a || typeof e.link < "u" ? "cursor-pointer" : "cursor-default hover:bg-transparent"
    ]
  });
  return /* @__PURE__ */ B.jsxs(
    Yn.Root,
    {
      className: "flex flex-col",
      defaultOpen: o,
      open: l,
      onOpenChange: () => c(!0),
      children: [
        /* @__PURE__ */ B.jsx(Yn.Trigger, { className: "group", asChild: !0, disabled: !a, children: ((C = e.link) == null ? void 0 : C.type) === "doc" ? /* @__PURE__ */ B.jsxs(
          Nr,
          {
            to: fo(e.link.id),
            className: d,
            onClick: () => {
              u(!0), h && !l && c(!0);
            },
            children: [
              p,
              /* @__PURE__ */ B.jsxs("div", { className: "flex items-center gap-2 justify-between w-full text-foreground/80 group-aria-[current='page']:text-primary", children: [
                /* @__PURE__ */ B.jsx("div", { className: "truncate", children: e.label }),
                f
              ] })
            ]
          }
        ) : /* @__PURE__ */ B.jsxs("div", { onClick: () => u(!0), className: d, children: [
          p,
          /* @__PURE__ */ B.jsxs("div", { className: "flex items-center justify-between w-full", children: [
            /* @__PURE__ */ B.jsx("div", { className: "flex gap-2 truncate w-full", children: e.label }),
            f
          ] })
        ] }) }),
        /* @__PURE__ */ B.jsx(
          Yn.Content,
          {
            className: vt(
              // CollapsibleContent class is used to animate and it should only be applied when the user has triggered the toggle
              r && "CollapsibleContent",
              e.items.length === 0 && "hidden",
              "ms-6 my-1"
            ),
            children: /* @__PURE__ */ B.jsx("ul", { className: "relative after:absolute after:-left-[--padding-nav-item] after:translate-x-[1.5px] after:top-0 after:bottom-0 after:w-px after:bg-border", children: e.items.map((y) => /* @__PURE__ */ B.jsx(
              rm,
              {
                onRequestClose: t,
                item: y
              },
              ("id" in y ? y.id : "") + ("href" in y ? y.href : "") + y.label
            )) })
          }
        )
      ]
    }
  );
}, ps = Ui(nm, tm);
ps.displayName = "SidebarCategory";
const Tn = vi(
  "flex items-center gap-2 px-[--padding-nav-item] my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums",
  {
    variants: {
      isActive: {
        true: "bg-accent font-medium",
        false: "text-foreground/80"
      },
      isMuted: {
        true: "text-foreground/30",
        false: ""
      },
      isPending: {
        true: "bg-accent animate-pulse",
        false: ""
      }
    },
    defaultVariants: {
      isActive: !1
    }
  }
), Es = "data-anchor", rm = ({
  item: e,
  onRequestClose: t
}) => {
  var a;
  const n = Or(), { activeAnchor: r } = Wr(), [u] = ao();
  switch (e.type) {
    case "category":
      return /* @__PURE__ */ B.jsx(ps, { category: e, onRequestClose: t });
    case "doc":
      return /* @__PURE__ */ B.jsxs(
        Nr,
        {
          className: ({ isActive: i, isPending: o }) => Tn({ isActive: i, isPending: o }),
          to: ho(e.id),
          onClick: t,
          end: !0,
          children: [
            e.icon && /* @__PURE__ */ B.jsx(e.icon, { size: 16, className: "align-[-0.125em]" }),
            e.badge ? /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
              /* @__PURE__ */ B.jsx("span", { className: "truncate flex-1", title: e.label, children: e.label }),
              /* @__PURE__ */ B.jsx(Qu, { ...e.badge })
            ] }) : e.label
          ]
        }
      );
    case "link":
      return e.href.startsWith("http") ? /* @__PURE__ */ B.jsxs(
        "a",
        {
          className: Tn(),
          href: e.href,
          target: "_blank",
          rel: "noopener noreferrer",
          onClick: t,
          children: [
            /* @__PURE__ */ B.jsx("span", { className: "whitespace-normal", children: e.label }),
            /* @__PURE__ */ B.jsx("span", { className: "whitespace-nowrap", children: /* @__PURE__ */ B.jsx(lo, { className: "inline -translate-y-0.5", size: 12 }) })
          ]
        }
      ) : /* @__PURE__ */ B.jsx(
        Ts,
        {
          to: {
            pathname: e.href.split("#")[0],
            hash: e.href.split("#")[1],
            search: u.toString()
          },
          [Es]: e.href.split("#")[1],
          className: Tn({
            isActive: e.href === [n.pathname, r].join("#"),
            className: ((a = e.badge) == null ? void 0 : a.placement) !== "start" && "justify-between"
          }),
          onClick: t,
          children: e.badge ? /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
            /* @__PURE__ */ B.jsx("span", { className: "truncate", title: e.label, children: e.label }),
            /* @__PURE__ */ B.jsx(Qu, { ...e.badge })
          ] }) : /* @__PURE__ */ B.jsx("span", { className: "break-all", children: e.label })
        }
      );
  }
}, um = (e, t = { block: "center" }) => {
  if (!e) return;
  const n = e.getBoundingClientRect();
  n.top >= 0 && n.left >= 0 && n.bottom <= (window.innerHeight || document.documentElement.clientHeight) && n.right <= (window.innerWidth || document.documentElement.clientWidth) || e.scrollIntoView(t);
}, gs = () => {
  const { setActiveAnchor: e } = Wr();
  return Hi(
    (n) => {
      const r = n.replace(/^#/, ""), u = r.split("/").at(0), a = document.getElementById(decodeURIComponent(r)), i = document.querySelector(
        `[${Es}="${u}"]`
      );
      return a ? (a.scrollIntoView(), um(i), requestIdleCallback(() => e(u)), !0) : !1;
    },
    [e]
  );
}, Og = () => {
  const e = Or(), t = gs(), n = Ut(!1);
  bt(() => {
    !e.hash || !n.current || t(e.hash);
  }, [e.hash, t]), bt(() => {
    if (!e.hash) {
      n.current = !0;
      return;
    }
    const r = new MutationObserver((u, a) => {
      t(e.hash) && (n.current = !0, a.disconnect());
    });
    return r.observe(document.body, { childList: !0, subtree: !0 }), () => r.disconnect();
  }, [e.hash, t]);
}, Ts = (e) => {
  const t = Or(), n = gs(), r = so(e.to), [u, a] = r.split("#"), i = (o) => {
    var l;
    (l = e.onClick) == null || l.call(e, o), !(a !== t.hash.slice(1) || u !== t.pathname) && (o.preventDefault(), n(a));
  };
  return /* @__PURE__ */ B.jsx(Nr, { ...e, onClick: i });
}, im = vi("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
}), am = (e) => {
  switch (e) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
}, ft = ({
  level: e,
  children: t,
  id: n,
  className: r,
  registerSidebarAnchor: u
}) => {
  const a = am(e ?? 1), { ref: i } = Td();
  return /* @__PURE__ */ B.jsxs(
    a,
    {
      className: im({ className: r, level: e }),
      ref: u ? i : void 0,
      id: n,
      children: [
        n && /* @__PURE__ */ B.jsx(
          "a",
          {
            href: `#${n}`,
            className: "before:content-['#'] no-underline absolute text-primary -left-[0.8em] pr-2.5 opacity-0 group-hover:opacity-50 hover:!opacity-100 transition-opacity duration-200",
            "aria-label": `Link to ${n}`,
            children: "â"
          }
        ),
        t
      ]
    }
  );
}, sm = ({
  asChild: e,
  onClick: t,
  enabled: n = !0,
  ...r
}) => {
  const u = e ? po : "span";
  return /* @__PURE__ */ B.jsx(
    u,
    {
      onClick: (a) => {
        if (n) {
          const i = document.createRange();
          i.selectNodeContents(a.currentTarget);
          const o = window.getSelection();
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        t == null || t(a);
      },
      ...r
    }
  );
}, om = ({
  className: e,
  children: t,
  selectOnClick: n,
  onClick: r
}) => /* @__PURE__ */ B.jsx(sm, { asChild: !0, enabled: n, onClick: r, children: /* @__PURE__ */ B.jsx(
  "code",
  {
    className: vt(
      "font-mono border p-1 py-0.5 rounded bg-border/50 dark:bg-border/70 [overflow-wrap:anywhere]",
      e
    ),
    children: t
  }
) }), lm = {
  img: ({ node: e, ...t }) => /\.(mp4|webm|mov|avi)$/.test(t.src ?? "") ? /* @__PURE__ */ B.jsx("video", { src: t.src, controls: !0, playsInline: !0, autoPlay: !0, loop: !0 }) : /* @__PURE__ */ B.jsx("img", { ...t, className: "rounded-md" }),
  h1: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 1, id: t, children: e }),
  h2: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 2, id: t, children: e }),
  h3: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 3, id: t, children: e }),
  h4: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 4, id: t, children: e }),
  h5: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 5, id: t, children: e }),
  h6: ({ children: e, id: t }) => /* @__PURE__ */ B.jsx(ft, { level: 6, id: t, children: e }),
  a: ({ href: e, node: t, ...n }) => e && !e.startsWith("http") ? /* @__PURE__ */ B.jsx(Ts, { to: e, relative: "path", ...n }) : /* @__PURE__ */ B.jsx("a", { href: e, target: "_blank", ...n, rel: "noreferrer" }),
  Button: Eo,
  Callout: Ze,
  Stepper: go,
  SyntaxHighlight: hu,
  tip: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "tip", ...e }),
  info: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "info", ...e }),
  note: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "note", ...e }),
  caution: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "caution", ...e }),
  warning: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "caution", ...e }),
  danger: (e) => /* @__PURE__ */ B.jsx(Ze, { type: "danger", ...e }),
  pre: ({ children: e }) => /* @__PURE__ */ B.jsx(B.Fragment, { children: e }),
  code: ({ className: e, children: t, ...n }) => {
    const { inline: r, title: u } = n;
    if (r === !0 || r === "true")
      return /* @__PURE__ */ B.jsx(om, { className: e, children: t });
    const a = e == null ? void 0 : e.match(/language?-(\w+)/);
    return /* @__PURE__ */ B.jsx(
      hu,
      {
        language: a == null ? void 0 : a[1],
        className: "rounded-xl p-4 border dark:!bg-foreground/10 dark:border-transparent",
        showLanguageIndicator: !0,
        code: String(t).trim(),
        title: typeof u == "string" ? u : void 0
      }
    );
  }
}, cm = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, fm = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, hm = {};
function ri(e, t) {
  return (hm.jsx ? fm : cm).test(e);
}
const dm = /[ \t\n\f\r]/g;
function mm(e) {
  return typeof e == "object" ? e.type === "text" ? ui(e.value) : !1 : ui(e);
}
function ui(e) {
  return e.replace(dm, "") === "";
}
class an {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
an.prototype.normal = {};
an.prototype.property = {};
an.prototype.space = void 0;
function bs(e, t) {
  const n = {}, r = {};
  for (const u of e)
    Object.assign(n, u.property), Object.assign(r, u.normal);
  return new an(n, r, t);
}
function _r(e) {
  return e.toLowerCase();
}
class Ae {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Ae.prototype.attribute = "";
Ae.prototype.booleanish = !1;
Ae.prototype.boolean = !1;
Ae.prototype.commaOrSpaceSeparated = !1;
Ae.prototype.commaSeparated = !1;
Ae.prototype.defined = !1;
Ae.prototype.mustUseProperty = !1;
Ae.prototype.number = !1;
Ae.prototype.overloadedBoolean = !1;
Ae.prototype.property = "";
Ae.prototype.spaceSeparated = !1;
Ae.prototype.space = void 0;
let pm = 0;
const G = st(), oe = st(), As = st(), w = st(), ue = st(), gt = st(), Se = st();
function st() {
  return 2 ** ++pm;
}
const Cr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: G,
  booleanish: oe,
  commaOrSpaceSeparated: Se,
  commaSeparated: gt,
  number: w,
  overloadedBoolean: As,
  spaceSeparated: ue
}, Symbol.toStringTag, { value: "Module" })), Kn = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Cr)
);
class Gr extends Ae {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, u) {
    let a = -1;
    if (super(t, n), ii(this, "space", u), typeof r == "number")
      for (; ++a < Kn.length; ) {
        const i = Kn[a];
        ii(this, Kn[a], (r & Cr[i]) === Cr[i]);
      }
  }
}
Gr.prototype.defined = !0;
function ii(e, t, n) {
  n && (e[t] = n);
}
function yt(e) {
  const t = {}, n = {};
  for (const [r, u] of Object.entries(e.properties)) {
    const a = new Gr(
      r,
      e.transform(e.attributes || {}, r),
      u,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[_r(r)] = r, n[_r(a.attribute)] = r;
  }
  return new an(t, n, e.space);
}
const _s = yt({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: oe,
    ariaAutoComplete: null,
    ariaBusy: oe,
    ariaChecked: oe,
    ariaColCount: w,
    ariaColIndex: w,
    ariaColSpan: w,
    ariaControls: ue,
    ariaCurrent: null,
    ariaDescribedBy: ue,
    ariaDetails: null,
    ariaDisabled: oe,
    ariaDropEffect: ue,
    ariaErrorMessage: null,
    ariaExpanded: oe,
    ariaFlowTo: ue,
    ariaGrabbed: oe,
    ariaHasPopup: null,
    ariaHidden: oe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: ue,
    ariaLevel: w,
    ariaLive: null,
    ariaModal: oe,
    ariaMultiLine: oe,
    ariaMultiSelectable: oe,
    ariaOrientation: null,
    ariaOwns: ue,
    ariaPlaceholder: null,
    ariaPosInSet: w,
    ariaPressed: oe,
    ariaReadOnly: oe,
    ariaRelevant: null,
    ariaRequired: oe,
    ariaRoleDescription: ue,
    ariaRowCount: w,
    ariaRowIndex: w,
    ariaRowSpan: w,
    ariaSelected: oe,
    ariaSetSize: w,
    ariaSort: null,
    ariaValueMax: w,
    ariaValueMin: w,
    ariaValueNow: w,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function Cs(e, t) {
  return t in e ? e[t] : t;
}
function Ss(e, t) {
  return Cs(e, t.toLowerCase());
}
const Em = yt({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: gt,
    acceptCharset: ue,
    accessKey: ue,
    action: null,
    allow: null,
    allowFullScreen: G,
    allowPaymentRequest: G,
    allowUserMedia: G,
    alt: null,
    as: null,
    async: G,
    autoCapitalize: null,
    autoComplete: ue,
    autoFocus: G,
    autoPlay: G,
    blocking: ue,
    capture: null,
    charSet: null,
    checked: G,
    cite: null,
    className: ue,
    cols: w,
    colSpan: null,
    content: null,
    contentEditable: oe,
    controls: G,
    controlsList: ue,
    coords: w | gt,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: G,
    defer: G,
    dir: null,
    dirName: null,
    disabled: G,
    download: As,
    draggable: oe,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: G,
    formTarget: null,
    headers: ue,
    height: w,
    hidden: G,
    high: w,
    href: null,
    hrefLang: null,
    htmlFor: ue,
    httpEquiv: ue,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: G,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: G,
    itemId: null,
    itemProp: ue,
    itemRef: ue,
    itemScope: G,
    itemType: ue,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: G,
    low: w,
    manifest: null,
    max: null,
    maxLength: w,
    media: null,
    method: null,
    min: null,
    minLength: w,
    multiple: G,
    muted: G,
    name: null,
    nonce: null,
    noModule: G,
    noValidate: G,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: G,
    optimum: w,
    pattern: null,
    ping: ue,
    placeholder: null,
    playsInline: G,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: G,
    referrerPolicy: null,
    rel: ue,
    required: G,
    reversed: G,
    rows: w,
    rowSpan: w,
    sandbox: ue,
    scope: null,
    scoped: G,
    seamless: G,
    selected: G,
    shadowRootClonable: G,
    shadowRootDelegatesFocus: G,
    shadowRootMode: null,
    shape: null,
    size: w,
    sizes: null,
    slot: null,
    span: w,
    spellCheck: oe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: w,
    step: null,
    style: null,
    tabIndex: w,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: G,
    useMap: null,
    value: oe,
    width: w,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: ue,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: w,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: w,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: G,
    // Lists. Use CSS to reduce space between items instead
    declare: G,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: w,
    // `<img>` and `<object>`
    leftMargin: w,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: w,
    // `<body>`
    marginWidth: w,
    // `<body>`
    noResize: G,
    // `<frame>`
    noHref: G,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: G,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: G,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: w,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: oe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: w,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: w,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: G,
    disableRemotePlayback: G,
    prefix: null,
    property: null,
    results: w,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Ss
}), gm = yt({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Se,
    accentHeight: w,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: w,
    amplitude: w,
    arabicForm: null,
    ascent: w,
    attributeName: null,
    attributeType: null,
    azimuth: w,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: w,
    by: null,
    calcMode: null,
    capHeight: w,
    className: ue,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: w,
    diffuseConstant: w,
    direction: null,
    display: null,
    dur: null,
    divisor: w,
    dominantBaseline: null,
    download: G,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: w,
    enableBackground: null,
    end: null,
    event: null,
    exponent: w,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: w,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: gt,
    g2: gt,
    glyphName: gt,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: w,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: w,
    horizOriginX: w,
    horizOriginY: w,
    id: null,
    ideographic: w,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: w,
    k: w,
    k1: w,
    k2: w,
    k3: w,
    k4: w,
    kernelMatrix: Se,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: w,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: w,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: w,
    overlineThickness: w,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: w,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: ue,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: w,
    pointsAtY: w,
    pointsAtZ: w,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Se,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Se,
    rev: Se,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Se,
    requiredFeatures: Se,
    requiredFonts: Se,
    requiredFormats: Se,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: w,
    specularExponent: w,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: w,
    strikethroughThickness: w,
    string: null,
    stroke: null,
    strokeDashArray: Se,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: w,
    strokeOpacity: w,
    strokeWidth: null,
    style: null,
    surfaceScale: w,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Se,
    tabIndex: w,
    tableValues: null,
    target: null,
    targetX: w,
    targetY: w,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Se,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: w,
    underlineThickness: w,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: w,
    values: null,
    vAlphabetic: w,
    vMathematical: w,
    vectorEffect: null,
    vHanging: w,
    vIdeographic: w,
    version: null,
    vertAdvY: w,
    vertOriginX: w,
    vertOriginY: w,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: w,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Cs
}), xs = yt({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), Is = yt({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Ss
}), ks = yt({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Tm = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, bm = /[A-Z]/g, ai = /-[a-z]/g, Am = /^data[-\w.:]+$/i;
function _m(e, t) {
  const n = _r(t);
  let r = t, u = Ae;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Am.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(ai, Sm);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!ai.test(a)) {
        let i = a.replace(bm, Cm);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    u = Gr;
  }
  return new u(r, t);
}
function Cm(e) {
  return "-" + e.toLowerCase();
}
function Sm(e) {
  return e.charAt(1).toUpperCase();
}
const xm = bs([_s, Em, xs, Is, ks], "html"), Qr = bs([_s, gm, xs, Is, ks], "svg");
var ht = {}, Jn, si;
function Im() {
  if (si) return Jn;
  si = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, u = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, i = /^[;\s]*/, o = /^\s+|\s+$/g, l = `
`, c = "/", h = "*", f = "", p = "comment", d = "declaration";
  Jn = function(C, y) {
    if (typeof C != "string")
      throw new TypeError("First argument must be a string");
    if (!C) return [];
    y = y || {};
    var S = 1, O = 1;
    function L(v) {
      var F = v.match(t);
      F && (S += F.length);
      var j = v.lastIndexOf(l);
      O = ~j ? v.length - j : O + v.length;
    }
    function Y() {
      var v = { line: S, column: O };
      return function(F) {
        return F.position = new q(v), Z(), F;
      };
    }
    function q(v) {
      this.start = v, this.end = { line: S, column: O }, this.source = y.source;
    }
    q.prototype.content = C;
    function k(v) {
      var F = new Error(
        y.source + ":" + S + ":" + O + ": " + v
      );
      if (F.reason = v, F.filename = y.source, F.line = S, F.column = O, F.source = C, !y.silent) throw F;
    }
    function Q(v) {
      var F = v.exec(C);
      if (F) {
        var j = F[0];
        return L(j), C = C.slice(j.length), F;
      }
    }
    function Z() {
      Q(n);
    }
    function ee(v) {
      var F;
      for (v = v || []; F = I(); )
        F !== !1 && v.push(F);
      return v;
    }
    function I() {
      var v = Y();
      if (!(c != C.charAt(0) || h != C.charAt(1))) {
        for (var F = 2; f != C.charAt(F) && (h != C.charAt(F) || c != C.charAt(F + 1)); )
          ++F;
        if (F += 2, f === C.charAt(F - 1))
          return k("End of comment missing");
        var j = C.slice(2, F - 2);
        return O += 2, L(j), C = C.slice(F), O += 2, v({
          type: p,
          comment: j
        });
      }
    }
    function H() {
      var v = Y(), F = Q(r);
      if (F) {
        if (I(), !Q(u)) return k("property missing ':'");
        var j = Q(a), le = v({
          type: d,
          property: A(F[0].replace(e, f)),
          value: j ? A(j[0].replace(e, f)) : f
        });
        return Q(i), le;
      }
    }
    function U() {
      var v = [];
      ee(v);
      for (var F; F = H(); )
        F !== !1 && (v.push(F), ee(v));
      return v;
    }
    return Z(), U();
  };
  function A(C) {
    return C ? C.replace(o, f) : f;
  }
  return Jn;
}
var oi;
function km() {
  if (oi) return ht;
  oi = 1;
  var e = ht && ht.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(ht, "__esModule", { value: !0 }), ht.default = n;
  var t = e(Im());
  function n(r, u) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var i = (0, t.default)(r), o = typeof u == "function";
    return i.forEach(function(l) {
      if (l.type === "declaration") {
        var c = l.property, h = l.value;
        o ? u(c, h, l) : h && (a = a || {}, a[c] = h);
      }
    }), a;
  }
  return ht;
}
var Mt = {}, li;
function ym() {
  if (li) return Mt;
  li = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, u = /^-(ms)-/, a = function(c) {
    return !c || n.test(c) || e.test(c);
  }, i = function(c, h) {
    return h.toUpperCase();
  }, o = function(c, h) {
    return "".concat(h, "-");
  }, l = function(c, h) {
    return h === void 0 && (h = {}), a(c) ? c : (c = c.toLowerCase(), h.reactCompat ? c = c.replace(u, o) : c = c.replace(r, o), c.replace(t, i));
  };
  return Mt.camelCase = l, Mt;
}
var Bt, ci;
function Nm() {
  if (ci) return Bt;
  ci = 1;
  var e = Bt && Bt.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  }, t = e(km()), n = ym();
  function r(u, a) {
    var i = {};
    return !u || typeof u != "string" || (0, t.default)(u, function(o, l) {
      o && l && (i[(0, n.camelCase)(o, a)] = l);
    }), i;
  }
  return r.default = r, Bt = r, Bt;
}
var Om = Nm();
const Lm = /* @__PURE__ */ zi(Om);
function Gt(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? fi(e.position) : "start" in e || "end" in e ? fi(e) : "line" in e || "column" in e ? Sr(e) : "";
}
function Sr(e) {
  return hi(e && e.line) + ":" + hi(e && e.column);
}
function fi(e) {
  return Sr(e && e.start) + "-" + Sr(e && e.end);
}
function hi(e) {
  return e && typeof e == "number" ? e : 1;
}
class Ee extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ðª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let u = "", a = {}, i = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? u = t : !a.cause && t && (i = !0, u = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? a.ruleId = r : (a.source = r.slice(0, l), a.ruleId = r.slice(l + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const l = a.ancestors[a.ancestors.length - 1];
      l && (a.place = l.position);
    }
    const o = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = u, this.line = o ? o.line : void 0, this.name = Gt(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = i && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Ee.prototype.file = "";
Ee.prototype.name = "";
Ee.prototype.reason = "";
Ee.prototype.message = "";
Ee.prototype.stack = "";
Ee.prototype.column = void 0;
Ee.prototype.line = void 0;
Ee.prototype.ancestors = void 0;
Ee.prototype.cause = void 0;
Ee.prototype.fatal = void 0;
Ee.prototype.place = void 0;
Ee.prototype.ruleId = void 0;
Ee.prototype.source = void 0;
const $r = {}.hasOwnProperty, Rm = /* @__PURE__ */ new Map(), Dm = /[A-Z]/g, Pm = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), wm = /* @__PURE__ */ new Set(["td", "th"]), ys = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Mm(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = qm(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = Ym(n, t.jsx, t.jsxs);
  }
  const u = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Qr : xm,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = Ns(u, e, void 0);
  return a && typeof a != "string" ? a : u.create(
    e,
    u.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function Ns(e, t, n) {
  if (t.type === "element")
    return Bm(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Fm(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Um(e, t, n);
  if (t.type === "mdxjsEsm")
    return Hm(e, t);
  if (t.type === "root")
    return vm(e, t, n);
  if (t.type === "text")
    return zm(e, t);
}
function Bm(e, t, n) {
  const r = e.schema;
  let u = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (u = Qr, e.schema = u), e.ancestors.push(t);
  const a = Ls(e, t.tagName, !1), i = jm(e, t);
  let o = Kr(e, t);
  return Pm.has(t.tagName) && (o = o.filter(function(l) {
    return typeof l == "string" ? !mm(l) : !0;
  })), Os(e, i, a, t), Xr(i, o), e.ancestors.pop(), e.schema = r, e.create(t, a, i, n);
}
function Fm(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Jt(e, t.position);
}
function Hm(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Jt(e, t.position);
}
function Um(e, t, n) {
  const r = e.schema;
  let u = r;
  t.name === "svg" && r.space === "html" && (u = Qr, e.schema = u), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : Ls(e, t.name, !0), i = Vm(e, t), o = Kr(e, t);
  return Os(e, i, a, t), Xr(i, o), e.ancestors.pop(), e.schema = r, e.create(t, a, i, n);
}
function vm(e, t, n) {
  const r = {};
  return Xr(r, Kr(e, t)), e.create(t, e.Fragment, r, n);
}
function zm(e, t) {
  return t.value;
}
function Os(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function Xr(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function Ym(e, t, n) {
  return r;
  function r(u, a, i, o) {
    const c = Array.isArray(i.children) ? n : t;
    return o ? c(a, i, o) : c(a, i);
  }
}
function qm(e, t) {
  return n;
  function n(r, u, a, i) {
    const o = Array.isArray(a.children), l = Me(r);
    return t(
      u,
      a,
      i,
      o,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function jm(e, t) {
  const n = {};
  let r, u;
  for (u in t.properties)
    if (u !== "children" && $r.call(t.properties, u)) {
      const a = Wm(e, u, t.properties[u]);
      if (a) {
        const [i, o] = a;
        e.tableCellAlignToStyle && i === "align" && typeof o == "string" && wm.has(t.tagName) ? r = o : n[i] = o;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Vm(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const i = a.expression;
        i.type;
        const o = i.properties[0];
        o.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        Jt(e, t.position);
    else {
      const u = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, a = e.evaluater.evaluateExpression(o.expression);
        } else
          Jt(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[u] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function Kr(e, t) {
  const n = [];
  let r = -1;
  const u = e.passKeys ? /* @__PURE__ */ new Map() : Rm;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let i;
    if (e.passKeys) {
      const l = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (l) {
        const c = u.get(l) || 0;
        i = l + "-" + c, u.set(l, c + 1);
      }
    }
    const o = Ns(e, a, i);
    o !== void 0 && n.push(o);
  }
  return n;
}
function Wm(e, t, n) {
  const r = _m(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Zi(n) : ea(n)), r.property === "style") {
      let u = typeof n == "object" ? n : Gm(e, String(n));
      return e.stylePropertyNameCase === "css" && (u = Qm(u)), ["style", u];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? Tm[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function Gm(e, t) {
  try {
    return Lm(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), u = new Ee("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw u.file = e.filePath || void 0, u.url = ys + "#cannot-parse-style-attribute", u;
  }
}
function Ls(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const u = t.split(".");
    let a = -1, i;
    for (; ++a < u.length; ) {
      const o = ri(u[a]) ? { type: "Identifier", name: u[a] } : { type: "Literal", value: u[a] };
      i = i ? {
        type: "MemberExpression",
        object: i,
        property: o,
        computed: !!(a && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = i;
  } else
    r = ri(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const u = (
      /** @type {string | number} */
      r.value
    );
    return $r.call(e.components, u) ? e.components[u] : u;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Jt(e);
}
function Jt(e, t) {
  const n = new Ee(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = ys + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Qm(e) {
  const t = {};
  let n;
  for (n in e)
    $r.call(e, n) && (t[$m(n)] = e[n]);
  return t;
}
function $m(e) {
  let t = e.replace(Dm, Xm);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Xm(e) {
  return "-" + e.toLowerCase();
}
const Zn = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, di = typeof document < "u" && document.createElement("i");
function Jr(e) {
  const t = "&" + e + ";";
  di.innerHTML = t;
  const n = di.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function we(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
function Ie(e, t) {
  return e.length > 0 ? (we(e, e.length, 0, t), e) : t;
}
const mi = {}.hasOwnProperty;
function Km(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Jm(t, e[n]);
  return t;
}
function Jm(e, t) {
  let n;
  for (n in t) {
    const u = (mi.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        mi.call(u, i) || (u[i] = []);
        const o = a[i];
        Zm(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function Zm(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  we(e, 0, 0, r);
}
function Rs(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "ï¿½" : String.fromCodePoint(n)
  );
}
function Tt(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const ep = {
  tokenize: tp
};
function tp(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    u
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), J(e, t, "linePrefix");
  }
  function u(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return z(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), i);
  }
}
const np = {
  tokenize: rp
}, pi = {
  tokenize: up
};
function rp(e) {
  const t = this, n = [];
  let r = 0, u, a, i;
  return o;
  function o(L) {
    if (r < n.length) {
      const Y = n[r];
      return t.containerState = Y[1], e.attempt(
        Y[0].continuation,
        l,
        c
      )(L);
    }
    return c(L);
  }
  function l(L) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, u && O();
      const Y = t.events.length;
      let q = Y, k;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          k = t.events[q][1].end;
          break;
        }
      S(r);
      let Q = Y;
      for (; Q < t.events.length; )
        t.events[Q][1].end = Object.assign({}, k), Q++;
      return we(
        t.events,
        q + 1,
        0,
        t.events.slice(Y)
      ), t.events.length = Q, c(L);
    }
    return o(L);
  }
  function c(L) {
    if (r === n.length) {
      if (!u)
        return p(L);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return A(L);
      t.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      pi,
      h,
      f
    )(L);
  }
  function h(L) {
    return u && O(), S(r), p(L);
  }
  function f(L) {
    return t.parser.lazy[t.now().line] = r !== n.length, i = t.now().offset, A(L);
  }
  function p(L) {
    return t.containerState = {}, e.attempt(
      pi,
      d,
      A
    )(L);
  }
  function d(L) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(L);
  }
  function A(L) {
    if (L === null) {
      u && O(), S(0), e.consume(L);
      return;
    }
    return u = u || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), C(L);
  }
  function C(L) {
    if (L === null) {
      y(e.exit("chunkFlow"), !0), S(0), e.consume(L);
      return;
    }
    return z(L) ? (e.consume(L), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(L), C);
  }
  function y(L, Y) {
    const q = t.sliceStream(L);
    if (Y && q.push(null), L.previous = a, a && (a.next = L), a = L, u.defineSkip(L.start), u.write(q), t.parser.lazy[L.start.line]) {
      let k = u.events.length;
      for (; k--; )
        if (
          // The token starts before the line endingâ¦
          u.events[k][1].start.offset < i && // â¦and either is not ended yetâ¦
          (!u.events[k][1].end || // â¦or ends after it.
          u.events[k][1].end.offset > i)
        )
          return;
      const Q = t.events.length;
      let Z = Q, ee, I;
      for (; Z--; )
        if (t.events[Z][0] === "exit" && t.events[Z][1].type === "chunkFlow") {
          if (ee) {
            I = t.events[Z][1].end;
            break;
          }
          ee = !0;
        }
      for (S(r), k = Q; k < t.events.length; )
        t.events[k][1].end = Object.assign({}, I), k++;
      we(
        t.events,
        Z + 1,
        0,
        t.events.slice(Q)
      ), t.events.length = k;
    }
  }
  function S(L) {
    let Y = n.length;
    for (; Y-- > L; ) {
      const q = n[Y];
      t.containerState = q[1], q[0].exit.call(t, e);
    }
    n.length = L;
  }
  function O() {
    u.write([null]), a = void 0, u = void 0, t.containerState._closeFlow = void 0;
  }
}
function up(e, t, n) {
  return J(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function Zr(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const xr = {
  name: "attention",
  tokenize: ap,
  resolveAll: ip
};
function ip(e, t) {
  let n = -1, r, u, a, i, o, l, c, h;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Ei(f, -l), Ei(p, l), i = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, u = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, i.start), e[n][1].start = Object.assign({}, o.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = Ie(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), c = Ie(c, [
            ["enter", u, t],
            ["enter", i, t],
            ["exit", i, t],
            ["enter", a, t]
          ]), c = Ie(
            c,
            Zr(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), c = Ie(c, [
            ["exit", a, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", u, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (h = 2, c = Ie(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : h = 0, we(e, r - 1, n - r + 3, c), n = r + c.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function ap(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, u = _t(r);
  let a;
  return i;
  function i(l) {
    return a = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === a)
      return e.consume(l), o;
    const c = e.exit("attentionSequence"), h = _t(l), f = !h || h === 2 && u || n.includes(l), p = !u || u === 2 && h || n.includes(r);
    return c._open = !!(a === 42 ? f : f && (u || !p)), c._close = !!(a === 42 ? p : p && (h || !f)), t(l);
  }
}
function Ei(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const sp = {
  name: "autolink",
  tokenize: op
};
function op(e, t, n) {
  let r = 0;
  return u;
  function u(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(d) {
    return ge(d) ? (e.consume(d), i) : c(d);
  }
  function i(d) {
    return d === 43 || d === 45 || d === 46 || me(d) ? (r = 1, o(d)) : c(d);
  }
  function o(d) {
    return d === 58 ? (e.consume(d), r = 0, l) : (d === 43 || d === 45 || d === 46 || me(d)) && r++ < 32 ? (e.consume(d), o) : (r = 0, c(d));
  }
  function l(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : d === null || d === 32 || d === 60 || In(d) ? n(d) : (e.consume(d), l);
  }
  function c(d) {
    return d === 64 ? (e.consume(d), h) : J0(d) ? (e.consume(d), c) : n(d);
  }
  function h(d) {
    return me(d) ? f(d) : n(d);
  }
  function f(d) {
    return d === 46 ? (e.consume(d), r = 0, h) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(d);
  }
  function p(d) {
    if ((d === 45 || me(d)) && r++ < 63) {
      const A = d === 45 ? p : f;
      return e.consume(d), A;
    }
    return n(d);
  }
}
const Un = {
  tokenize: lp,
  partial: !0
};
function lp(e, t, n) {
  return r;
  function r(a) {
    return X(a) ? J(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? t(a) : n(a);
  }
}
const Ds = {
  name: "blockQuote",
  tokenize: cp,
  continuation: {
    tokenize: fp
  },
  exit: hp
};
function cp(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    if (i === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), a;
    }
    return n(i);
  }
  function a(i) {
    return X(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function fp(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return X(i) ? J(
      e,
      a,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i) : a(i);
  }
  function a(i) {
    return e.attempt(Ds, t, n)(i);
  }
}
function hp(e) {
  e.exit("blockQuote");
}
const Ps = {
  name: "characterEscape",
  tokenize: dp
};
function dp(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), u;
  }
  function u(a) {
    return ef(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const ws = {
  name: "characterReference",
  tokenize: mp
};
function mp(e, t, n) {
  const r = this;
  let u = 0, a, i;
  return o;
  function o(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, i = me, h(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, i = Z0, h) : (e.enter("characterReferenceValue"), a = 7, i = br, h(f));
  }
  function h(f) {
    if (f === 59 && u) {
      const p = e.exit("characterReferenceValue");
      return i === me && !Jr(r.sliceSerialize(p)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(f) && u++ < a ? (e.consume(f), h) : n(f);
  }
}
const gi = {
  tokenize: Ep,
  partial: !0
}, Ti = {
  name: "codeFenced",
  tokenize: pp,
  concrete: !0
};
function pp(e, t, n) {
  const r = this, u = {
    tokenize: q,
    partial: !0
  };
  let a = 0, i = 0, o;
  return l;
  function l(k) {
    return c(k);
  }
  function c(k) {
    const Q = r.events[r.events.length - 1];
    return a = Q && Q[1].type === "linePrefix" ? Q[2].sliceSerialize(Q[1], !0).length : 0, o = k, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), h(k);
  }
  function h(k) {
    return k === o ? (i++, e.consume(k), h) : i < 3 ? n(k) : (e.exit("codeFencedFenceSequence"), X(k) ? J(e, f, "whitespace")(k) : f(k));
  }
  function f(k) {
    return k === null || z(k) ? (e.exit("codeFencedFence"), r.interrupt ? t(k) : e.check(gi, C, Y)(k)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(k));
  }
  function p(k) {
    return k === null || z(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(k)) : X(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), J(e, d, "whitespace")(k)) : k === 96 && k === o ? n(k) : (e.consume(k), p);
  }
  function d(k) {
    return k === null || z(k) ? f(k) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), A(k));
  }
  function A(k) {
    return k === null || z(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(k)) : k === 96 && k === o ? n(k) : (e.consume(k), A);
  }
  function C(k) {
    return e.attempt(u, Y, y)(k);
  }
  function y(k) {
    return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), S;
  }
  function S(k) {
    return a > 0 && X(k) ? J(
      e,
      O,
      "linePrefix",
      a + 1
    )(k) : O(k);
  }
  function O(k) {
    return k === null || z(k) ? e.check(gi, C, Y)(k) : (e.enter("codeFlowValue"), L(k));
  }
  function L(k) {
    return k === null || z(k) ? (e.exit("codeFlowValue"), O(k)) : (e.consume(k), L);
  }
  function Y(k) {
    return e.exit("codeFenced"), t(k);
  }
  function q(k, Q, Z) {
    let ee = 0;
    return I;
    function I(j) {
      return k.enter("lineEnding"), k.consume(j), k.exit("lineEnding"), H;
    }
    function H(j) {
      return k.enter("codeFencedFence"), X(j) ? J(
        k,
        U,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(j) : U(j);
    }
    function U(j) {
      return j === o ? (k.enter("codeFencedFenceSequence"), v(j)) : Z(j);
    }
    function v(j) {
      return j === o ? (ee++, k.consume(j), v) : ee >= i ? (k.exit("codeFencedFenceSequence"), X(j) ? J(k, F, "whitespace")(j) : F(j)) : Z(j);
    }
    function F(j) {
      return j === null || z(j) ? (k.exit("codeFencedFence"), Q(j)) : Z(j);
    }
  }
}
function Ep(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i === null ? n(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
const er = {
  name: "codeIndented",
  tokenize: Tp
}, gp = {
  tokenize: bp,
  partial: !0
};
function Tp(e, t, n) {
  const r = this;
  return u;
  function u(c) {
    return e.enter("codeIndented"), J(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const h = r.events[r.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], !0).length >= 4 ? i(c) : n(c);
  }
  function i(c) {
    return c === null ? l(c) : z(c) ? e.attempt(gp, i, l)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || z(c) ? (e.exit("codeFlowValue"), i(c)) : (e.consume(c), o);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function bp(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return r.parser.lazy[r.now().line] ? n(i) : z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), u) : J(e, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : z(i) ? u(i) : n(i);
  }
}
const Ap = {
  name: "codeText",
  tokenize: Sp,
  resolve: _p,
  previous: Cp
};
function _p(e) {
  let t = e.length - 4, n = 3, r, u;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    u === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (u = r) : (r === t || e[r][1].type === "lineEnding") && (e[u][1].type = "codeTextData", r !== u + 2 && (e[u][1].end = e[r - 1][1].end, e.splice(u + 2, r - u - 2), t -= r - u - 2, r = u + 2), u = void 0);
  return e;
}
function Cp(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Sp(e, t, n) {
  let r = 0, u, a;
  return i;
  function i(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(f);
  }
  function o(f) {
    return f === 96 ? (e.consume(f), r++, o) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (a = e.enter("codeTextSequence"), u = 0, h(f)) : z(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || z(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), c);
  }
  function h(f) {
    return f === 96 ? (e.consume(f), u++, h) : u === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", c(f));
  }
}
function Ms(e) {
  const t = {};
  let n = -1, r, u, a, i, o, l, c;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, xp(e, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, u = void 0; a-- && (i = e[a], i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (e[u][1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r[1].end = Object.assign({}, e[u][1].start), o = e.slice(u, n), o.unshift(r), we(e, u, n - u + 1, o));
    }
  }
  return !c;
}
function xp(e, t) {
  const n = e[t][1], r = e[t][2];
  let u = t - 1;
  const a = [], i = n._tokenizer || r.parser[n.contentType](n.start), o = i.events, l = [], c = {};
  let h, f, p = -1, d = n, A = 0, C = 0;
  const y = [C];
  for (; d; ) {
    for (; e[++u][1] !== d; )
      ;
    a.push(u), d._tokenizer || (h = r.sliceStream(d), d.next || h.push(null), f && i.defineSkip(d.start), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(h), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = n; ++p < o.length; )
    // Find a void token that includes a break.
    o[p][0] === "exit" && o[p - 1][0] === "enter" && o[p][1].type === o[p - 1][1].type && o[p][1].start.line !== o[p][1].end.line && (C = p + 1, y.push(C), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (i.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : y.pop(), p = y.length; p--; ) {
    const S = o.slice(y[p], y[p + 1]), O = a.pop();
    l.unshift([O, O + S.length - 1]), we(e, O, 2, S);
  }
  for (p = -1; ++p < l.length; )
    c[A + l[p][0]] = A + l[p][1], A += l[p][1] - l[p][0] - 1;
  return c;
}
const Ip = {
  tokenize: Np,
  resolve: yp
}, kp = {
  tokenize: Op,
  partial: !0
};
function yp(e) {
  return Ms(e), e;
}
function Np(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), u(o);
  }
  function u(o) {
    return o === null ? a(o) : z(o) ? e.check(
      kp,
      i,
      a
    )(o) : (e.consume(o), u);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, u;
  }
}
function Op(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), J(e, a, "linePrefix");
  }
  function a(i) {
    if (i === null || z(i))
      return n(i);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i);
  }
}
function Bs(e, t, n, r, u, a, i, o, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let h = 0;
  return f;
  function f(S) {
    return S === 60 ? (e.enter(r), e.enter(u), e.enter(a), e.consume(S), e.exit(a), p) : S === null || S === 32 || S === 41 || In(S) ? n(S) : (e.enter(r), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), C(S));
  }
  function p(S) {
    return S === 62 ? (e.enter(a), e.consume(S), e.exit(a), e.exit(u), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), d(S));
  }
  function d(S) {
    return S === 62 ? (e.exit("chunkString"), e.exit(o), p(S)) : S === null || S === 60 || z(S) ? n(S) : (e.consume(S), S === 92 ? A : d);
  }
  function A(S) {
    return S === 60 || S === 62 || S === 92 ? (e.consume(S), d) : d(S);
  }
  function C(S) {
    return !h && (S === null || S === 41 || ne(S)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(r), t(S)) : h < c && S === 40 ? (e.consume(S), h++, C) : S === 41 ? (e.consume(S), h--, C) : S === null || S === 32 || S === 40 || In(S) ? n(S) : (e.consume(S), S === 92 ? y : C);
  }
  function y(S) {
    return S === 40 || S === 41 || S === 92 ? (e.consume(S), C) : C(S);
  }
}
function Fs(e, t, n, r, u, a) {
  const i = this;
  let o = 0, l;
  return c;
  function c(d) {
    return e.enter(r), e.enter(u), e.consume(d), e.exit(u), e.enter(a), h;
  }
  function h(d) {
    return o > 999 || d === null || d === 91 || d === 93 && !l || // To do: remove in the future once weâve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnât need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? n(d) : d === 93 ? (e.exit(a), e.enter(u), e.consume(d), e.exit(u), e.exit(r), t) : z(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), h) : (e.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || z(d) || o++ > 999 ? (e.exit("chunkString"), h(d)) : (e.consume(d), l || (l = !X(d)), d === 92 ? p : f);
  }
  function p(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), o++, f) : f(d);
  }
}
function Hs(e, t, n, r, u, a) {
  let i;
  return o;
  function o(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(u), e.consume(p), e.exit(u), i = p === 40 ? 41 : p, l) : n(p);
  }
  function l(p) {
    return p === i ? (e.enter(u), e.consume(p), e.exit(u), e.exit(r), t) : (e.enter(a), c(p));
  }
  function c(p) {
    return p === i ? (e.exit(a), l(i)) : p === null ? n(p) : z(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), J(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), h(p));
  }
  function h(p) {
    return p === i || p === null || z(p) ? (e.exit("chunkString"), c(p)) : (e.consume(p), p === 92 ? f : h);
  }
  function f(p) {
    return p === i || p === 92 ? (e.consume(p), h) : h(p);
  }
}
const Lp = {
  name: "definition",
  tokenize: Dp
}, Rp = {
  tokenize: Pp,
  partial: !0
};
function Dp(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(d) {
    return e.enter("definition"), i(d);
  }
  function i(d) {
    return Fs.call(
      r,
      e,
      o,
      // Note: we donât need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function o(d) {
    return u = Tt(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), l) : n(d);
  }
  function l(d) {
    return ne(d) ? Wt(e, c)(d) : c(d);
  }
  function c(d) {
    return Bs(
      e,
      h,
      // Note: we donât need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function h(d) {
    return e.attempt(Rp, f, f)(d);
  }
  function f(d) {
    return X(d) ? J(e, p, "whitespace")(d) : p(d);
  }
  function p(d) {
    return d === null || z(d) ? (e.exit("definition"), r.parser.defined.push(u), t(d)) : n(d);
  }
}
function Pp(e, t, n) {
  return r;
  function r(o) {
    return ne(o) ? Wt(e, u)(o) : n(o);
  }
  function u(o) {
    return Hs(
      e,
      a,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function a(o) {
    return X(o) ? J(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || z(o) ? t(o) : n(o);
  }
}
const wp = {
  name: "hardBreakEscape",
  tokenize: Mp
};
function Mp(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), u;
  }
  function u(a) {
    return z(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Bp = {
  name: "headingAtx",
  tokenize: Hp,
  resolve: Fp
};
function Fp(e, t) {
  let n = e.length - 2, r = 3, u, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (u = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, we(e, r, n - r + 1, [
    ["enter", u, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", u, t]
  ])), e;
}
function Hp(e, t, n) {
  let r = 0;
  return u;
  function u(h) {
    return e.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e.enter("atxHeadingSequence"), i(h);
  }
  function i(h) {
    return h === 35 && r++ < 6 ? (e.consume(h), i) : h === null || ne(h) ? (e.exit("atxHeadingSequence"), o(h)) : n(h);
  }
  function o(h) {
    return h === 35 ? (e.enter("atxHeadingSequence"), l(h)) : h === null || z(h) ? (e.exit("atxHeading"), t(h)) : X(h) ? J(e, o, "whitespace")(h) : (e.enter("atxHeadingText"), c(h));
  }
  function l(h) {
    return h === 35 ? (e.consume(h), l) : (e.exit("atxHeadingSequence"), o(h));
  }
  function c(h) {
    return h === null || h === 35 || ne(h) ? (e.exit("atxHeadingText"), o(h)) : (e.consume(h), c);
  }
}
const Up = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], bi = ["pre", "script", "style", "textarea"], vp = {
  name: "htmlFlow",
  tokenize: jp,
  resolveTo: qp,
  concrete: !0
}, zp = {
  tokenize: Wp,
  partial: !0
}, Yp = {
  tokenize: Vp,
  partial: !0
};
function qp(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function jp(e, t, n) {
  const r = this;
  let u, a, i, o, l;
  return c;
  function c(b) {
    return h(b);
  }
  function h(b) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(b), f;
  }
  function f(b) {
    return b === 33 ? (e.consume(b), p) : b === 47 ? (e.consume(b), a = !0, C) : b === 63 ? (e.consume(b), u = 3, r.interrupt ? t : T) : ge(b) ? (e.consume(b), i = String.fromCharCode(b), y) : n(b);
  }
  function p(b) {
    return b === 45 ? (e.consume(b), u = 2, d) : b === 91 ? (e.consume(b), u = 5, o = 0, A) : ge(b) ? (e.consume(b), u = 4, r.interrupt ? t : T) : n(b);
  }
  function d(b) {
    return b === 45 ? (e.consume(b), r.interrupt ? t : T) : n(b);
  }
  function A(b) {
    const Oe = "CDATA[";
    return b === Oe.charCodeAt(o++) ? (e.consume(b), o === Oe.length ? r.interrupt ? t : U : A) : n(b);
  }
  function C(b) {
    return ge(b) ? (e.consume(b), i = String.fromCharCode(b), y) : n(b);
  }
  function y(b) {
    if (b === null || b === 47 || b === 62 || ne(b)) {
      const Oe = b === 47, Xe = i.toLowerCase();
      return !Oe && !a && bi.includes(Xe) ? (u = 1, r.interrupt ? t(b) : U(b)) : Up.includes(i.toLowerCase()) ? (u = 6, Oe ? (e.consume(b), S) : r.interrupt ? t(b) : U(b)) : (u = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(b) : a ? O(b) : L(b));
    }
    return b === 45 || me(b) ? (e.consume(b), i += String.fromCharCode(b), y) : n(b);
  }
  function S(b) {
    return b === 62 ? (e.consume(b), r.interrupt ? t : U) : n(b);
  }
  function O(b) {
    return X(b) ? (e.consume(b), O) : I(b);
  }
  function L(b) {
    return b === 47 ? (e.consume(b), I) : b === 58 || b === 95 || ge(b) ? (e.consume(b), Y) : X(b) ? (e.consume(b), L) : I(b);
  }
  function Y(b) {
    return b === 45 || b === 46 || b === 58 || b === 95 || me(b) ? (e.consume(b), Y) : q(b);
  }
  function q(b) {
    return b === 61 ? (e.consume(b), k) : X(b) ? (e.consume(b), q) : L(b);
  }
  function k(b) {
    return b === null || b === 60 || b === 61 || b === 62 || b === 96 ? n(b) : b === 34 || b === 39 ? (e.consume(b), l = b, Q) : X(b) ? (e.consume(b), k) : Z(b);
  }
  function Q(b) {
    return b === l ? (e.consume(b), l = null, ee) : b === null || z(b) ? n(b) : (e.consume(b), Q);
  }
  function Z(b) {
    return b === null || b === 34 || b === 39 || b === 47 || b === 60 || b === 61 || b === 62 || b === 96 || ne(b) ? q(b) : (e.consume(b), Z);
  }
  function ee(b) {
    return b === 47 || b === 62 || X(b) ? L(b) : n(b);
  }
  function I(b) {
    return b === 62 ? (e.consume(b), H) : n(b);
  }
  function H(b) {
    return b === null || z(b) ? U(b) : X(b) ? (e.consume(b), H) : n(b);
  }
  function U(b) {
    return b === 45 && u === 2 ? (e.consume(b), le) : b === 60 && u === 1 ? (e.consume(b), he) : b === 62 && u === 4 ? (e.consume(b), Ne) : b === 63 && u === 3 ? (e.consume(b), T) : b === 93 && u === 5 ? (e.consume(b), Fe) : z(b) && (u === 6 || u === 7) ? (e.exit("htmlFlowData"), e.check(
      zp,
      He,
      v
    )(b)) : b === null || z(b) ? (e.exit("htmlFlowData"), v(b)) : (e.consume(b), U);
  }
  function v(b) {
    return e.check(
      Yp,
      F,
      He
    )(b);
  }
  function F(b) {
    return e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), j;
  }
  function j(b) {
    return b === null || z(b) ? v(b) : (e.enter("htmlFlowData"), U(b));
  }
  function le(b) {
    return b === 45 ? (e.consume(b), T) : U(b);
  }
  function he(b) {
    return b === 47 ? (e.consume(b), i = "", ye) : U(b);
  }
  function ye(b) {
    if (b === 62) {
      const Oe = i.toLowerCase();
      return bi.includes(Oe) ? (e.consume(b), Ne) : U(b);
    }
    return ge(b) && i.length < 8 ? (e.consume(b), i += String.fromCharCode(b), ye) : U(b);
  }
  function Fe(b) {
    return b === 93 ? (e.consume(b), T) : U(b);
  }
  function T(b) {
    return b === 62 ? (e.consume(b), Ne) : b === 45 && u === 2 ? (e.consume(b), T) : U(b);
  }
  function Ne(b) {
    return b === null || z(b) ? (e.exit("htmlFlowData"), He(b)) : (e.consume(b), Ne);
  }
  function He(b) {
    return e.exit("htmlFlow"), t(b);
  }
}
function Vp(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : n(i);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
function Wp(e, t, n) {
  return r;
  function r(u) {
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), e.attempt(Un, t, n);
  }
}
const Gp = {
  name: "htmlText",
  tokenize: Qp
};
function Qp(e, t, n) {
  const r = this;
  let u, a, i;
  return o;
  function o(T) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(T), l;
  }
  function l(T) {
    return T === 33 ? (e.consume(T), c) : T === 47 ? (e.consume(T), q) : T === 63 ? (e.consume(T), L) : ge(T) ? (e.consume(T), Z) : n(T);
  }
  function c(T) {
    return T === 45 ? (e.consume(T), h) : T === 91 ? (e.consume(T), a = 0, A) : ge(T) ? (e.consume(T), O) : n(T);
  }
  function h(T) {
    return T === 45 ? (e.consume(T), d) : n(T);
  }
  function f(T) {
    return T === null ? n(T) : T === 45 ? (e.consume(T), p) : z(T) ? (i = f, he(T)) : (e.consume(T), f);
  }
  function p(T) {
    return T === 45 ? (e.consume(T), d) : f(T);
  }
  function d(T) {
    return T === 62 ? le(T) : T === 45 ? p(T) : f(T);
  }
  function A(T) {
    const Ne = "CDATA[";
    return T === Ne.charCodeAt(a++) ? (e.consume(T), a === Ne.length ? C : A) : n(T);
  }
  function C(T) {
    return T === null ? n(T) : T === 93 ? (e.consume(T), y) : z(T) ? (i = C, he(T)) : (e.consume(T), C);
  }
  function y(T) {
    return T === 93 ? (e.consume(T), S) : C(T);
  }
  function S(T) {
    return T === 62 ? le(T) : T === 93 ? (e.consume(T), S) : C(T);
  }
  function O(T) {
    return T === null || T === 62 ? le(T) : z(T) ? (i = O, he(T)) : (e.consume(T), O);
  }
  function L(T) {
    return T === null ? n(T) : T === 63 ? (e.consume(T), Y) : z(T) ? (i = L, he(T)) : (e.consume(T), L);
  }
  function Y(T) {
    return T === 62 ? le(T) : L(T);
  }
  function q(T) {
    return ge(T) ? (e.consume(T), k) : n(T);
  }
  function k(T) {
    return T === 45 || me(T) ? (e.consume(T), k) : Q(T);
  }
  function Q(T) {
    return z(T) ? (i = Q, he(T)) : X(T) ? (e.consume(T), Q) : le(T);
  }
  function Z(T) {
    return T === 45 || me(T) ? (e.consume(T), Z) : T === 47 || T === 62 || ne(T) ? ee(T) : n(T);
  }
  function ee(T) {
    return T === 47 ? (e.consume(T), le) : T === 58 || T === 95 || ge(T) ? (e.consume(T), I) : z(T) ? (i = ee, he(T)) : X(T) ? (e.consume(T), ee) : le(T);
  }
  function I(T) {
    return T === 45 || T === 46 || T === 58 || T === 95 || me(T) ? (e.consume(T), I) : H(T);
  }
  function H(T) {
    return T === 61 ? (e.consume(T), U) : z(T) ? (i = H, he(T)) : X(T) ? (e.consume(T), H) : ee(T);
  }
  function U(T) {
    return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? n(T) : T === 34 || T === 39 ? (e.consume(T), u = T, v) : z(T) ? (i = U, he(T)) : X(T) ? (e.consume(T), U) : (e.consume(T), F);
  }
  function v(T) {
    return T === u ? (e.consume(T), u = void 0, j) : T === null ? n(T) : z(T) ? (i = v, he(T)) : (e.consume(T), v);
  }
  function F(T) {
    return T === null || T === 34 || T === 39 || T === 60 || T === 61 || T === 96 ? n(T) : T === 47 || T === 62 || ne(T) ? ee(T) : (e.consume(T), F);
  }
  function j(T) {
    return T === 47 || T === 62 || ne(T) ? ee(T) : n(T);
  }
  function le(T) {
    return T === 62 ? (e.consume(T), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(T);
  }
  function he(T) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), ye;
  }
  function ye(T) {
    return X(T) ? J(
      e,
      Fe,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(T) : Fe(T);
  }
  function Fe(T) {
    return e.enter("htmlTextData"), i(T);
  }
}
const eu = {
  name: "labelEnd",
  tokenize: e1,
  resolveTo: Zp,
  resolveAll: Jp
}, $p = {
  tokenize: t1
}, Xp = {
  tokenize: n1
}, Kp = {
  tokenize: r1
};
function Jp(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function Zp(e, t) {
  let n = e.length, r = 0, u, a, i, o;
  for (; n--; )
    if (u = e[n][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      e[n][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (i) {
      if (e[n][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = n, u.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[i][1].end)
  }, h = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[i - 2][1].start)
  };
  return o = [
    ["enter", l, t],
    ["enter", c, t]
  ], o = Ie(o, e.slice(a + 1, a + r + 3)), o = Ie(o, [["enter", h, t]]), o = Ie(
    o,
    Zr(
      t.parser.constructs.insideSpan.null,
      e.slice(a + r + 4, i - 3),
      t
    )
  ), o = Ie(o, [
    ["exit", h, t],
    e[i - 2],
    e[i - 1],
    ["exit", c, t]
  ]), o = Ie(o, e.slice(i + 1)), o = Ie(o, [["exit", l, t]]), we(e, a, e.length, o), e;
}
function e1(e, t, n) {
  const r = this;
  let u = r.events.length, a, i;
  for (; u--; )
    if ((r.events[u][1].type === "labelImage" || r.events[u][1].type === "labelLink") && !r.events[u][1]._balanced) {
      a = r.events[u][1];
      break;
    }
  return o;
  function o(p) {
    return a ? a._inactive ? f(p) : (i = r.parser.defined.includes(
      Tt(
        r.sliceSerialize({
          start: a.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(
      $p,
      h,
      i ? h : f
    )(p) : p === 91 ? e.attempt(
      Xp,
      h,
      i ? c : f
    )(p) : i ? h(p) : f(p);
  }
  function c(p) {
    return e.attempt(
      Kp,
      h,
      f
    )(p);
  }
  function h(p) {
    return t(p);
  }
  function f(p) {
    return a._balanced = !0, n(p);
  }
}
function t1(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), u;
  }
  function u(f) {
    return ne(f) ? Wt(e, a)(f) : a(f);
  }
  function a(f) {
    return f === 41 ? h(f) : Bs(
      e,
      i,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(f);
  }
  function i(f) {
    return ne(f) ? Wt(e, l)(f) : h(f);
  }
  function o(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? Hs(
      e,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(f) : h(f);
  }
  function c(f) {
    return ne(f) ? Wt(e, h)(f) : h(f);
  }
  function h(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function n1(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return Fs.call(
      r,
      e,
      a,
      i,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function a(o) {
    return r.parser.defined.includes(
      Tt(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function i(o) {
    return n(o);
  }
}
function r1(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const u1 = {
  name: "labelStartImage",
  tokenize: i1,
  resolveAll: eu.resolveAll
};
function i1(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : n(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const a1 = {
  name: "labelStartLink",
  tokenize: s1,
  resolveAll: eu.resolveAll
};
function s1(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(i) : t(i);
  }
}
const tr = {
  name: "lineEnding",
  tokenize: o1
};
function o1(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), J(e, t, "linePrefix");
  }
}
const bn = {
  name: "thematicBreak",
  tokenize: l1
};
function l1(e, t, n) {
  let r = 0, u;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), i(c);
  }
  function i(c) {
    return u = c, o(c);
  }
  function o(c) {
    return c === u ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || z(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === u ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), X(c) ? J(e, o, "whitespace")(c) : o(c));
  }
}
const be = {
  name: "list",
  tokenize: h1,
  continuation: {
    tokenize: d1
  },
  exit: p1
}, c1 = {
  tokenize: E1,
  partial: !0
}, f1 = {
  tokenize: m1,
  partial: !0
};
function h1(e, t, n) {
  const r = this, u = r.events[r.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, i = 0;
  return o;
  function o(d) {
    const A = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (A === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : br(d)) {
      if (r.containerState.type || (r.containerState.type = A, e.enter(A, {
        _container: !0
      })), A === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(bn, n, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return br(d) && ++i < 10 ? (e.consume(d), l) : (!r.interrupt || i < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), c(d)) : n(d);
  }
  function c(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      Un,
      // Canât be empty when interrupting.
      r.interrupt ? n : h,
      e.attempt(
        c1,
        p,
        f
      )
    );
  }
  function h(d) {
    return r.containerState.initialBlankLine = !0, a++, p(d);
  }
  function f(d) {
    return X(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), p) : n(d);
  }
  function p(d) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function d1(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Un, u, a);
  function u(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, J(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !X(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(f1, t, i)(o));
  }
  function i(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, J(
      e,
      e.attempt(be, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function m1(e, t, n) {
  const r = this;
  return J(
    e,
    u,
    "listItemIndent",
    r.containerState.size + 1
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function p1(e) {
  e.exit(this.containerState.type);
}
function E1(e, t, n) {
  const r = this;
  return J(
    e,
    u,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return !X(a) && i && i[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const Ai = {
  name: "setextUnderline",
  tokenize: T1,
  resolveTo: g1
};
function g1(e, t) {
  let n = e.length, r, u, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (u = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e[u][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[u][1].type = "setextHeadingText", a ? (e.splice(u, 0, ["enter", i, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = i, e.push(["exit", i, t]), e;
}
function T1(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(c) {
    let h = r.events.length, f;
    for (; h--; )
      if (r.events[h][1].type !== "lineEnding" && r.events[h][1].type !== "linePrefix" && r.events[h][1].type !== "content") {
        f = r.events[h][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), u = c, i(c)) : n(c);
  }
  function i(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === u ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), X(c) ? J(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || z(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const b1 = {
  tokenize: A1
};
function A1(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Un,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      u,
      J(
        e,
        e.attempt(
          this.parser.constructs.flow,
          u,
          e.attempt(Ip, u)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function u(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const _1 = {
  resolveAll: vs()
}, C1 = Us("string"), S1 = Us("text");
function Us(e) {
  return {
    tokenize: t,
    resolveAll: vs(
      e === "text" ? x1 : void 0
    )
  };
  function t(n) {
    const r = this, u = this.parser.constructs[e], a = n.attempt(u, i, o);
    return i;
    function i(h) {
      return c(h) ? a(h) : o(h);
    }
    function o(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), l;
    }
    function l(h) {
      return c(h) ? (n.exit("data"), a(h)) : (n.consume(h), l);
    }
    function c(h) {
      if (h === null)
        return !0;
      const f = u[h];
      let p = -1;
      if (f)
        for (; ++p < f.length; ) {
          const d = f[p];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function vs(e) {
  return t;
  function t(n, r) {
    let u = -1, a;
    for (; ++u <= n.length; )
      a === void 0 ? n[u] && n[u][1].type === "data" && (a = u, u++) : (!n[u] || n[u][1].type !== "data") && (u !== a + 2 && (n[a][1].end = n[u - 1][1].end, n.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function x1(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], u = t.sliceStream(r);
      let a = u.length, i = -1, o = 0, l;
      for (; a--; ) {
        const c = u[a];
        if (typeof c == "string") {
          for (i = c.length; c.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (c === -2)
          l = !0, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + a,
            _bufferIndex: a ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function I1(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], o = [];
  const l = {
    consume: O,
    enter: L,
    exit: Y,
    attempt: Q(q),
    check: Q(k),
    interrupt: Q(k, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: d,
    sliceSerialize: p,
    now: A,
    defineSkip: C,
    write: f
  };
  let h = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function f(H) {
    return i = Ie(i, H), y(), i[i.length - 1] !== null ? [] : (Z(t, 0), c.events = Zr(a, c.events, c), c.events);
  }
  function p(H, U) {
    return y1(d(H), U);
  }
  function d(H) {
    return k1(i, H);
  }
  function A() {
    const { line: H, column: U, offset: v, _index: F, _bufferIndex: j } = r;
    return {
      line: H,
      column: U,
      offset: v,
      _index: F,
      _bufferIndex: j
    };
  }
  function C(H) {
    u[H.line] = H.column, I();
  }
  function y() {
    let H;
    for (; r._index < i.length; ) {
      const U = i[r._index];
      if (typeof U == "string")
        for (H = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === H && r._bufferIndex < U.length; )
          S(U.charCodeAt(r._bufferIndex));
      else
        S(U);
    }
  }
  function S(H) {
    h = h(H);
  }
  function O(H) {
    z(H) ? (r.line++, r.column = 1, r.offset += H === -3 ? 2 : 1, I()) : H !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = H;
  }
  function L(H, U) {
    const v = U || {};
    return v.type = H, v.start = A(), c.events.push(["enter", v, c]), o.push(v), v;
  }
  function Y(H) {
    const U = o.pop();
    return U.end = A(), c.events.push(["exit", U, c]), U;
  }
  function q(H, U) {
    Z(H, U.from);
  }
  function k(H, U) {
    U.restore();
  }
  function Q(H, U) {
    return v;
    function v(F, j, le) {
      let he, ye, Fe, T;
      return Array.isArray(F) ? He(F) : "tokenize" in F ? (
        // @ts-expect-error Looks like a construct.
        He([F])
      ) : Ne(F);
      function Ne(de) {
        return Nt;
        function Nt(qe) {
          const ot = qe !== null && de[qe], Ke = qe !== null && de.null, zn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ot) ? ot : ot ? [ot] : [],
            ...Array.isArray(Ke) ? Ke : Ke ? [Ke] : []
          ];
          return He(zn)(qe);
        }
      }
      function He(de) {
        return he = de, ye = 0, de.length === 0 ? le : b(de[ye]);
      }
      function b(de) {
        return Nt;
        function Nt(qe) {
          return T = ee(), Fe = de, de.partial || (c.currentConstruct = de), de.name && c.parser.constructs.disable.null.includes(de.name) ? Xe() : de.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a âlive bindingâ, which is needed for `interrupt`.
            U ? Object.assign(Object.create(c), U) : c,
            l,
            Oe,
            Xe
          )(qe);
        }
      }
      function Oe(de) {
        return H(Fe, T), j;
      }
      function Xe(de) {
        return T.restore(), ++ye < he.length ? b(he[ye]) : le;
      }
    }
  }
  function Z(H, U) {
    H.resolveAll && !a.includes(H) && a.push(H), H.resolve && we(
      c.events,
      U,
      c.events.length - U,
      H.resolve(c.events.slice(U), c)
    ), H.resolveTo && (c.events = H.resolveTo(c.events, c));
  }
  function ee() {
    const H = A(), U = c.previous, v = c.currentConstruct, F = c.events.length, j = Array.from(o);
    return {
      restore: le,
      from: F
    };
    function le() {
      r = H, c.previous = U, c.currentConstruct = v, c.events.length = F, o = j, I();
    }
  }
  function I() {
    r.line in u && r.column < 2 && (r.column = u[r.line], r.offset += u[r.line] - 1);
  }
}
function k1(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, u = t.end._index, a = t.end._bufferIndex;
  let i;
  if (n === u)
    i = [e[n].slice(r, a)];
  else {
    if (i = e.slice(n, u), r > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r) : i.shift();
    }
    a > 0 && i.push(e[u].slice(0, a));
  }
  return i;
}
function y1(e, t) {
  let n = -1;
  const r = [];
  let u;
  for (; ++n < e.length; ) {
    const a = e[n];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r.push(i);
  }
  return r.join("");
}
const N1 = {
  42: be,
  43: be,
  45: be,
  48: be,
  49: be,
  50: be,
  51: be,
  52: be,
  53: be,
  54: be,
  55: be,
  56: be,
  57: be,
  62: Ds
}, O1 = {
  91: Lp
}, L1 = {
  [-2]: er,
  [-1]: er,
  32: er
}, R1 = {
  35: Bp,
  42: bn,
  45: [Ai, bn],
  60: vp,
  61: Ai,
  95: bn,
  96: Ti,
  126: Ti
}, D1 = {
  38: ws,
  92: Ps
}, P1 = {
  [-5]: tr,
  [-4]: tr,
  [-3]: tr,
  33: u1,
  38: ws,
  42: xr,
  60: [sp, Gp],
  91: a1,
  92: [wp, Ps],
  93: eu,
  95: xr,
  96: Ap
}, w1 = {
  null: [xr, _1]
}, M1 = {
  null: [42, 95]
}, B1 = {
  null: []
}, F1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: M1,
  contentInitial: O1,
  disable: B1,
  document: N1,
  flow: R1,
  flowInitial: L1,
  insideSpan: w1,
  string: D1,
  text: P1
}, Symbol.toStringTag, { value: "Module" }));
function H1(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    Km([F1, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: u(ep),
    document: u(np),
    flow: u(b1),
    string: u(C1),
    text: u(S1)
  };
  return r;
  function u(a) {
    return i;
    function i(o) {
      return I1(r, a, o);
    }
  }
}
function U1(e) {
  for (; !Ms(e); )
    ;
  return e;
}
const _i = /[\0\t\n\r]/g;
function v1() {
  let e = 1, t = "", n = !0, r;
  return u;
  function u(a, i, o) {
    const l = [];
    let c, h, f, p, d;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), f = 0, t = "", n && (a.charCodeAt(0) === 65279 && f++, n = void 0); f < a.length; ) {
      if (_i.lastIndex = f, c = _i.exec(a), p = c && c.index !== void 0 ? c.index : a.length, d = a.charCodeAt(p), !c) {
        t = a.slice(f);
        break;
      }
      if (d === 10 && f === p && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < p && (l.push(a.slice(f, p)), e += p - f), d) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e / 4) * 4, l.push(-2); e++ < h; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = p + 1;
    }
    return o && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const z1 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Y1(e) {
  return e.replace(z1, q1);
}
function q1(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const u = n.charCodeAt(1), a = u === 120 || u === 88;
    return Rs(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return Jr(n) || e;
}
const zs = {}.hasOwnProperty;
function j1(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), V1(n)(
    U1(
      H1(n).document().write(v1()(e, t, !0))
    )
  );
}
function V1(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(lu),
      autolinkProtocol: ee,
      autolinkEmail: ee,
      atxHeading: a(au),
      blockQuote: a(ot),
      characterEscape: ee,
      characterReference: ee,
      codeFenced: a(Ke),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: a(Ke, i),
      codeText: a(zn, i),
      codeTextData: ee,
      data: ee,
      codeFlowValue: ee,
      definition: a($s),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: a(Xs),
      hardBreakEscape: a(su),
      hardBreakTrailing: a(su),
      htmlFlow: a(ou, i),
      htmlFlowData: ee,
      htmlText: a(ou, i),
      htmlTextData: ee,
      image: a(Ks),
      label: i,
      link: a(lu),
      listItem: a(Js),
      listItemValue: p,
      listOrdered: a(cu, f),
      listUnordered: a(cu),
      paragraph: a(Zs),
      reference: b,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: a(au),
      strong: a(eo),
      thematicBreak: a(no)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: q,
      autolink: l(),
      autolinkEmail: qe,
      autolinkProtocol: Nt,
      blockQuote: l(),
      characterEscapeValue: I,
      characterReferenceMarkerHexadecimal: Xe,
      characterReferenceMarkerNumeric: Xe,
      characterReferenceValue: de,
      codeFenced: l(y),
      codeFencedFence: C,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: A,
      codeFlowValue: I,
      codeIndented: l(S),
      codeText: l(j),
      codeTextData: I,
      data: I,
      definition: l(),
      definitionDestinationString: Y,
      definitionLabelString: O,
      definitionTitleString: L,
      emphasis: l(),
      hardBreakEscape: l(U),
      hardBreakTrailing: l(U),
      htmlFlow: l(v),
      htmlFlowData: I,
      htmlText: l(F),
      htmlTextData: I,
      image: l(he),
      label: Fe,
      labelText: ye,
      lineEnding: H,
      link: l(le),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Oe,
      resourceDestinationString: T,
      resourceTitleString: Ne,
      resource: He,
      setextHeading: l(Z),
      setextHeadingLineSequence: Q,
      setextHeadingText: k,
      strong: l(),
      thematicBreak: l()
    }
  };
  Ys(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(N) {
    let M = {
      type: "root",
      children: []
    };
    const V = {
      stack: [M],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: i,
      resume: h,
      data: n
    }, K = [];
    let te = -1;
    for (; ++te < N.length; )
      if (N[te][1].type === "listOrdered" || N[te][1].type === "listUnordered")
        if (N[te][0] === "enter")
          K.push(te);
        else {
          const Le = K.pop();
          te = u(N, Le, te);
        }
    for (te = -1; ++te < N.length; ) {
      const Le = t[N[te][0]];
      zs.call(Le, N[te][1].type) && Le[N[te][1].type].call(
        Object.assign(
          {
            sliceSerialize: N[te][2].sliceSerialize
          },
          V
        ),
        N[te][1]
      );
    }
    if (V.tokenStack.length > 0) {
      const Le = V.tokenStack[V.tokenStack.length - 1];
      (Le[1] || Ci).call(V, void 0, Le[0]);
    }
    for (M.position = {
      start: je(
        N.length > 0 ? N[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: je(
        N.length > 0 ? N[N.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, te = -1; ++te < t.transforms.length; )
      M = t.transforms[te](M) || M;
    return M;
  }
  function u(N, M, V) {
    let K = M - 1, te = -1, Le = !1, Je, Ue, Ot, Lt;
    for (; ++K <= V; ) {
      const _e = N[K];
      switch (_e[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          _e[0] === "enter" ? te++ : te--, Lt = void 0;
          break;
        }
        case "lineEndingBlank": {
          _e[0] === "enter" && (Je && !Lt && !te && !Ot && (Ot = K), Lt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Lt = void 0;
      }
      if (!te && _e[0] === "enter" && _e[1].type === "listItemPrefix" || te === -1 && _e[0] === "exit" && (_e[1].type === "listUnordered" || _e[1].type === "listOrdered")) {
        if (Je) {
          let lt = K;
          for (Ue = void 0; lt--; ) {
            const ve = N[lt];
            if (ve[1].type === "lineEnding" || ve[1].type === "lineEndingBlank") {
              if (ve[0] === "exit") continue;
              Ue && (N[Ue][1].type = "lineEndingBlank", Le = !0), ve[1].type = "lineEnding", Ue = lt;
            } else if (!(ve[1].type === "linePrefix" || ve[1].type === "blockQuotePrefix" || ve[1].type === "blockQuotePrefixWhitespace" || ve[1].type === "blockQuoteMarker" || ve[1].type === "listItemIndent")) break;
          }
          Ot && (!Ue || Ot < Ue) && (Je._spread = !0), Je.end = Object.assign(
            {},
            Ue ? N[Ue][1].start : _e[1].end
          ), N.splice(Ue || K, 0, ["exit", Je, _e[2]]), K++, V++;
        }
        if (_e[1].type === "listItemPrefix") {
          const lt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, _e[1].start),
            // @ts-expect-error: weâll add `end` in a second.
            end: void 0
          };
          Je = lt, N.splice(K, 0, ["enter", lt, _e[2]]), K++, V++, Ot = void 0, Lt = !0;
        }
      }
    }
    return N[M][1]._spread = Le, V;
  }
  function a(N, M) {
    return V;
    function V(K) {
      o.call(this, N(K), K), M && M.call(this, K);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(N, M, V) {
    this.stack[this.stack.length - 1].children.push(N), this.stack.push(N), this.tokenStack.push([M, V]), N.position = {
      start: je(M.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(N) {
    return M;
    function M(V) {
      N && N.call(this, V), c.call(this, V);
    }
  }
  function c(N, M) {
    const V = this.stack.pop(), K = this.tokenStack.pop();
    if (K)
      K[0].type !== N.type && (M ? M.call(this, N, K[0]) : (K[1] || Ci).call(this, N, K[0]));
    else throw new Error(
      "Cannot close `" + N.type + "` (" + Gt({
        start: N.start,
        end: N.end
      }) + "): itâs not open"
    );
    V.position.end = je(N.end);
  }
  function h() {
    return qr(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(N) {
    if (this.data.expectingFirstListItemValue) {
      const M = this.stack[this.stack.length - 2];
      M.start = Number.parseInt(this.sliceSerialize(N), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.lang = N;
  }
  function A() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.meta = N;
  }
  function C() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N.replace(/(\r?\n|\r)$/g, "");
  }
  function O(N) {
    const M = this.resume(), V = this.stack[this.stack.length - 1];
    V.label = M, V.identifier = Tt(
      this.sliceSerialize(N)
    ).toLowerCase();
  }
  function L() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N;
  }
  function Y() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N;
  }
  function q(N) {
    const M = this.stack[this.stack.length - 1];
    if (!M.depth) {
      const V = this.sliceSerialize(N).length;
      M.depth = V;
    }
  }
  function k() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function Q(N) {
    const M = this.stack[this.stack.length - 1];
    M.depth = this.sliceSerialize(N).codePointAt(0) === 61 ? 1 : 2;
  }
  function Z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function ee(N) {
    const V = this.stack[this.stack.length - 1].children;
    let K = V[V.length - 1];
    (!K || K.type !== "text") && (K = to(), K.position = {
      start: je(N.start),
      // @ts-expect-error: weâll add `end` later.
      end: void 0
    }, V.push(K)), this.stack.push(K);
  }
  function I(N) {
    const M = this.stack.pop();
    M.value += this.sliceSerialize(N), M.position.end = je(N.end);
  }
  function H(N) {
    const M = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const V = M.children[M.children.length - 1];
      V.position.end = je(N.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(M.type) && (ee.call(this, N), I.call(this, N));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function v() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function F() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function j() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function le() {
    const N = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N.type += "Reference", N.referenceType = M, delete N.url, delete N.title;
    } else
      delete N.identifier, delete N.label;
    this.data.referenceType = void 0;
  }
  function he() {
    const N = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N.type += "Reference", N.referenceType = M, delete N.url, delete N.title;
    } else
      delete N.identifier, delete N.label;
    this.data.referenceType = void 0;
  }
  function ye(N) {
    const M = this.sliceSerialize(N), V = this.stack[this.stack.length - 2];
    V.label = Y1(M), V.identifier = Tt(M).toLowerCase();
  }
  function Fe() {
    const N = this.stack[this.stack.length - 1], M = this.resume(), V = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, V.type === "link") {
      const K = N.children;
      V.children = K;
    } else
      V.alt = M;
  }
  function T() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N;
  }
  function Ne() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N;
  }
  function He() {
    this.data.inReference = void 0;
  }
  function b() {
    this.data.referenceType = "collapsed";
  }
  function Oe(N) {
    const M = this.resume(), V = this.stack[this.stack.length - 1];
    V.label = M, V.identifier = Tt(
      this.sliceSerialize(N)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Xe(N) {
    this.data.characterReferenceType = N.type;
  }
  function de(N) {
    const M = this.sliceSerialize(N), V = this.data.characterReferenceType;
    let K;
    V ? (K = Rs(
      M,
      V === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : K = Jr(M);
    const te = this.stack.pop();
    te.value += K, te.position.end = je(N.end);
  }
  function Nt(N) {
    I.call(this, N);
    const M = this.stack[this.stack.length - 1];
    M.url = this.sliceSerialize(N);
  }
  function qe(N) {
    I.call(this, N);
    const M = this.stack[this.stack.length - 1];
    M.url = "mailto:" + this.sliceSerialize(N);
  }
  function ot() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ke() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function zn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function $s() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Xs() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function au() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function su() {
    return {
      type: "break"
    };
  }
  function ou() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ks() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function lu() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function cu(N) {
    return {
      type: "list",
      ordered: N.type === "listOrdered",
      start: null,
      spread: N._spread,
      children: []
    };
  }
  function Js(N) {
    return {
      type: "listItem",
      spread: N._spread,
      checked: null,
      children: []
    };
  }
  function Zs() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function eo() {
    return {
      type: "strong",
      children: []
    };
  }
  function to() {
    return {
      type: "text",
      value: ""
    };
  }
  function no() {
    return {
      type: "thematicBreak"
    };
  }
}
function je(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function Ys(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Ys(e, r) : W1(e, r);
  }
}
function W1(e, t) {
  let n;
  for (n in t)
    if (zs.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Ci(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + Gt({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Gt({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + Gt({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function G1(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return j1(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Q1(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function $1(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function X1(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let u = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (u.data = { meta: t.meta }), e.patch(t, u), u = e.applyData(t, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, e.patch(t, u), u;
}
function K1(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function J1(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Z1(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), u = kt(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let i, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + u,
      id: n + "fnref-" + u + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function eE(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function tE(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function qs(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const u = e.all(t), a = u[0];
  a && a.type === "text" ? a.value = "[" + a.value : u.unshift({ type: "text", value: "[" });
  const i = u[u.length - 1];
  return i && i.type === "text" ? i.value += r : u.push({ type: "text", value: r }), u;
}
function nE(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return qs(e, t);
  const u = { src: kt(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = { type: "element", tagName: "img", properties: u, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function rE(e, t) {
  const n = { src: kt(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function uE(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function iE(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return qs(e, t);
  const u = { href: kt(r.url || "") };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: u,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function aE(e, t) {
  const n = { href: kt(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function sE(e, t, n) {
  const r = e.all(t), u = n ? oE(n) : js(t), a = {}, i = [];
  if (typeof t.checked == "boolean") {
    const h = r[0];
    let f;
    h && h.type === "element" && h.tagName === "p" ? f = h : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const h = r[o];
    (u || o !== 0 || h.type !== "element" || h.tagName !== "p") && i.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !u ? i.push(...h.children) : i.push(h);
  }
  const l = r[r.length - 1];
  l && (u || l.type !== "element" || l.tagName !== "p") && i.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: i };
  return e.patch(t, c), e.applyData(t, c);
}
function oE(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = js(n[r]);
  }
  return t;
}
function js(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function lE(e, t) {
  const n = {}, r = e.all(t);
  let u = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++u < r.length; ) {
    const i = r[u];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function cE(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function fE(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function hE(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dE(e, t) {
  const n = e.all(t), r = n.shift(), u = [];
  if (r) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], i), u.push(i);
  }
  if (n.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = Me(t.children[1]), l = Mn(t.children[t.children.length - 1]);
    o && l && (i.position = { start: o, end: l }), u.push(i);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function mE(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, o = i ? i.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < o; ) {
    const f = t.children[l], p = {}, d = i ? i[l] : void 0;
    d && (p.align = d);
    let A = { type: "element", tagName: a, properties: p, children: [] };
    f && (A.children = e.all(f), e.patch(f, A), A = e.applyData(f, A)), c.push(A);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function pE(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Si = 9, xi = 32;
function EE(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), u = 0;
  const a = [];
  for (; r; )
    a.push(
      Ii(t.slice(u, r.index), u > 0, !0),
      r[0]
    ), u = r.index + r[0].length, r = n.exec(t);
  return a.push(Ii(t.slice(u), u > 0, !1)), a.join("");
}
function Ii(e, t, n) {
  let r = 0, u = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Si || a === xi; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(u - 1);
    for (; a === Si || a === xi; )
      u--, a = e.codePointAt(u - 1);
  }
  return u > r ? e.slice(r, u) : "";
}
function gE(e, t) {
  const n = { type: "text", value: EE(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function TE(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const bE = {
  blockquote: Q1,
  break: $1,
  code: X1,
  delete: K1,
  emphasis: J1,
  footnoteReference: Z1,
  heading: eE,
  html: tE,
  imageReference: nE,
  image: rE,
  inlineCode: uE,
  linkReference: iE,
  link: aE,
  listItem: sE,
  list: lE,
  paragraph: cE,
  // @ts-expect-error: root is different, but hard to type.
  root: fE,
  strong: hE,
  table: dE,
  tableCell: pE,
  tableRow: mE,
  text: gE,
  thematicBreak: TE,
  toml: hn,
  yaml: hn,
  definition: hn,
  footnoteDefinition: hn
};
function hn() {
}
const Vs = -1, vn = 0, Qt = 1, yn = 2, tu = 3, nu = 4, ru = 5, uu = 6, Ws = 7, Gs = 8, ki = typeof self == "object" ? self : globalThis, AE = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case vn:
      case Vs:
        return n(i, u);
      case Qt: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case yn: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case tu:
        return n(new Date(i), u);
      case nu: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case ru: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case uu: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case Ws: {
        const { name: o, message: l } = i;
        return n(new ki[o](l), u);
      }
      case Gs:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
      case "ArrayBuffer":
        return n(new Uint8Array(i).buffer, i);
      case "DataView": {
        const { buffer: o } = new Uint8Array(i);
        return n(new DataView(o), i);
      }
    }
    return n(new ki[a](i), u);
  };
  return r;
}, yi = (e) => AE(/* @__PURE__ */ new Map(), e)(0), dt = "", { toString: _E } = {}, { keys: CE } = Object, Ft = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [vn, t];
  const n = _E.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Qt, dt];
    case "Object":
      return [yn, dt];
    case "Date":
      return [tu, dt];
    case "RegExp":
      return [nu, dt];
    case "Map":
      return [ru, dt];
    case "Set":
      return [uu, dt];
    case "DataView":
      return [Qt, n];
  }
  return n.includes("Array") ? [Qt, n] : n.includes("Error") ? [Ws, n] : [yn, n];
}, dn = ([e, t]) => e === vn && (t === "function" || t === "symbol"), SE = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = Ft(i);
    switch (o) {
      case vn: {
        let h = i;
        switch (l) {
          case "bigint":
            o = Gs, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            h = null;
            break;
          case "undefined":
            return u([Vs], i);
        }
        return u([o, h], i);
      }
      case Qt: {
        if (l) {
          let p = i;
          return l === "DataView" ? p = new Uint8Array(i.buffer) : l === "ArrayBuffer" && (p = new Uint8Array(i)), u([l, [...p]], i);
        }
        const h = [], f = u([o, h], i);
        for (const p of i)
          h.push(a(p));
        return f;
      }
      case yn: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f = u([o, h], i);
        for (const p of CE(i))
          (e || !dn(Ft(i[p]))) && h.push([a(p), a(i[p])]);
        return f;
      }
      case tu:
        return u([o, i.toISOString()], i);
      case nu: {
        const { source: h, flags: f } = i;
        return u([o, { source: h, flags: f }], i);
      }
      case ru: {
        const h = [], f = u([o, h], i);
        for (const [p, d] of i)
          (e || !(dn(Ft(p)) || dn(Ft(d)))) && h.push([a(p), a(d)]);
        return f;
      }
      case uu: {
        const h = [], f = u([o, h], i);
        for (const p of i)
          (e || !dn(Ft(p))) && h.push(a(p));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, Ni = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return SE(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Nn = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? yi(Ni(e, t)) : structuredClone(e)
) : (e, t) => yi(Ni(e, t));
function xE(e, t) {
  const n = [{ type: "text", value: "â©" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function IE(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function kE(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || xE, r = e.options.footnoteBackLabel || IE, u = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const h = e.all(c), f = String(c.identifier).toUpperCase(), p = kt(f.toLowerCase());
    let d = 0;
    const A = [], C = e.footnoteCounts.get(f);
    for (; C !== void 0 && ++d <= C; ) {
      A.length > 0 && A.push({ type: "text", value: " " });
      let O = typeof n == "string" ? n : n(l, d);
      typeof O == "string" && (O = { type: "text", value: O }), A.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(O) ? O : [O]
      });
    }
    const y = h[h.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const O = y.children[y.children.length - 1];
      O && O.type === "text" ? O.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...A);
    } else
      h.push(...A);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(h, !0)
    };
    e.patch(c, S), o.push(S);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Nn(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: u }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Ir = {}.hasOwnProperty, yE = {};
function NE(e, t) {
  const n = t || yE, r = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = { ...bE, ...n.handlers }, o = {
    all: c,
    applyData: LE,
    definitionById: r,
    footnoteById: u,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: i,
    one: l,
    options: n,
    patch: OE,
    wrap: DE
  };
  return nn(e, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const f = h.type === "definition" ? r : u, p = String(h.identifier).toUpperCase();
      f.has(p) || f.set(p, h);
    }
  }), o;
  function l(h, f) {
    const p = h.type, d = o.handlers[p];
    if (Ir.call(o.handlers, p) && d)
      return d(o, h, f);
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ("children" in h) {
        const { children: C, ...y } = h, S = Nn(y);
        return S.children = o.all(h), S;
      }
      return Nn(h);
    }
    return (o.options.unknownHandler || RE)(o, h, f);
  }
  function c(h) {
    const f = [];
    if ("children" in h) {
      const p = h.children;
      let d = -1;
      for (; ++d < p.length; ) {
        const A = o.one(p[d], h);
        if (A) {
          if (d && p[d - 1].type === "break" && (!Array.isArray(A) && A.type === "text" && (A.value = Oi(A.value)), !Array.isArray(A) && A.type === "element")) {
            const C = A.children[0];
            C && C.type === "text" && (C.value = Oi(C.value));
          }
          Array.isArray(A) ? f.push(...A) : f.push(A);
        }
      }
    }
    return f;
  }
}
function OE(e, t) {
  e.position && (t.position = O0(e));
}
function LE(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, u = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const i = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: i };
      }
    n.type === "element" && a && Object.assign(n.properties, Nn(a)), "children" in n && n.children && u !== null && u !== void 0 && (n.children = u);
  }
  return n;
}
function RE(e, t) {
  const n = t.data || {}, r = "value" in t && !(Ir.call(n, "hProperties") || Ir.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function DE(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Oi(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Li(e, t) {
  const n = NE(e, t), r = n.one(e, void 0), u = kE(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return u && a.children.push({ type: "text", value: `
` }, u), a;
}
function PE(e, t) {
  return e && "run" in e ? async function(n, r) {
    const u = (
      /** @type {HastRoot} */
      Li(n, { file: r, ...t })
    );
    await e.run(u, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Li(n, { file: r, ...e || t })
    );
  };
}
function Ri(e) {
  if (e)
    throw e;
}
var nr, Di;
function wE() {
  if (Di) return nr;
  Di = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, u = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var h = e.call(c, "constructor"), f = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !h && !f)
      return !1;
    var p;
    for (p in c)
      ;
    return typeof p > "u" || e.call(c, p);
  }, i = function(c, h) {
    n && h.name === "__proto__" ? n(c, h.name, {
      enumerable: !0,
      configurable: !0,
      value: h.newValue,
      writable: !0
    }) : c[h.name] = h.newValue;
  }, o = function(c, h) {
    if (h === "__proto__")
      if (e.call(c, h)) {
        if (r)
          return r(c, h).value;
      } else return;
    return c[h];
  };
  return nr = function l() {
    var c, h, f, p, d, A, C = arguments[0], y = 1, S = arguments.length, O = !1;
    for (typeof C == "boolean" && (O = C, C = arguments[1] || {}, y = 2), (C == null || typeof C != "object" && typeof C != "function") && (C = {}); y < S; ++y)
      if (c = arguments[y], c != null)
        for (h in c)
          f = o(C, h), p = o(c, h), C !== p && (O && p && (a(p) || (d = u(p))) ? (d ? (d = !1, A = f && u(f) ? f : []) : A = f && a(f) ? f : {}, i(C, { name: h, newValue: l(O, A, p) })) : typeof p < "u" && i(C, { name: h, newValue: p }));
    return C;
  }, nr;
}
var ME = wE();
const rr = /* @__PURE__ */ zi(ME);
function kr(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function BE() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...u) {
    let a = -1;
    const i = u.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...u);
    function o(l, ...c) {
      const h = e[++a];
      let f = -1;
      if (l) {
        i(l);
        return;
      }
      for (; ++f < u.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = u[f]);
      u = c, h ? FE(h, o)(...c) : i(null, ...c);
    }
  }
  function r(u) {
    if (typeof u != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + u
      );
    return e.push(u), t;
  }
}
function FE(e, t) {
  let n;
  return r;
  function r(...i) {
    const o = e.length > i.length;
    let l;
    o && i.push(u);
    try {
      l = e.apply(this, i);
    } catch (c) {
      const h = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw h;
      return u(h);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(a, u) : l instanceof Error ? u(l) : a(l));
  }
  function u(i, ...o) {
    n || (n = !0, t(i, ...o));
  }
  function a(i) {
    u(null, i);
  }
}
const De = { basename: HE, dirname: UE, extname: vE, join: zE, sep: "/" };
function HE(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  sn(e);
  let n = 0, r = -1, u = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; u--; )
      if (e.codePointAt(u) === 47) {
        if (a) {
          n = u + 1;
          break;
        }
      } else r < 0 && (a = !0, r = u + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; u--; )
    if (e.codePointAt(u) === 47) {
      if (a) {
        n = u + 1;
        break;
      }
    } else
      i < 0 && (a = !0, i = u + 1), o > -1 && (e.codePointAt(u) === t.codePointAt(o--) ? o < 0 && (r = u) : (o = -1, r = i));
  return n === r ? r = i : r < 0 && (r = e.length), e.slice(n, r);
}
function UE(e) {
  if (sn(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function vE(e) {
  sn(e);
  let t = e.length, n = -1, r = 0, u = -1, a = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (i = !0, n = t + 1), o === 46 ? u < 0 ? u = t : a !== 1 && (a = 1) : u > -1 && (a = -1);
  }
  return u < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && u === n - 1 && u === r + 1 ? "" : e.slice(u, n);
}
function zE(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    sn(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : YE(n);
}
function YE(e) {
  sn(e);
  const t = e.codePointAt(0) === 47;
  let n = qE(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function qE(e, t) {
  let n = "", r = 0, u = -1, a = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(u === i - 1 || a === 1)) if (u !== i - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), u = i, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, u = i, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(u + 1, i) : n = e.slice(u + 1, i), r = i - u - 1;
      u = i, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function sn(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const jE = { cwd: VE };
function VE() {
  return "/";
}
function yr(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function WE(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!yr(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return GE(e);
}
function GE(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const u = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw u.code = "ERR_INVALID_FILE_URL_PATH", u;
      }
    }
  return decodeURIComponent(t);
}
const ur = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Qs {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â `{value: options}`
   * *   `URL` â `{path: options}`
   * *   `VFile` â shallow copies its data over to the new file
   * *   `object` â all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? yr(t) ? n = { path: t } : typeof t == "string" || QE(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : jE.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < ur.length; ) {
      const a = ur[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let u;
    for (u in n)
      ur.includes(u) || (this[u] = n[u]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? De.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    ar(t, "basename"), ir(t, "basename"), this.path = De.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? De.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâs no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Pi(this.basename, "dirname"), this.path = De.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? De.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâs no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (ir(t, "extname"), Pi(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = De.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    yr(t) && (t = WE(t)), ar(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? De.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    ar(t, "stem"), ir(t, "stem"), this.path = De.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const u = this.message(t, n, r);
    throw u.fatal = !0, u;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const u = this.message(t, n, r);
    return u.fatal = void 0, u;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const u = new Ee(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = !1, this.messages.push(u), u;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâs a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function ir(e, t) {
  if (e && e.includes(De.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + De.sep + "`"
    );
}
function ar(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Pi(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function QE(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const $E = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), u = r[e], a = function() {
      return u.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), XE = {}.hasOwnProperty;
class iu extends $E {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = BE();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new iu()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(rr(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (lr("data", this.frozen), this.namespace[t] = n, this) : XE.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (lr("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâs possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const u = n.call(t, ...r);
      typeof u == "function" && this.transformers.use(u);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = mn(t), r = this.parser || this.Parser;
    return sr("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâre using a compiler that doesnât serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), sr("process", this.parser || this.Parser), or("process", this.compiler || this.Compiler), n ? u(void 0, n) : new Promise(u);
    function u(a, i) {
      const o = mn(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(l, o, function(h, f, p) {
        if (h || !f || !p)
          return c(h);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), A = r.stringify(d, p);
        ZE(A) ? p.value = A : p.result = A, c(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function c(h, f) {
        h || !f ? i(h) : a ? a(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâre using a compiler that doesnât serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), sr("processSync", this.parser || this.Parser), or("processSync", this.compiler || this.Compiler), this.process(t, u), Mi("processSync", "process", n), r;
    function u(a, i) {
      n = !0, Ri(a), r = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    wi(t), this.freeze();
    const u = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(i, o) {
      const l = mn(n);
      u.run(t, l, c);
      function c(h, f, p) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        h ? o(h) : i ? i(d) : r(void 0, d, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, u;
    return this.run(t, n, a), Mi("runSync", "run", r), u;
    function a(i, o) {
      Ri(i), u = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâre using a compiler that doesnât serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = mn(n), u = this.compiler || this.Compiler;
    return or("stringify", u), wi(t), u(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, u = this.namespace;
    if (lr("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [h, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(h, f);
        } else
          i(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function i(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (u.settings = rr(!0, u.settings, c.settings));
    }
    function o(c) {
      let h = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++h < c.length; ) {
          const f = c[h];
          a(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, h) {
      let f = -1, p = -1;
      for (; ++f < r.length; )
        if (r[f][0] === c) {
          p = f;
          break;
        }
      if (p === -1)
        r.push([c, ...h]);
      else if (h.length > 0) {
        let [d, ...A] = h;
        const C = r[p][1];
        kr(C) && kr(d) && (d = rr(!0, C, d)), r[p] = [c, d, ...A];
      }
    }
  }
}
const KE = new iu().freeze();
function sr(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function or(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function lr(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function wi(e) {
  if (!kr(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Mi(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function mn(e) {
  return JE(e) ? e : new Qs(e);
}
function JE(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function ZE(e) {
  return typeof e == "string" || eg(e);
}
function eg(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const tg = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Bi = [], Fi = {
  allowDangerousHtml: !0
}, ng = /^(https?|ircs?|mailto|xmpp)$/i, rg = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  {
    from: "plugins",
    id: "change-plugins-to-remarkplugins",
    to: "remarkPlugins"
  },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function ug(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", u = e.className, a = e.components, i = e.disallowedElements, o = e.rehypePlugins || Bi, l = e.remarkPlugins || Bi, c = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Fi } : Fi, h = e.skipHtml, f = e.unwrapDisallowed, p = e.urlTransform || ig, d = KE().use(G1).use(l).use(PE, c).use(o), A = new Qs();
  typeof r == "string" && (A.value = r);
  for (const O of rg)
    Object.prototype.hasOwnProperty.call(e, O.from) && (`Unexpected '${O.from}' prop, ` + (O.to ? `use '${O.to}' instead` : "remove it") + ` (see <${tg}#${O.id}> for more info)`, void 0);
  const C = d.parse(A);
  let y = d.runSync(C, A);
  return u && (y = {
    type: "element",
    tagName: "div",
    properties: { className: u },
    children: y.type === "root" ? y.children : [y]
  }), nn(y, S), Mm(y, {
    Fragment: B.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: B.jsx,
    jsxs: B.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function S(O, L, Y) {
    if (O.type === "raw" && Y && typeof L == "number")
      return h ? Y.children.splice(L, 1) : Y.children[L] = { type: "text", value: O.value }, L;
    if (O.type === "element") {
      for (const k in Zn)
        if (Object.prototype.hasOwnProperty.call(Zn, k) && Object.prototype.hasOwnProperty.call(O.properties, k)) {
          const Q = O.properties[k], Z = Zn[k];
          (Z == null || Z.includes(O.tagName)) && (O.properties[k] = p(String(Q || ""), k, O));
        }
      let q = t ? !t.includes(O.tagName) : i ? i.includes(O.tagName) : !1;
      if (!q && n && typeof L == "number" && (q = !n(O, L, Y)), q && Y && typeof L == "number")
        return f && O.children ? Y.children.splice(L, 1, ...O.children) : Y.children.splice(L, 1), L;
    }
  }
}
function ig(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), u = e.indexOf("/");
  return t < 0 || u > -1 && t > u || n > -1 && t > n || r > -1 && t > r || ng.test(e.slice(0, t)) ? e : "";
}
const ag = () => (e) => {
  nn(e, "element", (t, n, r) => {
    t.tagName === "code" && (t.properties.inline = String((r == null ? void 0 : r.tagName) !== "pre"));
  });
}, sg = [gd], og = [ag, K0], Lg = "prose dark:prose-invert prose-neutral", lg = Ui(
  ({ content: e, className: t }) => /* @__PURE__ */ B.jsx(
    ug,
    {
      remarkPlugins: sg,
      rehypePlugins: og,
      components: lm,
      className: t,
      children: e
    }
  )
);
lg.displayName = "Markdown";
export {
  Ts as A,
  ft as H,
  om as I,
  lg as M,
  Lg as P,
  sm as S,
  Ng as V,
  rm as a,
  Og as b,
  lm as c,
  um as s,
  Wr as u
};
//# sourceMappingURL=Markdown-C5h6bxbE.js.map
