var g = Object.defineProperty;
var m = (n, t, s) => t in n ? g(n, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : n[t] = s;
var c = (n, t, s) => m(n, typeof t != "symbol" ? t + "" : t, s);
import { A as h } from "./AuthenticationPlugin-CJOFRBk3.js";
import { u as l } from "./hook-pPrHCB6G.js";
class p extends h {
  constructor(s) {
    super();
    c(this, "initialize", async () => {
      var r;
      const s = await this.clerk;
      if (s)
        if (s.session) {
          const e = s.session.user.emailAddresses.find(
            (a) => a.verification.status === "verified"
          );
          l.setState({
            isAuthenticated: !0,
            isPending: !1,
            profile: {
              sub: s.session.user.id,
              name: s.session.user.fullName ?? void 0,
              email: (e == null ? void 0 : e.emailAddress) ?? ((r = s.session.user.emailAddresses[0]) == null ? void 0 : r.emailAddress),
              emailVerified: e !== void 0,
              pictureUrl: s.session.user.imageUrl
            },
            providerData: {
              user: s.session.user
            }
          });
        } else
          l.setState({
            isAuthenticated: !1,
            isPending: !1,
            profile: void 0
          });
    });
    this.clerk = s;
  }
}
const y = ({
  clerkPubKey: n,
  redirectToAfterSignOut: t = "/",
  redirectToAfterSignUp: s = "/",
  redirectToAfterSignIn: r = "/"
}) => {
  let e;
  const a = (async () => {
    var o;
    if (typeof window > "u") return;
    const { Clerk: i } = await import("@clerk/clerk-js");
    if (e = new i(n), await e.load(), e.user) {
      const u = e.user.emailAddresses.find(
        (w) => w.verification.status === "verified"
      );
      l.setState({
        isAuthenticated: !0,
        isPending: !1,
        profile: {
          sub: e.user.id,
          name: e.user.fullName ?? void 0,
          email: (u == null ? void 0 : u.emailAddress) ?? ((o = e.user.emailAddresses[0]) == null ? void 0 : o.emailAddress),
          emailVerified: u !== void 0,
          pictureUrl: e.user.imageUrl
        },
        providerData: {
          user: {
            publicMetadata: e.user.publicMetadata,
            id: e.user.id,
            emailAddresses: e.user.emailAddresses,
            imageUrl: e.user.imageUrl,
            fullName: e.user.fullName
          }
        }
      });
    }
    return e;
  })();
  async function d() {
    if (await a, !(e != null && e.session))
      throw new Error("No session available");
    const i = await e.session.getToken();
    if (!i)
      throw new Error("Could not get access token from Clerk");
    return i;
  }
  async function f(i) {
    const o = await d();
    return i.headers.set("Authorization", `Bearer ${o}`), i;
  }
  return {
    clerk: e,
    getAccessToken: d,
    signRequest: f,
    signOut: async () => {
      await a, await (e == null ? void 0 : e.signOut({
        redirectUrl: window.location.origin + t
      })), l.setState({
        isAuthenticated: !1,
        isPending: !1,
        profile: null,
        providerData: null
      });
    },
    signIn: async ({ redirectTo: i } = {}) => {
      await a, await (e == null ? void 0 : e.redirectToSignIn({
        signInForceRedirectUrl: i ?? window.location.origin + r,
        signUpForceRedirectUrl: i ?? window.location.origin + s
      }));
    },
    signUp: async ({ redirectTo: i } = {}) => {
      await a, await (e == null ? void 0 : e.redirectToSignUp({
        signInForceRedirectUrl: i ?? window.location.origin + r,
        signUpForceRedirectUrl: i ?? window.location.origin + s
      }));
    },
    getAuthenticationPlugin() {
      return new p(a);
    }
  };
};
export {
  y as default
};
//# sourceMappingURL=zudoku.auth-clerk.js.map
