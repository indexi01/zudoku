function ye(e, n) {
  if (!!!e)
    throw new Error(n);
}
function eo(e) {
  return typeof e == "object" && e !== null;
}
function yu(e, n) {
  if (!!!e)
    throw new Error(
      n ?? "Unexpected invariant triggered."
    );
}
const vu = /\r\n|[\n\r]/g;
function ei(e, n) {
  let a = 0, i = 1;
  for (const t of e.body.matchAll(vu)) {
    if (typeof t.index == "number" || yu(!1), t.index >= n)
      break;
    a = t.index + t[0].length, i += 1;
  }
  return {
    line: i,
    column: n + 1 - a
  };
}
function Tu(e) {
  return no(
    e.source,
    ei(e.source, e.start)
  );
}
function no(e, n) {
  const a = e.locationOffset.column - 1, i = "".padStart(a) + e.body, t = n.line - 1, r = e.locationOffset.line - 1, s = n.line + r, u = n.line === 1 ? a : 0, c = n.column + u, d = `${e.name}:${s}:${c}
`, m = i.split(/\r\n|[\n\r]/g), o = m[t];
  if (o.length > 120) {
    const p = Math.floor(c / 80), y = c % 80, l = [];
    for (let f = 0; f < o.length; f += 80)
      l.push(o.slice(f, f + 80));
    return d + Si([
      [`${s} |`, l[0]],
      ...l.slice(1, p + 1).map((f) => ["|", f]),
      ["|", "^".padStart(y)],
      ["|", l[p + 1]]
    ]);
  }
  return d + Si([
    // Lines specified like this: ["prefix", "string"],
    [`${s - 1} |`, m[t - 1]],
    [`${s} |`, o],
    ["|", "^".padStart(c)],
    [`${s + 1} |`, m[t + 1]]
  ]);
}
function Si(e) {
  const n = e.filter(([i, t]) => t !== void 0), a = Math.max(...n.map(([i]) => i.length));
  return n.map(([i, t]) => i.padStart(a) + (t ? " " + t : "")).join(`
`);
}
function bu(e) {
  const n = e[0];
  return n == null || "kind" in n || "length" in n ? {
    nodes: n,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : n;
}
let qe = class to extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(n, ...a) {
    var i, t, r;
    const { nodes: s, source: u, positions: c, path: d, originalError: m, extensions: o } = bu(a);
    super(n), this.name = "GraphQLError", this.path = d ?? void 0, this.originalError = m ?? void 0, this.nodes = Li(
      Array.isArray(s) ? s : s ? [s] : void 0
    );
    const p = Li(
      (i = this.nodes) === null || i === void 0 ? void 0 : i.map((l) => l.loc).filter((l) => l != null)
    );
    this.source = u ?? (p == null || (t = p[0]) === null || t === void 0 ? void 0 : t.source), this.positions = c ?? (p == null ? void 0 : p.map((l) => l.start)), this.locations = c && u ? c.map((l) => ei(u, l)) : p == null ? void 0 : p.map((l) => ei(l.source, l.start));
    const y = eo(
      m == null ? void 0 : m.extensions
    ) ? m == null ? void 0 : m.extensions : void 0;
    this.extensions = (r = o ?? y) !== null && r !== void 0 ? r : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), m != null && m.stack ? Object.defineProperty(this, "stack", {
      value: m.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, to) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let n = this.message;
    if (this.nodes)
      for (const a of this.nodes)
        a.loc && (n += `

` + Tu(a.loc));
    else if (this.source && this.locations)
      for (const a of this.locations)
        n += `

` + no(this.source, a);
    return n;
  }
  toJSON() {
    const n = {
      message: this.message
    };
    return this.locations != null && (n.locations = this.locations), this.path != null && (n.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (n.extensions = this.extensions), n;
  }
};
function Li(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function Ue(e, n, a) {
  return new qe(`Syntax Error: ${a}`, {
    source: e,
    positions: [n]
  });
}
class zc {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(n, a, i) {
    this.start = n.start, this.end = a.end, this.startToken = n, this.endToken = a, this.source = i;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class ro {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(n, a, i, t, r, s) {
    this.kind = n, this.start = a, this.end = i, this.line = t, this.column = r, this.value = s, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const io = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, gu = new Set(Object.keys(io));
function Ri(e) {
  const n = e == null ? void 0 : e.kind;
  return typeof n == "string" && gu.has(n);
}
var Di;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(Di || (Di = {}));
var Te;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(Te || (Te = {}));
function ni(e) {
  return e === 9 || e === 32;
}
function Bn(e) {
  return e >= 48 && e <= 57;
}
function ao(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function ai(e) {
  return ao(e) || e === 95;
}
function so(e) {
  return ao(e) || Bn(e) || e === 95;
}
function Eu(e) {
  var n;
  let a = Number.MAX_SAFE_INTEGER, i = null, t = -1;
  for (let s = 0; s < e.length; ++s) {
    var r;
    const u = e[s], c = Nu(u);
    c !== u.length && (i = (r = i) !== null && r !== void 0 ? r : s, t = s, s !== 0 && c < a && (a = c));
  }
  return e.map((s, u) => u === 0 ? s : s.slice(a)).slice(
    (n = i) !== null && n !== void 0 ? n : 0,
    t + 1
  );
}
function Nu(e) {
  let n = 0;
  for (; n < e.length && ni(e.charCodeAt(n)); )
    ++n;
  return n;
}
function Ou(e, n) {
  const a = e.replace(/"""/g, '\\"""'), i = a.split(/\r\n|[\n\r]/g), t = i.length === 1, r = i.length > 1 && i.slice(1).every((y) => y.length === 0 || ni(y.charCodeAt(0))), s = a.endsWith('\\"""'), u = e.endsWith('"') && !s, c = e.endsWith("\\"), d = u || c, m = !(n != null && n.minimize) && // add leading and trailing new lines only if it improves readability
  (!t || e.length > 70 || d || r || s);
  let o = "";
  const p = t && ni(e.charCodeAt(0));
  return (m && !p || r) && (o += `
`), o += a, (m || d) && (o += `
`), '"""' + o + '"""';
}
var ie;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(ie || (ie = {}));
class Xc {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(n) {
    const a = new ro(ie.SOF, 0, 0, 0, 0);
    this.source = n, this.lastToken = a, this.token = a, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let n = this.token;
    if (n.kind !== ie.EOF)
      do
        if (n.next)
          n = n.next;
        else {
          const a = _u(this, n.end);
          n.next = a, a.prev = n, n = a;
        }
      while (n.kind === ie.COMMENT);
    return n;
  }
}
function Hc(e) {
  return e === ie.BANG || e === ie.DOLLAR || e === ie.AMP || e === ie.PAREN_L || e === ie.PAREN_R || e === ie.SPREAD || e === ie.COLON || e === ie.EQUALS || e === ie.AT || e === ie.BRACKET_L || e === ie.BRACKET_R || e === ie.BRACE_L || e === ie.PIPE || e === ie.BRACE_R;
}
function In(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function Rr(e, n) {
  return oo(e.charCodeAt(n)) && uo(e.charCodeAt(n + 1));
}
function oo(e) {
  return e >= 55296 && e <= 56319;
}
function uo(e) {
  return e >= 56320 && e <= 57343;
}
function un(e, n) {
  const a = e.source.body.codePointAt(n);
  if (a === void 0)
    return ie.EOF;
  if (a >= 32 && a <= 126) {
    const i = String.fromCodePoint(a);
    return i === '"' ? `'"'` : `"${i}"`;
  }
  return "U+" + a.toString(16).toUpperCase().padStart(4, "0");
}
function _e(e, n, a, i, t) {
  const r = e.line, s = 1 + a - e.lineStart;
  return new ro(n, a, i, r, s, t);
}
function _u(e, n) {
  const a = e.source.body, i = a.length;
  let t = n;
  for (; t < i; ) {
    const r = a.charCodeAt(t);
    switch (r) {
      // Ignored ::
      //   - UnicodeBOM
      //   - WhiteSpace
      //   - LineTerminator
      //   - Comment
      //   - Comma
      //
      // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
      //
      // WhiteSpace ::
      //   - "Horizontal Tab (U+0009)"
      //   - "Space (U+0020)"
      //
      // Comma :: ,
      case 65279:
      // <BOM>
      case 9:
      // \t
      case 32:
      // <space>
      case 44:
        ++t;
        continue;
      // LineTerminator ::
      //   - "New Line (U+000A)"
      //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
      //   - "Carriage Return (U+000D)" "New Line (U+000A)"
      case 10:
        ++t, ++e.line, e.lineStart = t;
        continue;
      case 13:
        a.charCodeAt(t + 1) === 10 ? t += 2 : ++t, ++e.line, e.lineStart = t;
        continue;
      // Comment
      case 35:
        return Iu(e, t);
      // Token ::
      //   - Punctuator
      //   - Name
      //   - IntValue
      //   - FloatValue
      //   - StringValue
      //
      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
      case 33:
        return _e(e, ie.BANG, t, t + 1);
      case 36:
        return _e(e, ie.DOLLAR, t, t + 1);
      case 38:
        return _e(e, ie.AMP, t, t + 1);
      case 40:
        return _e(e, ie.PAREN_L, t, t + 1);
      case 41:
        return _e(e, ie.PAREN_R, t, t + 1);
      case 46:
        if (a.charCodeAt(t + 1) === 46 && a.charCodeAt(t + 2) === 46)
          return _e(e, ie.SPREAD, t, t + 3);
        break;
      case 58:
        return _e(e, ie.COLON, t, t + 1);
      case 61:
        return _e(e, ie.EQUALS, t, t + 1);
      case 64:
        return _e(e, ie.AT, t, t + 1);
      case 91:
        return _e(e, ie.BRACKET_L, t, t + 1);
      case 93:
        return _e(e, ie.BRACKET_R, t, t + 1);
      case 123:
        return _e(e, ie.BRACE_L, t, t + 1);
      case 124:
        return _e(e, ie.PIPE, t, t + 1);
      case 125:
        return _e(e, ie.BRACE_R, t, t + 1);
      // StringValue
      case 34:
        return a.charCodeAt(t + 1) === 34 && a.charCodeAt(t + 2) === 34 ? ju(e, t) : Lu(e, t);
    }
    if (Bn(r) || r === 45)
      return Su(e, t, r);
    if (ai(r))
      return Pu(e, t);
    throw Ue(
      e.source,
      t,
      r === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : In(r) || Rr(a, t) ? `Unexpected character: ${un(e, t)}.` : `Invalid character: ${un(e, t)}.`
    );
  }
  return _e(e, ie.EOF, i, i);
}
function Iu(e, n) {
  const a = e.source.body, i = a.length;
  let t = n + 1;
  for (; t < i; ) {
    const r = a.charCodeAt(t);
    if (r === 10 || r === 13)
      break;
    if (In(r))
      ++t;
    else if (Rr(a, t))
      t += 2;
    else
      break;
  }
  return _e(
    e,
    ie.COMMENT,
    n,
    t,
    a.slice(n + 1, t)
  );
}
function Su(e, n, a) {
  const i = e.source.body;
  let t = n, r = a, s = !1;
  if (r === 45 && (r = i.charCodeAt(++t)), r === 48) {
    if (r = i.charCodeAt(++t), Bn(r))
      throw Ue(
        e.source,
        t,
        `Invalid number, unexpected digit after 0: ${un(
          e,
          t
        )}.`
      );
  } else
    t = xr(e, t, r), r = i.charCodeAt(t);
  if (r === 46 && (s = !0, r = i.charCodeAt(++t), t = xr(e, t, r), r = i.charCodeAt(t)), (r === 69 || r === 101) && (s = !0, r = i.charCodeAt(++t), (r === 43 || r === 45) && (r = i.charCodeAt(++t)), t = xr(e, t, r), r = i.charCodeAt(t)), r === 46 || ai(r))
    throw Ue(
      e.source,
      t,
      `Invalid number, expected digit but got: ${un(
        e,
        t
      )}.`
    );
  return _e(
    e,
    s ? ie.FLOAT : ie.INT,
    n,
    t,
    i.slice(n, t)
  );
}
function xr(e, n, a) {
  if (!Bn(a))
    throw Ue(
      e.source,
      n,
      `Invalid number, expected digit but got: ${un(
        e,
        n
      )}.`
    );
  const i = e.source.body;
  let t = n + 1;
  for (; Bn(i.charCodeAt(t)); )
    ++t;
  return t;
}
function Lu(e, n) {
  const a = e.source.body, i = a.length;
  let t = n + 1, r = t, s = "";
  for (; t < i; ) {
    const u = a.charCodeAt(t);
    if (u === 34)
      return s += a.slice(r, t), _e(e, ie.STRING, n, t + 1, s);
    if (u === 92) {
      s += a.slice(r, t);
      const c = a.charCodeAt(t + 1) === 117 ? a.charCodeAt(t + 2) === 123 ? Ru(e, t) : Du(e, t) : Au(e, t);
      s += c.value, t += c.size, r = t;
      continue;
    }
    if (u === 10 || u === 13)
      break;
    if (In(u))
      ++t;
    else if (Rr(a, t))
      t += 2;
    else
      throw Ue(
        e.source,
        t,
        `Invalid character within String: ${un(
          e,
          t
        )}.`
      );
  }
  throw Ue(e.source, t, "Unterminated string.");
}
function Ru(e, n) {
  const a = e.source.body;
  let i = 0, t = 3;
  for (; t < 12; ) {
    const r = a.charCodeAt(n + t++);
    if (r === 125) {
      if (t < 5 || !In(i))
        break;
      return {
        value: String.fromCodePoint(i),
        size: t
      };
    }
    if (i = i << 4 | Kn(r), i < 0)
      break;
  }
  throw Ue(
    e.source,
    n,
    `Invalid Unicode escape sequence: "${a.slice(
      n,
      n + t
    )}".`
  );
}
function Du(e, n) {
  const a = e.source.body, i = Ai(a, n + 2);
  if (In(i))
    return {
      value: String.fromCodePoint(i),
      size: 6
    };
  if (oo(i) && a.charCodeAt(n + 6) === 92 && a.charCodeAt(n + 7) === 117) {
    const t = Ai(a, n + 8);
    if (uo(t))
      return {
        value: String.fromCodePoint(i, t),
        size: 12
      };
  }
  throw Ue(
    e.source,
    n,
    `Invalid Unicode escape sequence: "${a.slice(n, n + 6)}".`
  );
}
function Ai(e, n) {
  return Kn(e.charCodeAt(n)) << 12 | Kn(e.charCodeAt(n + 1)) << 8 | Kn(e.charCodeAt(n + 2)) << 4 | Kn(e.charCodeAt(n + 3));
}
function Kn(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Au(e, n) {
  const a = e.source.body;
  switch (a.charCodeAt(n + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Ue(
    e.source,
    n,
    `Invalid character escape sequence: "${a.slice(
      n,
      n + 2
    )}".`
  );
}
function ju(e, n) {
  const a = e.source.body, i = a.length;
  let t = e.lineStart, r = n + 3, s = r, u = "";
  const c = [];
  for (; r < i; ) {
    const d = a.charCodeAt(r);
    if (d === 34 && a.charCodeAt(r + 1) === 34 && a.charCodeAt(r + 2) === 34) {
      u += a.slice(s, r), c.push(u);
      const m = _e(
        e,
        ie.BLOCK_STRING,
        n,
        r + 3,
        // Return a string of the lines joined with U+000A.
        Eu(c).join(`
`)
      );
      return e.line += c.length - 1, e.lineStart = t, m;
    }
    if (d === 92 && a.charCodeAt(r + 1) === 34 && a.charCodeAt(r + 2) === 34 && a.charCodeAt(r + 3) === 34) {
      u += a.slice(s, r), s = r + 1, r += 4;
      continue;
    }
    if (d === 10 || d === 13) {
      u += a.slice(s, r), c.push(u), d === 13 && a.charCodeAt(r + 1) === 10 ? r += 2 : ++r, u = "", s = r, t = r;
      continue;
    }
    if (In(d))
      ++r;
    else if (Rr(a, r))
      r += 2;
    else
      throw Ue(
        e.source,
        r,
        `Invalid character within String: ${un(
          e,
          r
        )}.`
      );
  }
  throw Ue(e.source, r, "Unterminated string.");
}
function Pu(e, n) {
  const a = e.source.body, i = a.length;
  let t = n + 1;
  for (; t < i; ) {
    const r = a.charCodeAt(t);
    if (so(r))
      ++t;
    else
      break;
  }
  return _e(
    e,
    ie.NAME,
    n,
    t,
    a.slice(n, t)
  );
}
const Fu = 10, co = 2;
function ke(e) {
  return Dr(e, []);
}
function Dr(e, n) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return wu(e, n);
    default:
      return String(e);
  }
}
function wu(e, n) {
  if (e === null)
    return "null";
  if (n.includes(e))
    return "[Circular]";
  const a = [...n, e];
  if (ku(e)) {
    const i = e.toJSON();
    if (i !== e)
      return typeof i == "string" ? i : Dr(i, a);
  } else if (Array.isArray(e))
    return Cu(e, a);
  return Vu(e, a);
}
function ku(e) {
  return typeof e.toJSON == "function";
}
function Vu(e, n) {
  const a = Object.entries(e);
  return a.length === 0 ? "{}" : n.length > co ? "[" + Gu(e) + "]" : "{ " + a.map(
    ([t, r]) => t + ": " + Dr(r, n)
  ).join(", ") + " }";
}
function Cu(e, n) {
  if (e.length === 0)
    return "[]";
  if (n.length > co)
    return "[Array]";
  const a = Math.min(Fu, e.length), i = e.length - a, t = [];
  for (let r = 0; r < a; ++r)
    t.push(Dr(e[r], n));
  return i === 1 ? t.push("... 1 more item") : i > 1 && t.push(`... ${i} more items`), "[" + t.join(", ") + "]";
}
function Gu(e) {
  const n = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (n === "Object" && typeof e.constructor == "function") {
    const a = e.constructor.name;
    if (typeof a == "string" && a !== "")
      return a;
  }
  return n;
}
const Mu = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", He = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  Mu ? function(n, a) {
    return n instanceof a;
  } : function(n, a) {
    if (n instanceof a)
      return !0;
    if (typeof n == "object" && n !== null) {
      var i;
      const t = a.prototype[Symbol.toStringTag], r = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in n ? n[Symbol.toStringTag] : (i = n.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (t === r) {
        const s = ke(n);
        throw new Error(`Cannot use ${t} "${s}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class $u {
  constructor(n, a = "GraphQL request", i = {
    line: 1,
    column: 1
  }) {
    typeof n == "string" || ye(!1, `Body must be a string. Received: ${ke(n)}.`), this.body = n, this.name = a, this.locationOffset = i, this.locationOffset.line > 0 || ye(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || ye(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Wc(e) {
  return He(e, $u);
}
const Uu = 5;
function Qu(e, n) {
  const [a, i] = n ? [e, n] : [void 0, e];
  let t = " Did you mean ";
  a && (t += a + " ");
  const r = i.map((c) => `"${c}"`);
  switch (r.length) {
    case 0:
      return "";
    case 1:
      return t + r[0] + "?";
    case 2:
      return t + r[0] + " or " + r[1] + "?";
  }
  const s = r.slice(0, Uu), u = s.pop();
  return t + s.join(", ") + ", or " + u + "?";
}
function ji(e) {
  return e;
}
function qu(e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    a[n(i)] = i;
  return a;
}
function si(e, n, a) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const t of e)
    i[n(t)] = a(t);
  return i;
}
function Ar(e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  for (const i of Object.keys(e))
    a[i] = n(e[i], i);
  return a;
}
function Ku(e, n) {
  let a = 0, i = 0;
  for (; a < e.length && i < n.length; ) {
    let t = e.charCodeAt(a), r = n.charCodeAt(i);
    if (nt(t) && nt(r)) {
      let s = 0;
      do
        ++a, s = s * 10 + t - ti, t = e.charCodeAt(a);
      while (nt(t) && s > 0);
      let u = 0;
      do
        ++i, u = u * 10 + r - ti, r = n.charCodeAt(i);
      while (nt(r) && u > 0);
      if (s < u)
        return -1;
      if (s > u)
        return 1;
    } else {
      if (t < r)
        return -1;
      if (t > r)
        return 1;
      ++a, ++i;
    }
  }
  return e.length - n.length;
}
const ti = 48, xu = 57;
function nt(e) {
  return !isNaN(e) && ti <= e && e <= xu;
}
function Bu(e, n) {
  const a = /* @__PURE__ */ Object.create(null), i = new Yu(e), t = Math.floor(e.length * 0.4) + 1;
  for (const r of n) {
    const s = i.measure(r, t);
    s !== void 0 && (a[r] = s);
  }
  return Object.keys(a).sort((r, s) => {
    const u = a[r] - a[s];
    return u !== 0 ? u : Ku(r, s);
  });
}
class Yu {
  constructor(n) {
    this._input = n, this._inputLowerCase = n.toLowerCase(), this._inputArray = Pi(this._inputLowerCase), this._rows = [
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0)
    ];
  }
  measure(n, a) {
    if (this._input === n)
      return 0;
    const i = n.toLowerCase();
    if (this._inputLowerCase === i)
      return 1;
    let t = Pi(i), r = this._inputArray;
    if (t.length < r.length) {
      const m = t;
      t = r, r = m;
    }
    const s = t.length, u = r.length;
    if (s - u > a)
      return;
    const c = this._rows;
    for (let m = 0; m <= u; m++)
      c[0][m] = m;
    for (let m = 1; m <= s; m++) {
      const o = c[(m - 1) % 3], p = c[m % 3];
      let y = p[0] = m;
      for (let l = 1; l <= u; l++) {
        const f = t[m - 1] === r[l - 1] ? 0 : 1;
        let h = Math.min(
          o[l] + 1,
          // delete
          p[l - 1] + 1,
          // insert
          o[l - 1] + f
          // substitute
        );
        if (m > 1 && l > 1 && t[m - 1] === r[l - 2] && t[m - 2] === r[l - 1]) {
          const T = c[(m - 2) % 3][l - 2];
          h = Math.min(h, T + 1);
        }
        h < y && (y = h), p[l] = h;
      }
      if (y > a)
        return;
    }
    const d = c[s % 3][u];
    return d <= a ? d : void 0;
  }
}
function Pi(e) {
  const n = e.length, a = new Array(n);
  for (let i = 0; i < n; ++i)
    a[i] = e.charCodeAt(i);
  return a;
}
function Ke(e) {
  if (e == null)
    return /* @__PURE__ */ Object.create(null);
  if (Object.getPrototypeOf(e) === null)
    return e;
  const n = /* @__PURE__ */ Object.create(null);
  for (const [a, i] of Object.entries(e))
    n[a] = i;
  return n;
}
function Ju(e) {
  return `"${e.replace(zu, Xu)}"`;
}
const zu = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function Xu(e) {
  return Hu[e.charCodeAt(0)];
}
const Hu = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], xn = Object.freeze({});
function Wu(e, n, a = io) {
  const i = /* @__PURE__ */ new Map();
  for (const T of Object.values(Te))
    i.set(T, lo(n, T));
  let t, r = Array.isArray(e), s = [e], u = -1, c = [], d = e, m, o;
  const p = [], y = [];
  do {
    u++;
    const T = u === s.length, O = T && c.length !== 0;
    if (T) {
      if (m = y.length === 0 ? void 0 : p[p.length - 1], d = o, o = y.pop(), O)
        if (r) {
          d = d.slice();
          let D = 0;
          for (const [_, w] of c) {
            const M = _ - D;
            w === null ? (d.splice(M, 1), D++) : d[M] = w;
          }
        } else {
          d = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(d)
          );
          for (const [D, _] of c)
            d[D] = _;
        }
      u = t.index, s = t.keys, c = t.edits, r = t.inArray, t = t.prev;
    } else if (o) {
      if (m = r ? u : s[u], d = o[m], d == null)
        continue;
      p.push(m);
    }
    let R;
    if (!Array.isArray(d)) {
      var l, f;
      Ri(d) || ye(!1, `Invalid AST Node: ${ke(d)}.`);
      const D = T ? (l = i.get(d.kind)) === null || l === void 0 ? void 0 : l.leave : (f = i.get(d.kind)) === null || f === void 0 ? void 0 : f.enter;
      if (R = D == null ? void 0 : D.call(n, d, m, o, p, y), R === xn)
        break;
      if (R === !1) {
        if (!T) {
          p.pop();
          continue;
        }
      } else if (R !== void 0 && (c.push([m, R]), !T))
        if (Ri(R))
          d = R;
        else {
          p.pop();
          continue;
        }
    }
    if (R === void 0 && O && c.push([m, d]), T)
      p.pop();
    else {
      var h;
      t = {
        inArray: r,
        index: u,
        keys: s,
        edits: c,
        prev: t
      }, r = Array.isArray(d), s = r ? d : (h = a[d.kind]) !== null && h !== void 0 ? h : [], u = -1, c = [], o && y.push(o), o = d;
    }
  } while (t !== void 0);
  return c.length !== 0 ? c[c.length - 1][1] : e;
}
function Zc(e) {
  const n = new Array(e.length).fill(null), a = /* @__PURE__ */ Object.create(null);
  for (const i of Object.values(Te)) {
    let t = !1;
    const r = new Array(e.length).fill(void 0), s = new Array(e.length).fill(void 0);
    for (let c = 0; c < e.length; ++c) {
      const { enter: d, leave: m } = lo(e[c], i);
      t || (t = d != null || m != null), r[c] = d, s[c] = m;
    }
    if (!t)
      continue;
    const u = {
      enter(...c) {
        const d = c[0];
        for (let o = 0; o < e.length; o++)
          if (n[o] === null) {
            var m;
            const p = (m = r[o]) === null || m === void 0 ? void 0 : m.apply(e[o], c);
            if (p === !1)
              n[o] = d;
            else if (p === xn)
              n[o] = xn;
            else if (p !== void 0)
              return p;
          }
      },
      leave(...c) {
        const d = c[0];
        for (let o = 0; o < e.length; o++)
          if (n[o] === null) {
            var m;
            const p = (m = s[o]) === null || m === void 0 ? void 0 : m.apply(e[o], c);
            if (p === xn)
              n[o] = xn;
            else if (p !== void 0 && p !== !1)
              return p;
          } else n[o] === d && (n[o] = null);
      }
    };
    a[i] = u;
  }
  return a;
}
function lo(e, n) {
  const a = e[n];
  return typeof a == "object" ? a : typeof a == "function" ? {
    enter: a,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function Lr(e) {
  return Wu(e, ec);
}
const Zu = 80, ec = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => X(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const n = ae("(", X(e.variableDefinitions, ", "), ")"), a = X(
        [
          e.operation,
          X([e.name, n]),
          X(e.directives, " ")
        ],
        " "
      );
      return (a === "query" ? "" : a + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: n, defaultValue: a, directives: i }) => e + ": " + n + ae(" = ", a) + ae(" ", X(i, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => Me(e)
  },
  Field: {
    leave({ alias: e, name: n, arguments: a, directives: i, selectionSet: t }) {
      const r = ae("", e, ": ") + n;
      let s = r + ae("(", X(a, ", "), ")");
      return s.length > Zu && (s = r + ae(`(
`, Sr(X(a, `
`)), `
)`)), X([s, X(i, " "), t], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: n }) => "..." + e + ae(" ", X(n, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: n, selectionSet: a }) => X(
      [
        "...",
        ae("on ", e),
        X(n, " "),
        a
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: n, variableDefinitions: a, directives: i, selectionSet: t }) => (
      // or removed in the future.
      `fragment ${e}${ae("(", X(a, ", "), ")")} on ${n} ${ae("", X(i, " "), " ")}` + t
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: n }) => n ? Ou(e) : Ju(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + X(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + X(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: n }) => "@" + e + ae("(", X(n, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: n, operationTypes: a }) => ae("", e, `
`) + X(["schema", X(n, " "), Me(a)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: n }) => e + ": " + n
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: n, directives: a }) => ae("", e, `
`) + X(["scalar", n, X(a, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: a, directives: i, fields: t }) => ae("", e, `
`) + X(
      [
        "type",
        n,
        ae("implements ", X(a, " & ")),
        X(i, " "),
        Me(t)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: n, arguments: a, type: i, directives: t }) => ae("", e, `
`) + n + (Fi(a) ? ae(`(
`, Sr(X(a, `
`)), `
)`) : ae("(", X(a, ", "), ")")) + ": " + i + ae(" ", X(t, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: n, type: a, defaultValue: i, directives: t }) => ae("", e, `
`) + X(
      [n + ": " + a, ae("= ", i), X(t, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: a, directives: i, fields: t }) => ae("", e, `
`) + X(
      [
        "interface",
        n,
        ae("implements ", X(a, " & ")),
        X(i, " "),
        Me(t)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, types: i }) => ae("", e, `
`) + X(
      ["union", n, X(a, " "), ae("= ", X(i, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, values: i }) => ae("", e, `
`) + X(["enum", n, X(a, " "), Me(i)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: n, directives: a }) => ae("", e, `
`) + X([n, X(a, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: n, directives: a, fields: i }) => ae("", e, `
`) + X(["input", n, X(a, " "), Me(i)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: n, arguments: a, repeatable: i, locations: t }) => ae("", e, `
`) + "directive @" + n + (Fi(a) ? ae(`(
`, Sr(X(a, `
`)), `
)`) : ae("(", X(a, ", "), ")")) + (i ? " repeatable" : "") + " on " + X(t, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: n }) => X(
      ["extend schema", X(e, " "), Me(n)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: n }) => X(["extend scalar", e, X(n, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: a, fields: i }) => X(
      [
        "extend type",
        e,
        ae("implements ", X(n, " & ")),
        X(a, " "),
        Me(i)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: a, fields: i }) => X(
      [
        "extend interface",
        e,
        ae("implements ", X(n, " & ")),
        X(a, " "),
        Me(i)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: n, types: a }) => X(
      [
        "extend union",
        e,
        X(n, " "),
        ae("= ", X(a, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: n, values: a }) => X(["extend enum", e, X(n, " "), Me(a)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: n, fields: a }) => X(["extend input", e, X(n, " "), Me(a)], " ")
  }
};
function X(e, n = "") {
  var a;
  return (a = e == null ? void 0 : e.filter((i) => i).join(n)) !== null && a !== void 0 ? a : "";
}
function Me(e) {
  return ae(`{
`, Sr(X(e, `
`)), `
}`);
}
function ae(e, n, a = "") {
  return n != null && n !== "" ? e + n + a : "";
}
function Sr(e) {
  return ae("  ", e.replace(/\n/g, `
  `));
}
function Fi(e) {
  var n;
  return (n = e == null ? void 0 : e.some((a) => a.includes(`
`))) !== null && n !== void 0 ? n : !1;
}
function ri(e, n) {
  switch (e.kind) {
    case Te.NULL:
      return null;
    case Te.INT:
      return parseInt(e.value, 10);
    case Te.FLOAT:
      return parseFloat(e.value);
    case Te.STRING:
    case Te.ENUM:
    case Te.BOOLEAN:
      return e.value;
    case Te.LIST:
      return e.values.map(
        (a) => ri(a, n)
      );
    case Te.OBJECT:
      return si(
        e.fields,
        (a) => a.name.value,
        (a) => ri(a.value, n)
      );
    case Te.VARIABLE:
      return n == null ? void 0 : n[e.name.value];
  }
}
function xe(e) {
  if (e != null || ye(!1, "Must provide name."), typeof e == "string" || ye(!1, "Expected name to be a string."), e.length === 0)
    throw new qe("Expected name to be a non-empty string.");
  for (let n = 1; n < e.length; ++n)
    if (!so(e.charCodeAt(n)))
      throw new qe(
        `Names must only contain [_a-zA-Z0-9] but "${e}" does not.`
      );
  if (!ai(e.charCodeAt(0)))
    throw new qe(
      `Names must start with [_a-zA-Z] but "${e}" does not.`
    );
  return e;
}
function nc(e) {
  if (e === "true" || e === "false" || e === "null")
    throw new qe(`Enum values cannot be named: ${e}`);
  return xe(e);
}
function po(e) {
  return Yn(e) || jr(e) || Jn(e) || zn(e) || Xn(e) || oi(e) || fo(e) || Sn(e);
}
function Yn(e) {
  return He(e, ci);
}
function jr(e) {
  return He(e, oc);
}
function Jn(e) {
  return He(e, lc);
}
function zn(e) {
  return He(e, pc);
}
function Xn(e) {
  return He(e, fc);
}
function oi(e) {
  return He(e, mc);
}
function fo(e) {
  return He(e, ic);
}
function Sn(e) {
  return He(e, ac);
}
function tc(e) {
  return Yn(e) || Xn(e) || oi(e) || ui(e) && tc(e.ofType);
}
function rc(e) {
  return Yn(e) || jr(e) || Jn(e) || zn(e) || Xn(e) || ui(e) && rc(e.ofType);
}
function el(e) {
  return Yn(e) || Xn(e);
}
function nl(e) {
  return jr(e) || Jn(e) || zn(e);
}
function tl(e) {
  return Jn(e) || zn(e);
}
class ic {
  constructor(n) {
    po(n) || ye(!1, `Expected ${ke(n)} to be a GraphQL type.`), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class ac {
  constructor(n) {
    sc(n) || ye(
      !1,
      `Expected ${ke(n)} to be a GraphQL nullable type.`
    ), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function ui(e) {
  return fo(e) || Sn(e);
}
function sc(e) {
  return po(e) && !Sn(e);
}
function rl(e) {
  if (e)
    return Sn(e) ? e.ofType : e;
}
function il(e) {
  return Yn(e) || jr(e) || Jn(e) || zn(e) || Xn(e) || oi(e);
}
function al(e) {
  if (e) {
    let n = e;
    for (; ui(n); )
      n = n.ofType;
    return n;
  }
}
function mo(e) {
  return typeof e == "function" ? e() : e;
}
function ho(e) {
  return typeof e == "function" ? e() : e;
}
class ci {
  constructor(n) {
    var a, i, t, r;
    const s = (a = n.parseValue) !== null && a !== void 0 ? a : ji;
    this.name = xe(n.name), this.description = n.description, this.specifiedByURL = n.specifiedByURL, this.serialize = (i = n.serialize) !== null && i !== void 0 ? i : ji, this.parseValue = s, this.parseLiteral = (t = n.parseLiteral) !== null && t !== void 0 ? t : (u, c) => s(ri(u, c)), this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (r = n.extensionASTNodes) !== null && r !== void 0 ? r : [], n.specifiedByURL == null || typeof n.specifiedByURL == "string" || ye(
      !1,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${ke(n.specifiedByURL)}.`
    ), n.serialize == null || typeof n.serialize == "function" || ye(
      !1,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    ), n.parseLiteral && (typeof n.parseValue == "function" && typeof n.parseLiteral == "function" || ye(
      !1,
      `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
    ));
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class oc {
  constructor(n) {
    var a;
    this.name = xe(n.name), this.description = n.description, this.isTypeOf = n.isTypeOf, this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._fields = () => vo(n), this._interfaces = () => yo(n), n.isTypeOf == null || typeof n.isTypeOf == "function" || ye(
      !1,
      `${this.name} must provide "isTypeOf" as a function, but got: ${ke(n.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: To(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function yo(e) {
  var n;
  const a = mo(
    (n = e.interfaces) !== null && n !== void 0 ? n : []
  );
  return Array.isArray(a) || ye(
    !1,
    `${e.name} interfaces must be an Array or a function which returns an Array.`
  ), a;
}
function vo(e) {
  const n = ho(e.fields);
  return _n(n) || ye(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), Ar(n, (a, i) => {
    var t;
    _n(a) || ye(
      !1,
      `${e.name}.${i} field config must be an object.`
    ), a.resolve == null || typeof a.resolve == "function" || ye(
      !1,
      `${e.name}.${i} field resolver must be a function if provided, but got: ${ke(a.resolve)}.`
    );
    const r = (t = a.args) !== null && t !== void 0 ? t : {};
    return _n(r) || ye(
      !1,
      `${e.name}.${i} args must be an object with argument names as keys.`
    ), {
      name: xe(i),
      description: a.description,
      type: a.type,
      args: uc(r),
      resolve: a.resolve,
      subscribe: a.subscribe,
      deprecationReason: a.deprecationReason,
      extensions: Ke(a.extensions),
      astNode: a.astNode
    };
  });
}
function uc(e) {
  return Object.entries(e).map(([n, a]) => ({
    name: xe(n),
    description: a.description,
    type: a.type,
    defaultValue: a.defaultValue,
    deprecationReason: a.deprecationReason,
    extensions: Ke(a.extensions),
    astNode: a.astNode
  }));
}
function _n(e) {
  return eo(e) && !Array.isArray(e);
}
function To(e) {
  return Ar(e, (n) => ({
    description: n.description,
    type: n.type,
    args: cc(n.args),
    resolve: n.resolve,
    subscribe: n.subscribe,
    deprecationReason: n.deprecationReason,
    extensions: n.extensions,
    astNode: n.astNode
  }));
}
function cc(e) {
  return si(
    e,
    (n) => n.name,
    (n) => ({
      description: n.description,
      type: n.type,
      defaultValue: n.defaultValue,
      deprecationReason: n.deprecationReason,
      extensions: n.extensions,
      astNode: n.astNode
    })
  );
}
function sl(e) {
  return Sn(e.type) && e.defaultValue === void 0;
}
class lc {
  constructor(n) {
    var a;
    this.name = xe(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._fields = vo.bind(void 0, n), this._interfaces = yo.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || ye(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${ke(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: To(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class pc {
  constructor(n) {
    var a;
    this.name = xe(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._types = dc.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || ye(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${ke(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    return typeof this._types == "function" && (this._types = this._types()), this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function dc(e) {
  const n = mo(e.types);
  return Array.isArray(n) || ye(
    !1,
    `Must provide Array of types or a function which returns such an array for Union ${e.name}.`
  ), n;
}
class fc {
  /* <T> */
  constructor(n) {
    var a;
    this.name = xe(n.name), this.description = n.description, this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this._values = typeof n.values == "function" ? n.values : wi(this.name, n.values), this._valueLookup = null, this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return typeof this._values == "function" && (this._values = wi(this.name, this._values())), this._values;
  }
  getValue(n) {
    return this._nameLookup === null && (this._nameLookup = qu(this.getValues(), (a) => a.name)), this._nameLookup[n];
  }
  serialize(n) {
    this._valueLookup === null && (this._valueLookup = new Map(
      this.getValues().map((i) => [i.value, i])
    ));
    const a = this._valueLookup.get(n);
    if (a === void 0)
      throw new qe(
        `Enum "${this.name}" cannot represent value: ${ke(n)}`
      );
    return a.name;
  }
  parseValue(n) {
    if (typeof n != "string") {
      const i = ke(n);
      throw new qe(
        `Enum "${this.name}" cannot represent non-string value: ${i}.` + tt(this, i)
      );
    }
    const a = this.getValue(n);
    if (a == null)
      throw new qe(
        `Value "${n}" does not exist in "${this.name}" enum.` + tt(this, n)
      );
    return a.value;
  }
  parseLiteral(n, a) {
    if (n.kind !== Te.ENUM) {
      const t = Lr(n);
      throw new qe(
        `Enum "${this.name}" cannot represent non-enum value: ${t}.` + tt(this, t),
        {
          nodes: n
        }
      );
    }
    const i = this.getValue(n.value);
    if (i == null) {
      const t = Lr(n);
      throw new qe(
        `Value "${t}" does not exist in "${this.name}" enum.` + tt(this, t),
        {
          nodes: n
        }
      );
    }
    return i.value;
  }
  toConfig() {
    const n = si(
      this.getValues(),
      (a) => a.name,
      (a) => ({
        description: a.description,
        value: a.value,
        deprecationReason: a.deprecationReason,
        extensions: a.extensions,
        astNode: a.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function tt(e, n) {
  const a = e.getValues().map((t) => t.name), i = Bu(n, a);
  return Qu("the enum value", i);
}
function wi(e, n) {
  return _n(n) || ye(
    !1,
    `${e} values must be an object with value names as keys.`
  ), Object.entries(n).map(([a, i]) => (_n(i) || ye(
    !1,
    `${e}.${a} must refer to an object with a "value" key representing an internal value but got: ${ke(i)}.`
  ), {
    name: nc(a),
    description: i.description,
    value: i.value !== void 0 ? i.value : a,
    deprecationReason: i.deprecationReason,
    extensions: Ke(i.extensions),
    astNode: i.astNode
  }));
}
class mc {
  constructor(n) {
    var a, i;
    this.name = xe(n.name), this.description = n.description, this.extensions = Ke(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (a = n.extensionASTNodes) !== null && a !== void 0 ? a : [], this.isOneOf = (i = n.isOneOf) !== null && i !== void 0 ? i : !1, this._fields = hc.bind(void 0, n);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  toConfig() {
    const n = Ar(this.getFields(), (a) => ({
      description: a.description,
      type: a.type,
      defaultValue: a.defaultValue,
      deprecationReason: a.deprecationReason,
      extensions: a.extensions,
      astNode: a.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function hc(e) {
  const n = ho(e.fields);
  return _n(n) || ye(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), Ar(n, (a, i) => (!("resolve" in a) || ye(
    !1,
    `${e.name}.${i} field has a resolve property, but Input Types cannot define resolvers.`
  ), {
    name: xe(i),
    description: a.description,
    type: a.type,
    defaultValue: a.defaultValue,
    deprecationReason: a.deprecationReason,
    extensions: Ke(a.extensions),
    astNode: a.astNode
  }));
}
function ol(e) {
  return Sn(e.type) && e.defaultValue === void 0;
}
function ki(e) {
  return e;
}
function Vi(e) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new TypeError("JSONObject cannot represent non-object value: " + e);
  return e;
}
function bo(e, n, a) {
  var i = /* @__PURE__ */ Object.create(null);
  return n.fields.forEach(function(t) {
    i[t.name.value] = li(e, t.value, a);
  }), i;
}
function li(e, n, a) {
  switch (n.kind) {
    case Te.STRING:
    case Te.BOOLEAN:
      return n.value;
    case Te.INT:
    case Te.FLOAT:
      return parseFloat(n.value);
    case Te.OBJECT:
      return bo(e, n, a);
    case Te.LIST:
      return n.values.map(function(i) {
        return li(e, i, a);
      });
    case Te.NULL:
      return null;
    case Te.VARIABLE:
      return a ? a[n.name.value] : void 0;
    default:
      throw new TypeError(e + " cannot represent value: " + Lr(n));
  }
}
var Ci = new ci({
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: ki,
  parseValue: ki,
  parseLiteral: function(n, a) {
    return li("JSON", n, a);
  }
}), ul = new ci({
  name: "JSONObject",
  description: "The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: Vi,
  parseValue: Vi,
  parseLiteral: function(n, a) {
    if (n.kind !== Te.OBJECT)
      throw new TypeError("JSONObject cannot represent non-object value: " + Lr(n));
    return bo("JSONObject", n, a);
  }
}), Br = {}, rn = {}, rt = {}, Gi;
function We() {
  if (Gi) return rt;
  Gi = 1, Object.defineProperty(rt, "__esModule", {
    value: !0
  }), rt.isObjectLike = e;
  function e(n) {
    return typeof n == "object" && n !== null;
  }
  return rt;
}
var it = {}, at = {}, Mi;
function Re() {
  if (Mi) return at;
  Mi = 1, Object.defineProperty(at, "__esModule", {
    value: !0
  }), at.invariant = e;
  function e(n, a) {
    if (!!!n)
      throw new Error(
        a ?? "Unexpected invariant triggered."
      );
  }
  return at;
}
var $i;
function pi() {
  if ($i) return it;
  $i = 1, Object.defineProperty(it, "__esModule", {
    value: !0
  }), it.getLocation = a;
  var e = /* @__PURE__ */ Re();
  const n = /\r\n|[\n\r]/g;
  function a(i, t) {
    let r = 0, s = 1;
    for (const u of i.body.matchAll(n)) {
      if (typeof u.index == "number" || (0, e.invariant)(!1), u.index >= t)
        break;
      r = u.index + u[0].length, s += 1;
    }
    return {
      line: s,
      column: t + 1 - r
    };
  }
  return it;
}
var jn = {}, Ui;
function go() {
  if (Ui) return jn;
  Ui = 1, Object.defineProperty(jn, "__esModule", {
    value: !0
  }), jn.printLocation = n, jn.printSourceLocation = a;
  var e = /* @__PURE__ */ pi();
  function n(t) {
    return a(
      t.source,
      (0, e.getLocation)(t.source, t.start)
    );
  }
  function a(t, r) {
    const s = t.locationOffset.column - 1, u = "".padStart(s) + t.body, c = r.line - 1, d = t.locationOffset.line - 1, m = r.line + d, o = r.line === 1 ? s : 0, p = r.column + o, y = `${t.name}:${m}:${p}
`, l = u.split(/\r\n|[\n\r]/g), f = l[c];
    if (f.length > 120) {
      const h = Math.floor(p / 80), T = p % 80, O = [];
      for (let R = 0; R < f.length; R += 80)
        O.push(f.slice(R, R + 80));
      return y + i([
        [`${m} |`, O[0]],
        ...O.slice(1, h + 1).map((R) => ["|", R]),
        ["|", "^".padStart(T)],
        ["|", O[h + 1]]
      ]);
    }
    return y + i([
      // Lines specified like this: ["prefix", "string"],
      [`${m - 1} |`, l[c - 1]],
      [`${m} |`, f],
      ["|", "^".padStart(p)],
      [`${m + 1} |`, l[c + 1]]
    ]);
  }
  function i(t) {
    const r = t.filter(([u, c]) => c !== void 0), s = Math.max(...r.map(([u]) => u.length));
    return r.map(([u, c]) => u.padStart(s) + (c ? " " + c : "")).join(`
`);
  }
  return jn;
}
var Qi;
function ne() {
  if (Qi) return rn;
  Qi = 1, Object.defineProperty(rn, "__esModule", {
    value: !0
  }), rn.GraphQLError = void 0, rn.formatError = u, rn.printError = s;
  var e = /* @__PURE__ */ We(), n = /* @__PURE__ */ pi(), a = /* @__PURE__ */ go();
  function i(c) {
    const d = c[0];
    return d == null || "kind" in d || "length" in d ? {
      nodes: d,
      source: c[1],
      positions: c[2],
      path: c[3],
      originalError: c[4],
      extensions: c[5]
    } : d;
  }
  let t = class Eo extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(d, ...m) {
      var o, p, y;
      const { nodes: l, source: f, positions: h, path: T, originalError: O, extensions: R } = i(m);
      super(d), this.name = "GraphQLError", this.path = T ?? void 0, this.originalError = O ?? void 0, this.nodes = r(
        Array.isArray(l) ? l : l ? [l] : void 0
      );
      const D = r(
        (o = this.nodes) === null || o === void 0 ? void 0 : o.map((w) => w.loc).filter((w) => w != null)
      );
      this.source = f ?? (D == null || (p = D[0]) === null || p === void 0 ? void 0 : p.source), this.positions = h ?? (D == null ? void 0 : D.map((w) => w.start)), this.locations = h && f ? h.map((w) => (0, n.getLocation)(f, w)) : D == null ? void 0 : D.map(
        (w) => (0, n.getLocation)(w.source, w.start)
      );
      const _ = (0, e.isObjectLike)(
        O == null ? void 0 : O.extensions
      ) ? O == null ? void 0 : O.extensions : void 0;
      this.extensions = (y = R ?? _) !== null && y !== void 0 ? y : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
        message: {
          writable: !0,
          enumerable: !0
        },
        name: {
          enumerable: !1
        },
        nodes: {
          enumerable: !1
        },
        source: {
          enumerable: !1
        },
        positions: {
          enumerable: !1
        },
        originalError: {
          enumerable: !1
        }
      }), O != null && O.stack ? Object.defineProperty(this, "stack", {
        value: O.stack,
        writable: !0,
        configurable: !0
      }) : Error.captureStackTrace ? Error.captureStackTrace(this, Eo) : Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: !0,
        configurable: !0
      });
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let d = this.message;
      if (this.nodes)
        for (const m of this.nodes)
          m.loc && (d += `

` + (0, a.printLocation)(m.loc));
      else if (this.source && this.locations)
        for (const m of this.locations)
          d += `

` + (0, a.printSourceLocation)(this.source, m);
      return d;
    }
    toJSON() {
      const d = {
        message: this.message
      };
      return this.locations != null && (d.locations = this.locations), this.path != null && (d.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (d.extensions = this.extensions), d;
    }
  };
  rn.GraphQLError = t;
  function r(c) {
    return c === void 0 || c.length === 0 ? void 0 : c;
  }
  function s(c) {
    return c.toString();
  }
  function u(c) {
    return c.toJSON();
  }
  return rn;
}
var st = {}, qi;
function di() {
  if (qi) return st;
  qi = 1, Object.defineProperty(st, "__esModule", {
    value: !0
  }), st.syntaxError = n;
  var e = /* @__PURE__ */ ne();
  function n(a, i, t) {
    return new e.GraphQLError(`Syntax Error: ${t}`, {
      source: a,
      positions: [i]
    });
  }
  return st;
}
var ot = {}, ut = {}, ct = {}, Ki;
function fe() {
  if (Ki) return ct;
  Ki = 1, Object.defineProperty(ct, "__esModule", {
    value: !0
  }), ct.inspect = a;
  const e = 10, n = 2;
  function a(d) {
    return i(d, []);
  }
  function i(d, m) {
    switch (typeof d) {
      case "string":
        return JSON.stringify(d);
      case "function":
        return d.name ? `[function ${d.name}]` : "[function]";
      case "object":
        return t(d, m);
      default:
        return String(d);
    }
  }
  function t(d, m) {
    if (d === null)
      return "null";
    if (m.includes(d))
      return "[Circular]";
    const o = [...m, d];
    if (r(d)) {
      const p = d.toJSON();
      if (p !== d)
        return typeof p == "string" ? p : i(p, o);
    } else if (Array.isArray(d))
      return u(d, o);
    return s(d, o);
  }
  function r(d) {
    return typeof d.toJSON == "function";
  }
  function s(d, m) {
    const o = Object.entries(d);
    return o.length === 0 ? "{}" : m.length > n ? "[" + c(d) + "]" : "{ " + o.map(
      ([y, l]) => y + ": " + i(l, m)
    ).join(", ") + " }";
  }
  function u(d, m) {
    if (d.length === 0)
      return "[]";
    if (m.length > n)
      return "[Array]";
    const o = Math.min(e, d.length), p = d.length - o, y = [];
    for (let l = 0; l < o; ++l)
      y.push(i(d[l], m));
    return p === 1 ? y.push("... 1 more item") : p > 1 && y.push(`... ${p} more items`), "[" + y.join(", ") + "]";
  }
  function c(d) {
    const m = Object.prototype.toString.call(d).replace(/^\[object /, "").replace(/]$/, "");
    if (m === "Object" && typeof d.constructor == "function") {
      const o = d.constructor.name;
      if (typeof o == "string" && o !== "")
        return o;
    }
    return m;
  }
  return ct;
}
var xi;
function yc() {
  if (xi) return ut;
  xi = 1, Object.defineProperty(ut, "__esModule", {
    value: !0
  }), ut.toError = n;
  var e = /* @__PURE__ */ fe();
  function n(i) {
    return i instanceof Error ? i : new a(i);
  }
  class a extends Error {
    constructor(t) {
      super("Unexpected error value: " + (0, e.inspect)(t)), this.name = "NonErrorThrown", this.thrownValue = t;
    }
  }
  return ut;
}
var Bi;
function fi() {
  if (Bi) return ot;
  Bi = 1, Object.defineProperty(ot, "__esModule", {
    value: !0
  }), ot.locatedError = a;
  var e = /* @__PURE__ */ yc(), n = /* @__PURE__ */ ne();
  function a(t, r, s) {
    var u;
    const c = (0, e.toError)(t);
    return i(c) ? c : new n.GraphQLError(c.message, {
      nodes: (u = c.nodes) !== null && u !== void 0 ? u : r,
      source: c.source,
      positions: c.positions,
      path: s,
      originalError: c
    });
  }
  function i(t) {
    return Array.isArray(t.path);
  }
  return ot;
}
var Yi;
function vc() {
  return Yi || (Yi = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return n.GraphQLError;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return n.formatError;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return i.locatedError;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return n.printError;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return a.syntaxError;
      }
    });
    var n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ di(), i = /* @__PURE__ */ fi();
  }(Br)), Br;
}
var Yr = {}, an = {}, Ji;
function Tc() {
  if (Ji) return an;
  Ji = 1, Object.defineProperty(an, "__esModule", {
    value: !0
  }), an.versionInfo = an.version = void 0;
  const e = "16.10.0";
  an.version = e;
  const n = Object.freeze({
    major: 16,
    minor: 10,
    patch: 0,
    preReleaseTag: null
  });
  return an.versionInfo = n, an;
}
var Pn = {}, lt = {}, zi;
function Ae() {
  if (zi) return lt;
  zi = 1, Object.defineProperty(lt, "__esModule", {
    value: !0
  }), lt.devAssert = e;
  function e(n, a) {
    if (!!!n)
      throw new Error(a);
  }
  return lt;
}
var pt = {}, Xi;
function mi() {
  if (Xi) return pt;
  Xi = 1, Object.defineProperty(pt, "__esModule", {
    value: !0
  }), pt.isPromise = e;
  function e(n) {
    return typeof (n == null ? void 0 : n.then) == "function";
  }
  return pt;
}
var Ye = {}, Pe = {}, Hi;
function Ze() {
  if (Hi) return Pe;
  Hi = 1, Object.defineProperty(Pe, "__esModule", {
    value: !0
  }), Pe.Token = Pe.QueryDocumentKeys = Pe.OperationTypeNode = Pe.Location = void 0, Pe.isNode = t;
  class e {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(u, c, d) {
      this.start = u.start, this.end = c.end, this.startToken = u, this.endToken = c, this.source = d;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  }
  Pe.Location = e;
  class n {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(u, c, d, m, o, p) {
      this.kind = u, this.start = c, this.end = d, this.line = m, this.column = o, this.value = p, this.prev = null, this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  }
  Pe.Token = n;
  const a = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  Pe.QueryDocumentKeys = a;
  const i = new Set(Object.keys(a));
  function t(s) {
    const u = s == null ? void 0 : s.kind;
    return typeof u == "string" && i.has(u);
  }
  var r;
  return Pe.OperationTypeNode = r, function(s) {
    s.QUERY = "query", s.MUTATION = "mutation", s.SUBSCRIPTION = "subscription";
  }(r || (Pe.OperationTypeNode = r = {})), Pe;
}
var mn = {}, Wi;
function Hn() {
  if (Wi) return mn;
  Wi = 1, Object.defineProperty(mn, "__esModule", {
    value: !0
  }), mn.DirectiveLocation = void 0;
  var e;
  return mn.DirectiveLocation = e, function(n) {
    n.QUERY = "QUERY", n.MUTATION = "MUTATION", n.SUBSCRIPTION = "SUBSCRIPTION", n.FIELD = "FIELD", n.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", n.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", n.INLINE_FRAGMENT = "INLINE_FRAGMENT", n.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", n.SCHEMA = "SCHEMA", n.SCALAR = "SCALAR", n.OBJECT = "OBJECT", n.FIELD_DEFINITION = "FIELD_DEFINITION", n.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", n.INTERFACE = "INTERFACE", n.UNION = "UNION", n.ENUM = "ENUM", n.ENUM_VALUE = "ENUM_VALUE", n.INPUT_OBJECT = "INPUT_OBJECT", n.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
  }(e || (mn.DirectiveLocation = e = {})), mn;
}
var hn = {}, Zi;
function oe() {
  if (Zi) return hn;
  Zi = 1, Object.defineProperty(hn, "__esModule", {
    value: !0
  }), hn.Kind = void 0;
  var e;
  return hn.Kind = e, function(n) {
    n.NAME = "Name", n.DOCUMENT = "Document", n.OPERATION_DEFINITION = "OperationDefinition", n.VARIABLE_DEFINITION = "VariableDefinition", n.SELECTION_SET = "SelectionSet", n.FIELD = "Field", n.ARGUMENT = "Argument", n.FRAGMENT_SPREAD = "FragmentSpread", n.INLINE_FRAGMENT = "InlineFragment", n.FRAGMENT_DEFINITION = "FragmentDefinition", n.VARIABLE = "Variable", n.INT = "IntValue", n.FLOAT = "FloatValue", n.STRING = "StringValue", n.BOOLEAN = "BooleanValue", n.NULL = "NullValue", n.ENUM = "EnumValue", n.LIST = "ListValue", n.OBJECT = "ObjectValue", n.OBJECT_FIELD = "ObjectField", n.DIRECTIVE = "Directive", n.NAMED_TYPE = "NamedType", n.LIST_TYPE = "ListType", n.NON_NULL_TYPE = "NonNullType", n.SCHEMA_DEFINITION = "SchemaDefinition", n.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", n.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", n.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", n.FIELD_DEFINITION = "FieldDefinition", n.INPUT_VALUE_DEFINITION = "InputValueDefinition", n.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", n.UNION_TYPE_DEFINITION = "UnionTypeDefinition", n.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", n.ENUM_VALUE_DEFINITION = "EnumValueDefinition", n.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", n.DIRECTIVE_DEFINITION = "DirectiveDefinition", n.SCHEMA_EXTENSION = "SchemaExtension", n.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", n.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", n.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", n.UNION_TYPE_EXTENSION = "UnionTypeExtension", n.ENUM_TYPE_EXTENSION = "EnumTypeExtension", n.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
  }(e || (hn.Kind = e = {})), hn;
}
var yn = {}, vn = {}, tn = {}, ea;
function hi() {
  if (ea) return tn;
  ea = 1, Object.defineProperty(tn, "__esModule", {
    value: !0
  }), tn.isDigit = n, tn.isLetter = a, tn.isNameContinue = t, tn.isNameStart = i, tn.isWhiteSpace = e;
  function e(r) {
    return r === 9 || r === 32;
  }
  function n(r) {
    return r >= 48 && r <= 57;
  }
  function a(r) {
    return r >= 97 && r <= 122 || // A-Z
    r >= 65 && r <= 90;
  }
  function i(r) {
    return a(r) || r === 95;
  }
  function t(r) {
    return a(r) || n(r) || r === 95;
  }
  return tn;
}
var na;
function Pr() {
  if (na) return vn;
  na = 1, Object.defineProperty(vn, "__esModule", {
    value: !0
  }), vn.dedentBlockStringLines = n, vn.isPrintableAsBlockString = i, vn.printBlockString = t;
  var e = /* @__PURE__ */ hi();
  function n(r) {
    var s;
    let u = Number.MAX_SAFE_INTEGER, c = null, d = -1;
    for (let o = 0; o < r.length; ++o) {
      var m;
      const p = r[o], y = a(p);
      y !== p.length && (c = (m = c) !== null && m !== void 0 ? m : o, d = o, o !== 0 && y < u && (u = y));
    }
    return r.map((o, p) => p === 0 ? o : o.slice(u)).slice(
      (s = c) !== null && s !== void 0 ? s : 0,
      d + 1
    );
  }
  function a(r) {
    let s = 0;
    for (; s < r.length && (0, e.isWhiteSpace)(r.charCodeAt(s)); )
      ++s;
    return s;
  }
  function i(r) {
    if (r === "")
      return !0;
    let s = !0, u = !1, c = !0, d = !1;
    for (let m = 0; m < r.length; ++m)
      switch (r.codePointAt(m)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return !1;
        // Has non-printable characters
        case 13:
          return !1;
        // Has \r or \r\n which will be replaced as \n
        case 10:
          if (s && !d)
            return !1;
          d = !0, s = !0, u = !1;
          break;
        case 9:
        //   \t
        case 32:
          u || (u = s);
          break;
        default:
          c && (c = u), s = !1;
      }
    return !(s || c && d);
  }
  function t(r, s) {
    const u = r.replace(/"""/g, '\\"""'), c = u.split(/\r\n|[\n\r]/g), d = c.length === 1, m = c.length > 1 && c.slice(1).every(
      (O) => O.length === 0 || (0, e.isWhiteSpace)(O.charCodeAt(0))
    ), o = u.endsWith('\\"""'), p = r.endsWith('"') && !o, y = r.endsWith("\\"), l = p || y, f = !(s != null && s.minimize) && // add leading and trailing new lines only if it improves readability
    (!d || r.length > 70 || l || m || o);
    let h = "";
    const T = d && (0, e.isWhiteSpace)(r.charCodeAt(0));
    return (f && !T || m) && (h += `
`), h += u, (f || l) && (h += `
`), '"""' + h + '"""';
  }
  return vn;
}
var Tn = {}, ta;
function Fr() {
  if (ta) return Tn;
  ta = 1, Object.defineProperty(Tn, "__esModule", {
    value: !0
  }), Tn.TokenKind = void 0;
  var e;
  return Tn.TokenKind = e, function(n) {
    n.SOF = "<SOF>", n.EOF = "<EOF>", n.BANG = "!", n.DOLLAR = "$", n.AMP = "&", n.PAREN_L = "(", n.PAREN_R = ")", n.SPREAD = "...", n.COLON = ":", n.EQUALS = "=", n.AT = "@", n.BRACKET_L = "[", n.BRACKET_R = "]", n.BRACE_L = "{", n.PIPE = "|", n.BRACE_R = "}", n.NAME = "Name", n.INT = "Int", n.FLOAT = "Float", n.STRING = "String", n.BLOCK_STRING = "BlockString", n.COMMENT = "Comment";
  }(e || (Tn.TokenKind = e = {})), Tn;
}
var ra;
function yi() {
  if (ra) return yn;
  ra = 1, Object.defineProperty(yn, "__esModule", {
    value: !0
  }), yn.Lexer = void 0, yn.isPunctuatorTokenKind = s;
  var e = /* @__PURE__ */ di(), n = /* @__PURE__ */ Ze(), a = /* @__PURE__ */ Pr(), i = /* @__PURE__ */ hi(), t = /* @__PURE__ */ Fr();
  class r {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(g) {
      const L = new n.Token(
        t.TokenKind.SOF,
        0,
        0,
        0,
        0
      );
      this.source = g, this.lastToken = L, this.token = L, this.line = 1, this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      return this.lastToken = this.token, this.token = this.lookahead();
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let g = this.token;
      if (g.kind !== t.TokenKind.EOF)
        do
          if (g.next)
            g = g.next;
          else {
            const L = y(this, g.end);
            g.next = L, L.prev = g, g = L;
          }
        while (g.kind === t.TokenKind.COMMENT);
      return g;
    }
  }
  yn.Lexer = r;
  function s(N) {
    return N === t.TokenKind.BANG || N === t.TokenKind.DOLLAR || N === t.TokenKind.AMP || N === t.TokenKind.PAREN_L || N === t.TokenKind.PAREN_R || N === t.TokenKind.SPREAD || N === t.TokenKind.COLON || N === t.TokenKind.EQUALS || N === t.TokenKind.AT || N === t.TokenKind.BRACKET_L || N === t.TokenKind.BRACKET_R || N === t.TokenKind.BRACE_L || N === t.TokenKind.PIPE || N === t.TokenKind.BRACE_R;
  }
  function u(N) {
    return N >= 0 && N <= 55295 || N >= 57344 && N <= 1114111;
  }
  function c(N, g) {
    return d(N.charCodeAt(g)) && m(N.charCodeAt(g + 1));
  }
  function d(N) {
    return N >= 55296 && N <= 56319;
  }
  function m(N) {
    return N >= 56320 && N <= 57343;
  }
  function o(N, g) {
    const L = N.source.body.codePointAt(g);
    if (L === void 0)
      return t.TokenKind.EOF;
    if (L >= 32 && L <= 126) {
      const E = String.fromCodePoint(L);
      return E === '"' ? `'"'` : `"${E}"`;
    }
    return "U+" + L.toString(16).toUpperCase().padStart(4, "0");
  }
  function p(N, g, L, E, v) {
    const b = N.line, I = 1 + L - N.lineStart;
    return new n.Token(g, L, E, b, I, v);
  }
  function y(N, g) {
    const L = N.source.body, E = L.length;
    let v = g;
    for (; v < E; ) {
      const b = L.charCodeAt(v);
      switch (b) {
        // Ignored ::
        //   - UnicodeBOM
        //   - WhiteSpace
        //   - LineTerminator
        //   - Comment
        //   - Comma
        //
        // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
        //
        // WhiteSpace ::
        //   - "Horizontal Tab (U+0009)"
        //   - "Space (U+0020)"
        //
        // Comma :: ,
        case 65279:
        // <BOM>
        case 9:
        // \t
        case 32:
        // <space>
        case 44:
          ++v;
          continue;
        // LineTerminator ::
        //   - "New Line (U+000A)"
        //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
        //   - "Carriage Return (U+000D)" "New Line (U+000A)"
        case 10:
          ++v, ++N.line, N.lineStart = v;
          continue;
        case 13:
          L.charCodeAt(v + 1) === 10 ? v += 2 : ++v, ++N.line, N.lineStart = v;
          continue;
        // Comment
        case 35:
          return l(N, v);
        // Token ::
        //   - Punctuator
        //   - Name
        //   - IntValue
        //   - FloatValue
        //   - StringValue
        //
        // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
        case 33:
          return p(
            N,
            t.TokenKind.BANG,
            v,
            v + 1
          );
        case 36:
          return p(
            N,
            t.TokenKind.DOLLAR,
            v,
            v + 1
          );
        case 38:
          return p(
            N,
            t.TokenKind.AMP,
            v,
            v + 1
          );
        case 40:
          return p(
            N,
            t.TokenKind.PAREN_L,
            v,
            v + 1
          );
        case 41:
          return p(
            N,
            t.TokenKind.PAREN_R,
            v,
            v + 1
          );
        case 46:
          if (L.charCodeAt(v + 1) === 46 && L.charCodeAt(v + 2) === 46)
            return p(
              N,
              t.TokenKind.SPREAD,
              v,
              v + 3
            );
          break;
        case 58:
          return p(
            N,
            t.TokenKind.COLON,
            v,
            v + 1
          );
        case 61:
          return p(
            N,
            t.TokenKind.EQUALS,
            v,
            v + 1
          );
        case 64:
          return p(
            N,
            t.TokenKind.AT,
            v,
            v + 1
          );
        case 91:
          return p(
            N,
            t.TokenKind.BRACKET_L,
            v,
            v + 1
          );
        case 93:
          return p(
            N,
            t.TokenKind.BRACKET_R,
            v,
            v + 1
          );
        case 123:
          return p(
            N,
            t.TokenKind.BRACE_L,
            v,
            v + 1
          );
        case 124:
          return p(
            N,
            t.TokenKind.PIPE,
            v,
            v + 1
          );
        case 125:
          return p(
            N,
            t.TokenKind.BRACE_R,
            v,
            v + 1
          );
        // StringValue
        case 34:
          return L.charCodeAt(v + 1) === 34 && L.charCodeAt(v + 2) === 34 ? M(N, v) : T(N, v);
      }
      if ((0, i.isDigit)(b) || b === 45)
        return f(N, v, b);
      if ((0, i.isNameStart)(b))
        return V(N, v);
      throw (0, e.syntaxError)(
        N.source,
        v,
        b === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : u(b) || c(L, v) ? `Unexpected character: ${o(N, v)}.` : `Invalid character: ${o(N, v)}.`
      );
    }
    return p(N, t.TokenKind.EOF, E, E);
  }
  function l(N, g) {
    const L = N.source.body, E = L.length;
    let v = g + 1;
    for (; v < E; ) {
      const b = L.charCodeAt(v);
      if (b === 10 || b === 13)
        break;
      if (u(b))
        ++v;
      else if (c(L, v))
        v += 2;
      else
        break;
    }
    return p(
      N,
      t.TokenKind.COMMENT,
      g,
      v,
      L.slice(g + 1, v)
    );
  }
  function f(N, g, L) {
    const E = N.source.body;
    let v = g, b = L, I = !1;
    if (b === 45 && (b = E.charCodeAt(++v)), b === 48) {
      if (b = E.charCodeAt(++v), (0, i.isDigit)(b))
        throw (0, e.syntaxError)(
          N.source,
          v,
          `Invalid number, unexpected digit after 0: ${o(
            N,
            v
          )}.`
        );
    } else
      v = h(N, v, b), b = E.charCodeAt(v);
    if (b === 46 && (I = !0, b = E.charCodeAt(++v), v = h(N, v, b), b = E.charCodeAt(v)), (b === 69 || b === 101) && (I = !0, b = E.charCodeAt(++v), (b === 43 || b === 45) && (b = E.charCodeAt(++v)), v = h(N, v, b), b = E.charCodeAt(v)), b === 46 || (0, i.isNameStart)(b))
      throw (0, e.syntaxError)(
        N.source,
        v,
        `Invalid number, expected digit but got: ${o(
          N,
          v
        )}.`
      );
    return p(
      N,
      I ? t.TokenKind.FLOAT : t.TokenKind.INT,
      g,
      v,
      E.slice(g, v)
    );
  }
  function h(N, g, L) {
    if (!(0, i.isDigit)(L))
      throw (0, e.syntaxError)(
        N.source,
        g,
        `Invalid number, expected digit but got: ${o(
          N,
          g
        )}.`
      );
    const E = N.source.body;
    let v = g + 1;
    for (; (0, i.isDigit)(E.charCodeAt(v)); )
      ++v;
    return v;
  }
  function T(N, g) {
    const L = N.source.body, E = L.length;
    let v = g + 1, b = v, I = "";
    for (; v < E; ) {
      const S = L.charCodeAt(v);
      if (S === 34)
        return I += L.slice(b, v), p(
          N,
          t.TokenKind.STRING,
          g,
          v + 1,
          I
        );
      if (S === 92) {
        I += L.slice(b, v);
        const j = L.charCodeAt(v + 1) === 117 ? L.charCodeAt(v + 2) === 123 ? O(N, v) : R(N, v) : w(N, v);
        I += j.value, v += j.size, b = v;
        continue;
      }
      if (S === 10 || S === 13)
        break;
      if (u(S))
        ++v;
      else if (c(L, v))
        v += 2;
      else
        throw (0, e.syntaxError)(
          N.source,
          v,
          `Invalid character within String: ${o(
            N,
            v
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      N.source,
      v,
      "Unterminated string."
    );
  }
  function O(N, g) {
    const L = N.source.body;
    let E = 0, v = 3;
    for (; v < 12; ) {
      const b = L.charCodeAt(g + v++);
      if (b === 125) {
        if (v < 5 || !u(E))
          break;
        return {
          value: String.fromCodePoint(E),
          size: v
        };
      }
      if (E = E << 4 | _(b), E < 0)
        break;
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid Unicode escape sequence: "${L.slice(
        g,
        g + v
      )}".`
    );
  }
  function R(N, g) {
    const L = N.source.body, E = D(L, g + 2);
    if (u(E))
      return {
        value: String.fromCodePoint(E),
        size: 6
      };
    if (d(E) && L.charCodeAt(g + 6) === 92 && L.charCodeAt(g + 7) === 117) {
      const v = D(L, g + 8);
      if (m(v))
        return {
          value: String.fromCodePoint(E, v),
          size: 12
        };
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid Unicode escape sequence: "${L.slice(g, g + 6)}".`
    );
  }
  function D(N, g) {
    return _(N.charCodeAt(g)) << 12 | _(N.charCodeAt(g + 1)) << 8 | _(N.charCodeAt(g + 2)) << 4 | _(N.charCodeAt(g + 3));
  }
  function _(N) {
    return N >= 48 && N <= 57 ? N - 48 : N >= 65 && N <= 70 ? N - 55 : N >= 97 && N <= 102 ? N - 87 : -1;
  }
  function w(N, g) {
    const L = N.source.body;
    switch (L.charCodeAt(g + 1)) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: `
`,
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid character escape sequence: "${L.slice(
        g,
        g + 2
      )}".`
    );
  }
  function M(N, g) {
    const L = N.source.body, E = L.length;
    let v = N.lineStart, b = g + 3, I = b, S = "";
    const j = [];
    for (; b < E; ) {
      const k = L.charCodeAt(b);
      if (k === 34 && L.charCodeAt(b + 1) === 34 && L.charCodeAt(b + 2) === 34) {
        S += L.slice(I, b), j.push(S);
        const U = p(
          N,
          t.TokenKind.BLOCK_STRING,
          g,
          b + 3,
          // Return a string of the lines joined with U+000A.
          (0, a.dedentBlockStringLines)(j).join(`
`)
        );
        return N.line += j.length - 1, N.lineStart = v, U;
      }
      if (k === 92 && L.charCodeAt(b + 1) === 34 && L.charCodeAt(b + 2) === 34 && L.charCodeAt(b + 3) === 34) {
        S += L.slice(I, b), I = b + 1, b += 4;
        continue;
      }
      if (k === 10 || k === 13) {
        S += L.slice(I, b), j.push(S), k === 13 && L.charCodeAt(b + 1) === 10 ? b += 2 : ++b, S = "", I = b, v = b;
        continue;
      }
      if (u(k))
        ++b;
      else if (c(L, b))
        b += 2;
      else
        throw (0, e.syntaxError)(
          N.source,
          b,
          `Invalid character within String: ${o(
            N,
            b
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      N.source,
      b,
      "Unterminated string."
    );
  }
  function V(N, g) {
    const L = N.source.body, E = L.length;
    let v = g + 1;
    for (; v < E; ) {
      const b = L.charCodeAt(v);
      if ((0, i.isNameContinue)(b))
        ++v;
      else
        break;
    }
    return p(
      N,
      t.TokenKind.NAME,
      g,
      v,
      L.slice(g, v)
    );
  }
  return yn;
}
var bn = {}, Fn = {}, ia;
function wr() {
  if (ia) return Fn;
  ia = 1, Object.defineProperty(Fn, "__esModule", {
    value: !0
  }), Fn.instanceOf = void 0;
  var e = /* @__PURE__ */ fe();
  const a = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    globalThis.process && // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production" ? function(t, r) {
      return t instanceof r;
    } : function(t, r) {
      if (t instanceof r)
        return !0;
      if (typeof t == "object" && t !== null) {
        var s;
        const u = r.prototype[Symbol.toStringTag], c = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in t ? t[Symbol.toStringTag] : (s = t.constructor) === null || s === void 0 ? void 0 : s.name
        );
        if (u === c) {
          const d = (0, e.inspect)(t);
          throw new Error(`Cannot use ${u} "${d}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return !1;
    }
  );
  return Fn.instanceOf = a, Fn;
}
var aa;
function vi() {
  if (aa) return bn;
  aa = 1, Object.defineProperty(bn, "__esModule", {
    value: !0
  }), bn.Source = void 0, bn.isSource = t;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ wr();
  class i {
    constructor(s, u = "GraphQL request", c = {
      line: 1,
      column: 1
    }) {
      typeof s == "string" || (0, e.devAssert)(
        !1,
        `Body must be a string. Received: ${(0, n.inspect)(s)}.`
      ), this.body = s, this.name = u, this.locationOffset = c, this.locationOffset.line > 0 || (0, e.devAssert)(
        !1,
        "line in locationOffset is 1-indexed and must be positive."
      ), this.locationOffset.column > 0 || (0, e.devAssert)(
        !1,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  }
  bn.Source = i;
  function t(r) {
    return (0, a.instanceOf)(r, i);
  }
  return bn;
}
var sa;
function Wn() {
  if (sa) return Ye;
  sa = 1, Object.defineProperty(Ye, "__esModule", {
    value: !0
  }), Ye.Parser = void 0, Ye.parse = u, Ye.parseConstValue = d, Ye.parseType = m, Ye.parseValue = c;
  var e = /* @__PURE__ */ di(), n = /* @__PURE__ */ Ze(), a = /* @__PURE__ */ Hn(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ yi(), r = /* @__PURE__ */ vi(), s = /* @__PURE__ */ Fr();
  function u(l, f) {
    const h = new o(l, f), T = h.parseDocument();
    return Object.defineProperty(T, "tokenCount", {
      enumerable: !1,
      value: h.tokenCount
    }), T;
  }
  function c(l, f) {
    const h = new o(l, f);
    h.expectToken(s.TokenKind.SOF);
    const T = h.parseValueLiteral(!1);
    return h.expectToken(s.TokenKind.EOF), T;
  }
  function d(l, f) {
    const h = new o(l, f);
    h.expectToken(s.TokenKind.SOF);
    const T = h.parseConstValueLiteral();
    return h.expectToken(s.TokenKind.EOF), T;
  }
  function m(l, f) {
    const h = new o(l, f);
    h.expectToken(s.TokenKind.SOF);
    const T = h.parseTypeReference();
    return h.expectToken(s.TokenKind.EOF), T;
  }
  class o {
    constructor(f, h = {}) {
      const T = (0, r.isSource)(f) ? f : new r.Source(f);
      this._lexer = new t.Lexer(T), this._options = h, this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const f = this.expectToken(s.TokenKind.NAME);
      return this.node(f, {
        kind: i.Kind.NAME,
        value: f.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: i.Kind.DOCUMENT,
        definitions: this.many(
          s.TokenKind.SOF,
          this.parseDefinition,
          s.TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(s.TokenKind.BRACE_L))
        return this.parseOperationDefinition();
      const f = this.peekDescription(), h = f ? this._lexer.lookahead() : this._lexer.token;
      if (h.kind === s.TokenKind.NAME) {
        switch (h.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (f)
          throw (0, e.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        switch (h.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(h);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const f = this._lexer.token;
      if (this.peek(s.TokenKind.BRACE_L))
        return this.node(f, {
          kind: i.Kind.OPERATION_DEFINITION,
          operation: n.OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      const h = this.parseOperationType();
      let T;
      return this.peek(s.TokenKind.NAME) && (T = this.parseName()), this.node(f, {
        kind: i.Kind.OPERATION_DEFINITION,
        operation: h,
        name: T,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const f = this.expectToken(s.TokenKind.NAME);
      switch (f.value) {
        case "query":
          return n.OperationTypeNode.QUERY;
        case "mutation":
          return n.OperationTypeNode.MUTATION;
        case "subscription":
          return n.OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(f);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        this.parseVariableDefinition,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: i.Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(s.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(s.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const f = this._lexer.token;
      return this.expectToken(s.TokenKind.DOLLAR), this.node(f, {
        kind: i.Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: i.Kind.SELECTION_SET,
        selections: this.many(
          s.TokenKind.BRACE_L,
          this.parseSelection,
          s.TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(s.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const f = this._lexer.token, h = this.parseName();
      let T, O;
      return this.expectOptionalToken(s.TokenKind.COLON) ? (T = h, O = this.parseName()) : O = h, this.node(f, {
        kind: i.Kind.FIELD,
        alias: T,
        name: O,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(s.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(f) {
      const h = f ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        h,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(f = !1) {
      const h = this._lexer.token, T = this.parseName();
      return this.expectToken(s.TokenKind.COLON), this.node(h, {
        kind: i.Kind.ARGUMENT,
        name: T,
        value: this.parseValueLiteral(f)
      });
    }
    parseConstArgument() {
      return this.parseArgument(!0);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const f = this._lexer.token;
      this.expectToken(s.TokenKind.SPREAD);
      const h = this.expectOptionalKeyword("on");
      return !h && this.peek(s.TokenKind.NAME) ? this.node(f, {
        kind: i.Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1)
      }) : this.node(f, {
        kind: i.Kind.INLINE_FRAGMENT,
        typeCondition: h ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const f = this._lexer.token;
      return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(f, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      }) : this.node(f, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on")
        throw this.unexpected();
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(f) {
      const h = this._lexer.token;
      switch (h.kind) {
        case s.TokenKind.BRACKET_L:
          return this.parseList(f);
        case s.TokenKind.BRACE_L:
          return this.parseObject(f);
        case s.TokenKind.INT:
          return this.advanceLexer(), this.node(h, {
            kind: i.Kind.INT,
            value: h.value
          });
        case s.TokenKind.FLOAT:
          return this.advanceLexer(), this.node(h, {
            kind: i.Kind.FLOAT,
            value: h.value
          });
        case s.TokenKind.STRING:
        case s.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case s.TokenKind.NAME:
          switch (this.advanceLexer(), h.value) {
            case "true":
              return this.node(h, {
                kind: i.Kind.BOOLEAN,
                value: !0
              });
            case "false":
              return this.node(h, {
                kind: i.Kind.BOOLEAN,
                value: !1
              });
            case "null":
              return this.node(h, {
                kind: i.Kind.NULL
              });
            default:
              return this.node(h, {
                kind: i.Kind.ENUM,
                value: h.value
              });
          }
        case s.TokenKind.DOLLAR:
          if (f)
            if (this.expectToken(s.TokenKind.DOLLAR), this._lexer.token.kind === s.TokenKind.NAME) {
              const T = this._lexer.token.value;
              throw (0, e.syntaxError)(
                this._lexer.source,
                h.start,
                `Unexpected variable "$${T}" in constant value.`
              );
            } else
              throw this.unexpected(h);
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(!0);
    }
    parseStringLiteral() {
      const f = this._lexer.token;
      return this.advanceLexer(), this.node(f, {
        kind: i.Kind.STRING,
        value: f.value,
        block: f.kind === s.TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(f) {
      const h = () => this.parseValueLiteral(f);
      return this.node(this._lexer.token, {
        kind: i.Kind.LIST,
        values: this.any(
          s.TokenKind.BRACKET_L,
          h,
          s.TokenKind.BRACKET_R
        )
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(f) {
      const h = () => this.parseObjectField(f);
      return this.node(this._lexer.token, {
        kind: i.Kind.OBJECT,
        fields: this.any(
          s.TokenKind.BRACE_L,
          h,
          s.TokenKind.BRACE_R
        )
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(f) {
      const h = this._lexer.token, T = this.parseName();
      return this.expectToken(s.TokenKind.COLON), this.node(h, {
        kind: i.Kind.OBJECT_FIELD,
        name: T,
        value: this.parseValueLiteral(f)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(f) {
      const h = [];
      for (; this.peek(s.TokenKind.AT); )
        h.push(this.parseDirective(f));
      return h;
    }
    parseConstDirectives() {
      return this.parseDirectives(!0);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(f) {
      const h = this._lexer.token;
      return this.expectToken(s.TokenKind.AT), this.node(h, {
        kind: i.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(f)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const f = this._lexer.token;
      let h;
      if (this.expectOptionalToken(s.TokenKind.BRACKET_L)) {
        const T = this.parseTypeReference();
        this.expectToken(s.TokenKind.BRACKET_R), h = this.node(f, {
          kind: i.Kind.LIST_TYPE,
          type: T
        });
      } else
        h = this.parseNamedType();
      return this.expectOptionalToken(s.TokenKind.BANG) ? this.node(f, {
        kind: i.Kind.NON_NULL_TYPE,
        type: h
      }) : h;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: i.Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(s.TokenKind.STRING) || this.peek(s.TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription())
        return this.parseStringLiteral();
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("schema");
      const T = this.parseConstDirectives(), O = this.many(
        s.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        s.TokenKind.BRACE_R
      );
      return this.node(f, {
        kind: i.Kind.SCHEMA_DEFINITION,
        description: h,
        directives: T,
        operationTypes: O
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const f = this._lexer.token, h = this.parseOperationType();
      this.expectToken(s.TokenKind.COLON);
      const T = this.parseNamedType();
      return this.node(f, {
        kind: i.Kind.OPERATION_TYPE_DEFINITION,
        operation: h,
        type: T
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("scalar");
      const T = this.parseName(), O = this.parseConstDirectives();
      return this.node(f, {
        kind: i.Kind.SCALAR_TYPE_DEFINITION,
        description: h,
        name: T,
        directives: O
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("type");
      const T = this.parseName(), O = this.parseImplementsInterfaces(), R = this.parseConstDirectives(), D = this.parseFieldsDefinition();
      return this.node(f, {
        kind: i.Kind.OBJECT_TYPE_DEFINITION,
        description: h,
        name: T,
        interfaces: O,
        directives: R,
        fields: D
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(s.TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseFieldDefinition,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const f = this._lexer.token, h = this.parseDescription(), T = this.parseName(), O = this.parseArgumentDefs();
      this.expectToken(s.TokenKind.COLON);
      const R = this.parseTypeReference(), D = this.parseConstDirectives();
      return this.node(f, {
        kind: i.Kind.FIELD_DEFINITION,
        description: h,
        name: T,
        arguments: O,
        type: R,
        directives: D
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        s.TokenKind.PAREN_L,
        this.parseInputValueDef,
        s.TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const f = this._lexer.token, h = this.parseDescription(), T = this.parseName();
      this.expectToken(s.TokenKind.COLON);
      const O = this.parseTypeReference();
      let R;
      this.expectOptionalToken(s.TokenKind.EQUALS) && (R = this.parseConstValueLiteral());
      const D = this.parseConstDirectives();
      return this.node(f, {
        kind: i.Kind.INPUT_VALUE_DEFINITION,
        description: h,
        name: T,
        type: O,
        defaultValue: R,
        directives: D
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("interface");
      const T = this.parseName(), O = this.parseImplementsInterfaces(), R = this.parseConstDirectives(), D = this.parseFieldsDefinition();
      return this.node(f, {
        kind: i.Kind.INTERFACE_TYPE_DEFINITION,
        description: h,
        name: T,
        interfaces: O,
        directives: R,
        fields: D
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("union");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseUnionMemberTypes();
      return this.node(f, {
        kind: i.Kind.UNION_TYPE_DEFINITION,
        description: h,
        name: T,
        directives: O,
        types: R
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(s.TokenKind.EQUALS) ? this.delimitedMany(s.TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("enum");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseEnumValuesDefinition();
      return this.node(f, {
        kind: i.Kind.ENUM_TYPE_DEFINITION,
        description: h,
        name: T,
        directives: O,
        values: R
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const f = this._lexer.token, h = this.parseDescription(), T = this.parseEnumValueName(), O = this.parseConstDirectives();
      return this.node(f, {
        kind: i.Kind.ENUM_VALUE_DEFINITION,
        description: h,
        name: T,
        directives: O
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
        throw (0, e.syntaxError)(
          this._lexer.source,
          this._lexer.token.start,
          `${p(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("input");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseInputFieldsDefinition();
      return this.node(f, {
        kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: h,
        name: T,
        directives: O,
        fields: R
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseInputValueDef,
        s.TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const f = this._lexer.lookahead();
      if (f.kind === s.TokenKind.NAME)
        switch (f.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      throw this.unexpected(f);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("schema");
      const h = this.parseConstDirectives(), T = this.optionalMany(
        s.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        s.TokenKind.BRACE_R
      );
      if (h.length === 0 && T.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.SCHEMA_EXTENSION,
        directives: h,
        operationTypes: T
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("scalar");
      const h = this.parseName(), T = this.parseConstDirectives();
      if (T.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.SCALAR_TYPE_EXTENSION,
        name: h,
        directives: T
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("type");
      const h = this.parseName(), T = this.parseImplementsInterfaces(), O = this.parseConstDirectives(), R = this.parseFieldsDefinition();
      if (T.length === 0 && O.length === 0 && R.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.OBJECT_TYPE_EXTENSION,
        name: h,
        interfaces: T,
        directives: O,
        fields: R
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("interface");
      const h = this.parseName(), T = this.parseImplementsInterfaces(), O = this.parseConstDirectives(), R = this.parseFieldsDefinition();
      if (T.length === 0 && O.length === 0 && R.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.INTERFACE_TYPE_EXTENSION,
        name: h,
        interfaces: T,
        directives: O,
        fields: R
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("union");
      const h = this.parseName(), T = this.parseConstDirectives(), O = this.parseUnionMemberTypes();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.UNION_TYPE_EXTENSION,
        name: h,
        directives: T,
        types: O
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("enum");
      const h = this.parseName(), T = this.parseConstDirectives(), O = this.parseEnumValuesDefinition();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.ENUM_TYPE_EXTENSION,
        name: h,
        directives: T,
        values: O
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const f = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("input");
      const h = this.parseName(), T = this.parseConstDirectives(), O = this.parseInputFieldsDefinition();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(f, {
        kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name: h,
        directives: T,
        fields: O
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const f = this._lexer.token, h = this.parseDescription();
      this.expectKeyword("directive"), this.expectToken(s.TokenKind.AT);
      const T = this.parseName(), O = this.parseArgumentDefs(), R = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const D = this.parseDirectiveLocations();
      return this.node(f, {
        kind: i.Kind.DIRECTIVE_DEFINITION,
        description: h,
        name: T,
        arguments: O,
        repeatable: R,
        locations: D
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(
        s.TokenKind.PIPE,
        this.parseDirectiveLocation
      );
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const f = this._lexer.token, h = this.parseName();
      if (Object.prototype.hasOwnProperty.call(
        a.DirectiveLocation,
        h.value
      ))
        return h;
      throw this.unexpected(f);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(f, h) {
      return this._options.noLocation !== !0 && (h.loc = new n.Location(
        f,
        this._lexer.lastToken,
        this._lexer.source
      )), h;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(f) {
      return this._lexer.token.kind === f;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(f) {
      const h = this._lexer.token;
      if (h.kind === f)
        return this.advanceLexer(), h;
      throw (0, e.syntaxError)(
        this._lexer.source,
        h.start,
        `Expected ${y(f)}, found ${p(h)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(f) {
      return this._lexer.token.kind === f ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(f) {
      const h = this._lexer.token;
      if (h.kind === s.TokenKind.NAME && h.value === f)
        this.advanceLexer();
      else
        throw (0, e.syntaxError)(
          this._lexer.source,
          h.start,
          `Expected "${f}", found ${p(h)}.`
        );
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(f) {
      const h = this._lexer.token;
      return h.kind === s.TokenKind.NAME && h.value === f ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(f) {
      const h = f ?? this._lexer.token;
      return (0, e.syntaxError)(
        this._lexer.source,
        h.start,
        `Unexpected ${p(h)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(f, h, T) {
      this.expectToken(f);
      const O = [];
      for (; !this.expectOptionalToken(T); )
        O.push(h.call(this));
      return O;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(f, h, T) {
      if (this.expectOptionalToken(f)) {
        const O = [];
        do
          O.push(h.call(this));
        while (!this.expectOptionalToken(T));
        return O;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(f, h, T) {
      this.expectToken(f);
      const O = [];
      do
        O.push(h.call(this));
      while (!this.expectOptionalToken(T));
      return O;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(f, h) {
      this.expectOptionalToken(f);
      const T = [];
      do
        T.push(h.call(this));
      while (this.expectOptionalToken(f));
      return T;
    }
    advanceLexer() {
      const { maxTokens: f } = this._options, h = this._lexer.advance();
      if (h.kind !== s.TokenKind.EOF && (++this._tokenCounter, f !== void 0 && this._tokenCounter > f))
        throw (0, e.syntaxError)(
          this._lexer.source,
          h.start,
          `Document contains more that ${f} tokens. Parsing aborted.`
        );
    }
  }
  Ye.Parser = o;
  function p(l) {
    const f = l.value;
    return y(l.kind) + (f != null ? ` "${f}"` : "");
  }
  function y(l) {
    return (0, t.isPunctuatorTokenKind)(l) ? `"${l}"` : l;
  }
  return Ye;
}
var wn = {}, gn = {}, H = {}, dt = {}, oa;
function cn() {
  if (oa) return dt;
  oa = 1, Object.defineProperty(dt, "__esModule", {
    value: !0
  }), dt.didYouMean = n;
  const e = 5;
  function n(a, i) {
    const [t, r] = i ? [a, i] : [void 0, a];
    let s = " Did you mean ";
    t && (s += t + " ");
    const u = r.map((m) => `"${m}"`);
    switch (u.length) {
      case 0:
        return "";
      case 1:
        return s + u[0] + "?";
      case 2:
        return s + u[0] + " or " + u[1] + "?";
    }
    const c = u.slice(0, e), d = c.pop();
    return s + c.join(", ") + ", or " + d + "?";
  }
  return dt;
}
var ft = {}, ua;
function bc() {
  if (ua) return ft;
  ua = 1, Object.defineProperty(ft, "__esModule", {
    value: !0
  }), ft.identityFunc = e;
  function e(n) {
    return n;
  }
  return ft;
}
var mt = {}, ca;
function ln() {
  if (ca) return mt;
  ca = 1, Object.defineProperty(mt, "__esModule", {
    value: !0
  }), mt.keyMap = e;
  function e(n, a) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of n)
      i[a(t)] = t;
    return i;
  }
  return mt;
}
var ht = {}, la;
function kr() {
  if (la) return ht;
  la = 1, Object.defineProperty(ht, "__esModule", {
    value: !0
  }), ht.keyValMap = e;
  function e(n, a, i) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const r of n)
      t[a(r)] = i(r);
    return t;
  }
  return ht;
}
var yt = {}, pa;
function No() {
  if (pa) return yt;
  pa = 1, Object.defineProperty(yt, "__esModule", {
    value: !0
  }), yt.mapValue = e;
  function e(n, a) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of Object.keys(n))
      i[t] = a(n[t], t);
    return i;
  }
  return yt;
}
var vt = {}, Tt = {}, da;
function Vr() {
  if (da) return Tt;
  da = 1, Object.defineProperty(Tt, "__esModule", {
    value: !0
  }), Tt.naturalCompare = e;
  function e(t, r) {
    let s = 0, u = 0;
    for (; s < t.length && u < r.length; ) {
      let c = t.charCodeAt(s), d = r.charCodeAt(u);
      if (i(c) && i(d)) {
        let m = 0;
        do
          ++s, m = m * 10 + c - n, c = t.charCodeAt(s);
        while (i(c) && m > 0);
        let o = 0;
        do
          ++u, o = o * 10 + d - n, d = r.charCodeAt(u);
        while (i(d) && o > 0);
        if (m < o)
          return -1;
        if (m > o)
          return 1;
      } else {
        if (c < d)
          return -1;
        if (c > d)
          return 1;
        ++s, ++u;
      }
    }
    return t.length - r.length;
  }
  const n = 48, a = 57;
  function i(t) {
    return !isNaN(t) && n <= t && t <= a;
  }
  return Tt;
}
var fa;
function pn() {
  if (fa) return vt;
  fa = 1, Object.defineProperty(vt, "__esModule", {
    value: !0
  }), vt.suggestionList = n;
  var e = /* @__PURE__ */ Vr();
  function n(t, r) {
    const s = /* @__PURE__ */ Object.create(null), u = new a(t), c = Math.floor(t.length * 0.4) + 1;
    for (const d of r) {
      const m = u.measure(d, c);
      m !== void 0 && (s[d] = m);
    }
    return Object.keys(s).sort((d, m) => {
      const o = s[d] - s[m];
      return o !== 0 ? o : (0, e.naturalCompare)(d, m);
    });
  }
  class a {
    constructor(r) {
      this._input = r, this._inputLowerCase = r.toLowerCase(), this._inputArray = i(this._inputLowerCase), this._rows = [
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0)
      ];
    }
    measure(r, s) {
      if (this._input === r)
        return 0;
      const u = r.toLowerCase();
      if (this._inputLowerCase === u)
        return 1;
      let c = i(u), d = this._inputArray;
      if (c.length < d.length) {
        const l = c;
        c = d, d = l;
      }
      const m = c.length, o = d.length;
      if (m - o > s)
        return;
      const p = this._rows;
      for (let l = 0; l <= o; l++)
        p[0][l] = l;
      for (let l = 1; l <= m; l++) {
        const f = p[(l - 1) % 3], h = p[l % 3];
        let T = h[0] = l;
        for (let O = 1; O <= o; O++) {
          const R = c[l - 1] === d[O - 1] ? 0 : 1;
          let D = Math.min(
            f[O] + 1,
            // delete
            h[O - 1] + 1,
            // insert
            f[O - 1] + R
            // substitute
          );
          if (l > 1 && O > 1 && c[l - 1] === d[O - 2] && c[l - 2] === d[O - 1]) {
            const _ = p[(l - 2) % 3][O - 2];
            D = Math.min(D, _ + 1);
          }
          D < T && (T = D), h[O] = D;
        }
        if (T > s)
          return;
      }
      const y = p[m % 3][o];
      return y <= s ? y : void 0;
    }
  }
  function i(t) {
    const r = t.length, s = new Array(r);
    for (let u = 0; u < r; ++u)
      s[u] = t.charCodeAt(u);
    return s;
  }
  return vt;
}
var bt = {}, ma;
function Ti() {
  if (ma) return bt;
  ma = 1, Object.defineProperty(bt, "__esModule", {
    value: !0
  }), bt.toObjMap = e;
  function e(n) {
    if (n == null)
      return /* @__PURE__ */ Object.create(null);
    if (Object.getPrototypeOf(n) === null)
      return n;
    const a = /* @__PURE__ */ Object.create(null);
    for (const [i, t] of Object.entries(n))
      a[i] = t;
    return a;
  }
  return bt;
}
var gt = {}, Et = {}, ha;
function gc() {
  if (ha) return Et;
  ha = 1, Object.defineProperty(Et, "__esModule", {
    value: !0
  }), Et.printString = e;
  function e(t) {
    return `"${t.replace(n, a)}"`;
  }
  const n = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function a(t) {
    return i[t.charCodeAt(0)];
  }
  const i = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];
  return Et;
}
var Je = {}, ya;
function Ln() {
  if (ya) return Je;
  ya = 1, Object.defineProperty(Je, "__esModule", {
    value: !0
  }), Je.BREAK = void 0, Je.getEnterLeaveForKind = u, Je.getVisitFn = c, Je.visit = r, Je.visitInParallel = s;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Ze(), i = /* @__PURE__ */ oe();
  const t = Object.freeze({});
  Je.BREAK = t;
  function r(d, m, o = a.QueryDocumentKeys) {
    const p = /* @__PURE__ */ new Map();
    for (const g of Object.values(i.Kind))
      p.set(g, u(m, g));
    let y, l = Array.isArray(d), f = [d], h = -1, T = [], O = d, R, D;
    const _ = [], w = [];
    do {
      h++;
      const g = h === f.length, L = g && T.length !== 0;
      if (g) {
        if (R = w.length === 0 ? void 0 : _[_.length - 1], O = D, D = w.pop(), L)
          if (l) {
            O = O.slice();
            let v = 0;
            for (const [b, I] of T) {
              const S = b - v;
              I === null ? (O.splice(S, 1), v++) : O[S] = I;
            }
          } else {
            O = Object.defineProperties(
              {},
              Object.getOwnPropertyDescriptors(O)
            );
            for (const [v, b] of T)
              O[v] = b;
          }
        h = y.index, f = y.keys, T = y.edits, l = y.inArray, y = y.prev;
      } else if (D) {
        if (R = l ? h : f[h], O = D[R], O == null)
          continue;
        _.push(R);
      }
      let E;
      if (!Array.isArray(O)) {
        var M, V;
        (0, a.isNode)(O) || (0, e.devAssert)(
          !1,
          `Invalid AST Node: ${(0, n.inspect)(O)}.`
        );
        const v = g ? (M = p.get(O.kind)) === null || M === void 0 ? void 0 : M.leave : (V = p.get(O.kind)) === null || V === void 0 ? void 0 : V.enter;
        if (E = v == null ? void 0 : v.call(m, O, R, D, _, w), E === t)
          break;
        if (E === !1) {
          if (!g) {
            _.pop();
            continue;
          }
        } else if (E !== void 0 && (T.push([R, E]), !g))
          if ((0, a.isNode)(E))
            O = E;
          else {
            _.pop();
            continue;
          }
      }
      if (E === void 0 && L && T.push([R, O]), g)
        _.pop();
      else {
        var N;
        y = {
          inArray: l,
          index: h,
          keys: f,
          edits: T,
          prev: y
        }, l = Array.isArray(O), f = l ? O : (N = o[O.kind]) !== null && N !== void 0 ? N : [], h = -1, T = [], D && w.push(D), D = O;
      }
    } while (y !== void 0);
    return T.length !== 0 ? T[T.length - 1][1] : d;
  }
  function s(d) {
    const m = new Array(d.length).fill(null), o = /* @__PURE__ */ Object.create(null);
    for (const p of Object.values(i.Kind)) {
      let y = !1;
      const l = new Array(d.length).fill(void 0), f = new Array(d.length).fill(void 0);
      for (let T = 0; T < d.length; ++T) {
        const { enter: O, leave: R } = u(d[T], p);
        y || (y = O != null || R != null), l[T] = O, f[T] = R;
      }
      if (!y)
        continue;
      const h = {
        enter(...T) {
          const O = T[0];
          for (let D = 0; D < d.length; D++)
            if (m[D] === null) {
              var R;
              const _ = (R = l[D]) === null || R === void 0 ? void 0 : R.apply(d[D], T);
              if (_ === !1)
                m[D] = O;
              else if (_ === t)
                m[D] = t;
              else if (_ !== void 0)
                return _;
            }
        },
        leave(...T) {
          const O = T[0];
          for (let D = 0; D < d.length; D++)
            if (m[D] === null) {
              var R;
              const _ = (R = f[D]) === null || R === void 0 ? void 0 : R.apply(d[D], T);
              if (_ === t)
                m[D] = t;
              else if (_ !== void 0 && _ !== !1)
                return _;
            } else m[D] === O && (m[D] = null);
        }
      };
      o[p] = h;
    }
    return o;
  }
  function u(d, m) {
    const o = d[m];
    return typeof o == "object" ? o : typeof o == "function" ? {
      enter: o,
      leave: void 0
    } : {
      enter: d.enter,
      leave: d.leave
    };
  }
  function c(d, m, o) {
    const { enter: p, leave: y } = u(d, m);
    return o ? y : p;
  }
  return Je;
}
var va;
function Ge() {
  if (va) return gt;
  va = 1, Object.defineProperty(gt, "__esModule", {
    value: !0
  }), gt.print = i;
  var e = /* @__PURE__ */ Pr(), n = /* @__PURE__ */ gc(), a = /* @__PURE__ */ Ln();
  function i(o) {
    return (0, a.visit)(o, r);
  }
  const t = 80, r = {
    Name: {
      leave: (o) => o.value
    },
    Variable: {
      leave: (o) => "$" + o.name
    },
    // Document
    Document: {
      leave: (o) => s(o.definitions, `

`)
    },
    OperationDefinition: {
      leave(o) {
        const p = c("(", s(o.variableDefinitions, ", "), ")"), y = s(
          [
            o.operation,
            s([o.name, p]),
            s(o.directives, " ")
          ],
          " "
        );
        return (y === "query" ? "" : y + " ") + o.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable: o, type: p, defaultValue: y, directives: l }) => o + ": " + p + c(" = ", y) + c(" ", s(l, " "))
    },
    SelectionSet: {
      leave: ({ selections: o }) => u(o)
    },
    Field: {
      leave({ alias: o, name: p, arguments: y, directives: l, selectionSet: f }) {
        const h = c("", o, ": ") + p;
        let T = h + c("(", s(y, ", "), ")");
        return T.length > t && (T = h + c(`(
`, d(s(y, `
`)), `
)`)), s([T, s(l, " "), f], " ");
      }
    },
    Argument: {
      leave: ({ name: o, value: p }) => o + ": " + p
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name: o, directives: p }) => "..." + o + c(" ", s(p, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition: o, directives: p, selectionSet: y }) => s(
        [
          "...",
          c("on ", o),
          s(p, " "),
          y
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({ name: o, typeCondition: p, variableDefinitions: y, directives: l, selectionSet: f }) => (
        // or removed in the future.
        `fragment ${o}${c("(", s(y, ", "), ")")} on ${p} ${c("", s(l, " "), " ")}` + f
      )
    },
    // Value
    IntValue: {
      leave: ({ value: o }) => o
    },
    FloatValue: {
      leave: ({ value: o }) => o
    },
    StringValue: {
      leave: ({ value: o, block: p }) => p ? (0, e.printBlockString)(o) : (0, n.printString)(o)
    },
    BooleanValue: {
      leave: ({ value: o }) => o ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value: o }) => o
    },
    ListValue: {
      leave: ({ values: o }) => "[" + s(o, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields: o }) => "{" + s(o, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name: o, value: p }) => o + ": " + p
    },
    // Directive
    Directive: {
      leave: ({ name: o, arguments: p }) => "@" + o + c("(", s(p, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name: o }) => o
    },
    ListType: {
      leave: ({ type: o }) => "[" + o + "]"
    },
    NonNullType: {
      leave: ({ type: o }) => o + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description: o, directives: p, operationTypes: y }) => c("", o, `
`) + s(["schema", s(p, " "), u(y)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation: o, type: p }) => o + ": " + p
    },
    ScalarTypeDefinition: {
      leave: ({ description: o, name: p, directives: y }) => c("", o, `
`) + s(["scalar", p, s(y, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description: o, name: p, interfaces: y, directives: l, fields: f }) => c("", o, `
`) + s(
        [
          "type",
          p,
          c("implements ", s(y, " & ")),
          s(l, " "),
          u(f)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description: o, name: p, arguments: y, type: l, directives: f }) => c("", o, `
`) + p + (m(y) ? c(`(
`, d(s(y, `
`)), `
)`) : c("(", s(y, ", "), ")")) + ": " + l + c(" ", s(f, " "))
    },
    InputValueDefinition: {
      leave: ({ description: o, name: p, type: y, defaultValue: l, directives: f }) => c("", o, `
`) + s(
        [p + ": " + y, c("= ", l), s(f, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description: o, name: p, interfaces: y, directives: l, fields: f }) => c("", o, `
`) + s(
        [
          "interface",
          p,
          c("implements ", s(y, " & ")),
          s(l, " "),
          u(f)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description: o, name: p, directives: y, types: l }) => c("", o, `
`) + s(
        ["union", p, s(y, " "), c("= ", s(l, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description: o, name: p, directives: y, values: l }) => c("", o, `
`) + s(["enum", p, s(y, " "), u(l)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description: o, name: p, directives: y }) => c("", o, `
`) + s([p, s(y, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description: o, name: p, directives: y, fields: l }) => c("", o, `
`) + s(["input", p, s(y, " "), u(l)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description: o, name: p, arguments: y, repeatable: l, locations: f }) => c("", o, `
`) + "directive @" + p + (m(y) ? c(`(
`, d(s(y, `
`)), `
)`) : c("(", s(y, ", "), ")")) + (l ? " repeatable" : "") + " on " + s(f, " | ")
    },
    SchemaExtension: {
      leave: ({ directives: o, operationTypes: p }) => s(
        ["extend schema", s(o, " "), u(p)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name: o, directives: p }) => s(["extend scalar", o, s(p, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name: o, interfaces: p, directives: y, fields: l }) => s(
        [
          "extend type",
          o,
          c("implements ", s(p, " & ")),
          s(y, " "),
          u(l)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name: o, interfaces: p, directives: y, fields: l }) => s(
        [
          "extend interface",
          o,
          c("implements ", s(p, " & ")),
          s(y, " "),
          u(l)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name: o, directives: p, types: y }) => s(
        [
          "extend union",
          o,
          s(p, " "),
          c("= ", s(y, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name: o, directives: p, values: y }) => s(["extend enum", o, s(p, " "), u(y)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name: o, directives: p, fields: y }) => s(["extend input", o, s(p, " "), u(y)], " ")
    }
  };
  function s(o, p = "") {
    var y;
    return (y = o == null ? void 0 : o.filter((l) => l).join(p)) !== null && y !== void 0 ? y : "";
  }
  function u(o) {
    return c(`{
`, d(s(o, `
`)), `
}`);
  }
  function c(o, p, y = "") {
    return p != null && p !== "" ? o + p + y : "";
  }
  function d(o) {
    return c("  ", o.replace(/\n/g, `
  `));
  }
  function m(o) {
    var p;
    return (p = o == null ? void 0 : o.some((y) => y.includes(`
`))) !== null && p !== void 0 ? p : !1;
  }
  return gt;
}
var Nt = {}, Ta;
function Oo() {
  if (Ta) return Nt;
  Ta = 1, Object.defineProperty(Nt, "__esModule", {
    value: !0
  }), Nt.valueFromASTUntyped = a;
  var e = /* @__PURE__ */ kr(), n = /* @__PURE__ */ oe();
  function a(i, t) {
    switch (i.kind) {
      case n.Kind.NULL:
        return null;
      case n.Kind.INT:
        return parseInt(i.value, 10);
      case n.Kind.FLOAT:
        return parseFloat(i.value);
      case n.Kind.STRING:
      case n.Kind.ENUM:
      case n.Kind.BOOLEAN:
        return i.value;
      case n.Kind.LIST:
        return i.values.map(
          (r) => a(r, t)
        );
      case n.Kind.OBJECT:
        return (0, e.keyValMap)(
          i.fields,
          (r) => r.name.value,
          (r) => a(r.value, t)
        );
      case n.Kind.VARIABLE:
        return t == null ? void 0 : t[i.name.value];
    }
  }
  return Nt;
}
var kn = {}, ba;
function Cr() {
  if (ba) return kn;
  ba = 1, Object.defineProperty(kn, "__esModule", {
    value: !0
  }), kn.assertEnumValueName = t, kn.assertName = i;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ hi();
  function i(r) {
    if (r != null || (0, e.devAssert)(!1, "Must provide name."), typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.length === 0)
      throw new n.GraphQLError(
        "Expected name to be a non-empty string."
      );
    for (let s = 1; s < r.length; ++s)
      if (!(0, a.isNameContinue)(r.charCodeAt(s)))
        throw new n.GraphQLError(
          `Names must only contain [_a-zA-Z0-9] but "${r}" does not.`
        );
    if (!(0, a.isNameStart)(r.charCodeAt(0)))
      throw new n.GraphQLError(
        `Names must start with [_a-zA-Z] but "${r}" does not.`
      );
    return r;
  }
  function t(r) {
    if (r === "true" || r === "false" || r === "null")
      throw new n.GraphQLError(
        `Enum values cannot be named: ${r}`
      );
    return i(r);
  }
  return kn;
}
var ga;
function ue() {
  if (ga) return H;
  ga = 1, Object.defineProperty(H, "__esModule", {
    value: !0
  }), H.GraphQLUnionType = H.GraphQLScalarType = H.GraphQLObjectType = H.GraphQLNonNull = H.GraphQLList = H.GraphQLInterfaceType = H.GraphQLInputObjectType = H.GraphQLEnumType = void 0, H.argsToArgsConfig = me, H.assertAbstractType = x, H.assertCompositeType = G, H.assertEnumType = L, H.assertInputObjectType = v, H.assertInputType = U, H.assertInterfaceType = M, H.assertLeafType = te, H.assertListType = I, H.assertNamedType = Ie, H.assertNonNullType = j, H.assertNullableType = ce, H.assertObjectType = _, H.assertOutputType = P, H.assertScalarType = R, H.assertType = T, H.assertUnionType = N, H.assertWrappingType = Z, H.defineArguments = J, H.getNamedType = ve, H.getNullableType = de, H.isAbstractType = $, H.isCompositeType = pe, H.isEnumType = g, H.isInputObjectType = E, H.isInputType = k, H.isInterfaceType = w, H.isLeafType = K, H.isListType = b, H.isNamedType = be, H.isNonNullType = S, H.isNullableType = re, H.isObjectType = D, H.isOutputType = W, H.isRequiredArgument = Ne, H.isRequiredInputField = fu, H.isScalarType = O, H.isType = h, H.isUnionType = V, H.isWrappingType = Y, H.resolveObjMapThunk = De, H.resolveReadonlyArrayThunk = Ee;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ cn(), a = /* @__PURE__ */ bc(), i = /* @__PURE__ */ fe(), t = /* @__PURE__ */ wr(), r = /* @__PURE__ */ We(), s = /* @__PURE__ */ ln(), u = /* @__PURE__ */ kr(), c = /* @__PURE__ */ No(), d = /* @__PURE__ */ pn(), m = /* @__PURE__ */ Ti(), o = /* @__PURE__ */ ne(), p = /* @__PURE__ */ oe(), y = /* @__PURE__ */ Ge(), l = /* @__PURE__ */ Oo(), f = /* @__PURE__ */ Cr();
  function h(A) {
    return O(A) || D(A) || w(A) || V(A) || g(A) || E(A) || b(A) || S(A);
  }
  function T(A) {
    if (!h(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL type.`
      );
    return A;
  }
  function O(A) {
    return (0, t.instanceOf)(A, je);
  }
  function R(A) {
    if (!O(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Scalar type.`
      );
    return A;
  }
  function D(A) {
    return (0, t.instanceOf)(A, Ce);
  }
  function _(A) {
    if (!D(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Object type.`
      );
    return A;
  }
  function w(A) {
    return (0, t.instanceOf)(A, he);
  }
  function M(A) {
    if (!w(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Interface type.`
      );
    return A;
  }
  function V(A) {
    return (0, t.instanceOf)(A, Be);
  }
  function N(A) {
    if (!V(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Union type.`
      );
    return A;
  }
  function g(A) {
    return (0, t.instanceOf)(A, dn);
  }
  function L(A) {
    if (!g(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Enum type.`
      );
    return A;
  }
  function E(A) {
    return (0, t.instanceOf)(A, _i);
  }
  function v(A) {
    if (!E(A))
      throw new Error(
        `Expected ${(0, i.inspect)(
          A
        )} to be a GraphQL Input Object type.`
      );
    return A;
  }
  function b(A) {
    return (0, t.instanceOf)(A, B);
  }
  function I(A) {
    if (!b(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL List type.`
      );
    return A;
  }
  function S(A) {
    return (0, t.instanceOf)(A, ee);
  }
  function j(A) {
    if (!S(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Non-Null type.`
      );
    return A;
  }
  function k(A) {
    return O(A) || g(A) || E(A) || Y(A) && k(A.ofType);
  }
  function U(A) {
    if (!k(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL input type.`
      );
    return A;
  }
  function W(A) {
    return O(A) || D(A) || w(A) || V(A) || g(A) || Y(A) && W(A.ofType);
  }
  function P(A) {
    if (!W(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL output type.`
      );
    return A;
  }
  function K(A) {
    return O(A) || g(A);
  }
  function te(A) {
    if (!K(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL leaf type.`
      );
    return A;
  }
  function pe(A) {
    return D(A) || w(A) || V(A);
  }
  function G(A) {
    if (!pe(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL composite type.`
      );
    return A;
  }
  function $(A) {
    return w(A) || V(A);
  }
  function x(A) {
    if (!$(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL abstract type.`
      );
    return A;
  }
  class B {
    constructor(F) {
      h(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(F)} to be a GraphQL type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLList = B;
  class ee {
    constructor(F) {
      re(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(
          F
        )} to be a GraphQL nullable type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLNonNull = ee;
  function Y(A) {
    return b(A) || S(A);
  }
  function Z(A) {
    if (!Y(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL wrapping type.`
      );
    return A;
  }
  function re(A) {
    return h(A) && !S(A);
  }
  function ce(A) {
    if (!re(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL nullable type.`
      );
    return A;
  }
  function de(A) {
    if (A)
      return S(A) ? A.ofType : A;
  }
  function be(A) {
    return O(A) || D(A) || w(A) || V(A) || g(A) || E(A);
  }
  function Ie(A) {
    if (!be(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL named type.`
      );
    return A;
  }
  function ve(A) {
    if (A) {
      let F = A;
      for (; Y(F); )
        F = F.ofType;
      return F;
    }
  }
  function Ee(A) {
    return typeof A == "function" ? A() : A;
  }
  function De(A) {
    return typeof A == "function" ? A() : A;
  }
  class je {
    constructor(F) {
      var Q, se, Le, fn;
      const Ii = (Q = F.parseValue) !== null && Q !== void 0 ? Q : a.identityFunc;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.specifiedByURL = F.specifiedByURL, this.serialize = (se = F.serialize) !== null && se !== void 0 ? se : a.identityFunc, this.parseValue = Ii, this.parseLiteral = (Le = F.parseLiteral) !== null && Le !== void 0 ? Le : (mu, hu) => Ii(
        (0, l.valueFromASTUntyped)(mu, hu)
      ), this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (fn = F.extensionASTNodes) !== null && fn !== void 0 ? fn : [], F.specifiedByURL == null || typeof F.specifiedByURL == "string" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, i.inspect)(F.specifiedByURL)}.`
      ), F.serialize == null || typeof F.serialize == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
      ), F.parseLiteral && (typeof F.parseValue == "function" && typeof F.parseLiteral == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      ));
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLScalarType = je;
  class Ce {
    constructor(F) {
      var Q;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.isTypeOf = F.isTypeOf, this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = () => C(F), this._interfaces = () => et(F), F.isTypeOf == null || typeof F.isTypeOf == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "isTypeOf" as a function, but got: ${(0, i.inspect)(F.isTypeOf)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: z(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLObjectType = Ce;
  function et(A) {
    var F;
    const Q = Ee(
      (F = A.interfaces) !== null && F !== void 0 ? F : []
    );
    return Array.isArray(Q) || (0, e.devAssert)(
      !1,
      `${A.name} interfaces must be an Array or a function which returns an Array.`
    ), Q;
  }
  function C(A) {
    const F = De(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, c.mapValue)(F, (Q, se) => {
      var Le;
      q(Q) || (0, e.devAssert)(
        !1,
        `${A.name}.${se} field config must be an object.`
      ), Q.resolve == null || typeof Q.resolve == "function" || (0, e.devAssert)(
        !1,
        `${A.name}.${se} field resolver must be a function if provided, but got: ${(0, i.inspect)(Q.resolve)}.`
      );
      const fn = (Le = Q.args) !== null && Le !== void 0 ? Le : {};
      return q(fn) || (0, e.devAssert)(
        !1,
        `${A.name}.${se} args must be an object with argument names as keys.`
      ), {
        name: (0, f.assertName)(se),
        description: Q.description,
        type: Q.type,
        args: J(fn),
        resolve: Q.resolve,
        subscribe: Q.subscribe,
        deprecationReason: Q.deprecationReason,
        extensions: (0, m.toObjMap)(Q.extensions),
        astNode: Q.astNode
      };
    });
  }
  function J(A) {
    return Object.entries(A).map(([F, Q]) => ({
      name: (0, f.assertName)(F),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, m.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function q(A) {
    return (0, r.isObjectLike)(A) && !Array.isArray(A);
  }
  function z(A) {
    return (0, c.mapValue)(A, (F) => ({
      description: F.description,
      type: F.type,
      args: me(F.args),
      resolve: F.resolve,
      subscribe: F.subscribe,
      deprecationReason: F.deprecationReason,
      extensions: F.extensions,
      astNode: F.astNode
    }));
  }
  function me(A) {
    return (0, u.keyValMap)(
      A,
      (F) => F.name,
      (F) => ({
        description: F.description,
        type: F.type,
        defaultValue: F.defaultValue,
        deprecationReason: F.deprecationReason,
        extensions: F.extensions,
        astNode: F.astNode
      })
    );
  }
  function Ne(A) {
    return S(A.type) && A.defaultValue === void 0;
  }
  class he {
    constructor(F) {
      var Q;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = C.bind(void 0, F), this._interfaces = et.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: z(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInterfaceType = he;
  class Be {
    constructor(F) {
      var Q;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._types = An.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      return typeof this._types == "function" && (this._types = this._types()), this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLUnionType = Be;
  function An(A) {
    const F = Ee(A.types);
    return Array.isArray(F) || (0, e.devAssert)(
      !1,
      `Must provide Array of types or a function which returns such an array for Union ${A.name}.`
    ), F;
  }
  class dn {
    /* <T> */
    constructor(F) {
      var Q;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._values = typeof F.values == "function" ? F.values : Oi(this.name, F.values), this._valueLookup = null, this._nameLookup = null;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      return typeof this._values == "function" && (this._values = Oi(this.name, this._values())), this._values;
    }
    getValue(F) {
      return this._nameLookup === null && (this._nameLookup = (0, s.keyMap)(
        this.getValues(),
        (Q) => Q.name
      )), this._nameLookup[F];
    }
    serialize(F) {
      this._valueLookup === null && (this._valueLookup = new Map(
        this.getValues().map((se) => [se.value, se])
      ));
      const Q = this._valueLookup.get(F);
      if (Q === void 0)
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent value: ${(0, i.inspect)(
            F
          )}`
        );
      return Q.name;
    }
    parseValue(F) {
      if (typeof F != "string") {
        const se = (0, i.inspect)(F);
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent non-string value: ${se}.` + Se(this, se)
        );
      }
      const Q = this.getValue(F);
      if (Q == null)
        throw new o.GraphQLError(
          `Value "${F}" does not exist in "${this.name}" enum.` + Se(this, F)
        );
      return Q.value;
    }
    parseLiteral(F, Q) {
      if (F.kind !== p.Kind.ENUM) {
        const Le = (0, y.print)(F);
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent non-enum value: ${Le}.` + Se(this, Le),
          {
            nodes: F
          }
        );
      }
      const se = this.getValue(F.value);
      if (se == null) {
        const Le = (0, y.print)(F);
        throw new o.GraphQLError(
          `Value "${Le}" does not exist in "${this.name}" enum.` + Se(this, Le),
          {
            nodes: F
          }
        );
      }
      return se.value;
    }
    toConfig() {
      const F = (0, u.keyValMap)(
        this.getValues(),
        (Q) => Q.name,
        (Q) => ({
          description: Q.description,
          value: Q.value,
          deprecationReason: Q.deprecationReason,
          extensions: Q.extensions,
          astNode: Q.astNode
        })
      );
      return {
        name: this.name,
        description: this.description,
        values: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLEnumType = dn;
  function Se(A, F) {
    const Q = A.getValues().map((Le) => Le.name), se = (0, d.suggestionList)(
      F,
      Q
    );
    return (0, n.didYouMean)("the enum value", se);
  }
  function Oi(A, F) {
    return q(F) || (0, e.devAssert)(
      !1,
      `${A} values must be an object with value names as keys.`
    ), Object.entries(F).map(([Q, se]) => (q(se) || (0, e.devAssert)(
      !1,
      `${A}.${Q} must refer to an object with a "value" key representing an internal value but got: ${(0, i.inspect)(
        se
      )}.`
    ), {
      name: (0, f.assertEnumValueName)(Q),
      description: se.description,
      value: se.value !== void 0 ? se.value : Q,
      deprecationReason: se.deprecationReason,
      extensions: (0, m.toObjMap)(se.extensions),
      astNode: se.astNode
    }));
  }
  class _i {
    constructor(F) {
      var Q, se;
      this.name = (0, f.assertName)(F.name), this.description = F.description, this.extensions = (0, m.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this.isOneOf = (se = F.isOneOf) !== null && se !== void 0 ? se : !1, this._fields = du.bind(void 0, F);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    toConfig() {
      const F = (0, c.mapValue)(this.getFields(), (Q) => ({
        description: Q.description,
        type: Q.type,
        defaultValue: Q.defaultValue,
        deprecationReason: Q.deprecationReason,
        extensions: Q.extensions,
        astNode: Q.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        isOneOf: this.isOneOf
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInputObjectType = _i;
  function du(A) {
    const F = De(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, c.mapValue)(F, (Q, se) => (!("resolve" in Q) || (0, e.devAssert)(
      !1,
      `${A.name}.${se} field has a resolve property, but Input Types cannot define resolvers.`
    ), {
      name: (0, f.assertName)(se),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, m.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function fu(A) {
    return S(A.type) && A.defaultValue === void 0;
  }
  return H;
}
var Ea;
function Gr() {
  if (Ea) return gn;
  Ea = 1, Object.defineProperty(gn, "__esModule", {
    value: !0
  }), gn.doTypesOverlap = i, gn.isEqualType = n, gn.isTypeSubTypeOf = a;
  var e = /* @__PURE__ */ ue();
  function n(t, r) {
    return t === r ? !0 : (0, e.isNonNullType)(t) && (0, e.isNonNullType)(r) || (0, e.isListType)(t) && (0, e.isListType)(r) ? n(t.ofType, r.ofType) : !1;
  }
  function a(t, r, s) {
    return r === s ? !0 : (0, e.isNonNullType)(s) ? (0, e.isNonNullType)(r) ? a(t, r.ofType, s.ofType) : !1 : (0, e.isNonNullType)(r) ? a(t, r.ofType, s) : (0, e.isListType)(s) ? (0, e.isListType)(r) ? a(t, r.ofType, s.ofType) : !1 : (0, e.isListType)(r) ? !1 : (0, e.isAbstractType)(s) && ((0, e.isInterfaceType)(r) || (0, e.isObjectType)(r)) && t.isSubType(s, r);
  }
  function i(t, r, s) {
    return r === s ? !0 : (0, e.isAbstractType)(r) ? (0, e.isAbstractType)(s) ? t.getPossibleTypes(r).some((u) => t.isSubType(s, u)) : t.isSubType(r, s) : (0, e.isAbstractType)(s) ? t.isSubType(s, r) : !1;
  }
  return gn;
}
var ge = {}, Oe = {}, Na;
function en() {
  if (Na) return Oe;
  Na = 1, Object.defineProperty(Oe, "__esModule", {
    value: !0
  }), Oe.GraphQLString = Oe.GraphQLInt = Oe.GraphQLID = Oe.GraphQLFloat = Oe.GraphQLBoolean = Oe.GRAPHQL_MIN_INT = Oe.GRAPHQL_MAX_INT = void 0, Oe.isSpecifiedScalarType = l, Oe.specifiedScalarTypes = void 0;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ We(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Ge(), r = /* @__PURE__ */ ue();
  const s = 2147483647;
  Oe.GRAPHQL_MAX_INT = s;
  const u = -2147483648;
  Oe.GRAPHQL_MIN_INT = u;
  const c = new r.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(h) {
      const T = f(h);
      if (typeof T == "boolean")
        return T ? 1 : 0;
      let O = T;
      if (typeof T == "string" && T !== "" && (O = Number(T)), typeof O != "number" || !Number.isInteger(O))
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            T
          )}`
        );
      if (O > s || O < u)
        throw new a.GraphQLError(
          "Int cannot represent non 32-bit signed integer value: " + (0, e.inspect)(T)
        );
      return O;
    },
    parseValue(h) {
      if (typeof h != "number" || !Number.isInteger(h))
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            h
          )}`
        );
      if (h > s || h < u)
        throw new a.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${h}`
        );
      return h;
    },
    parseLiteral(h) {
      if (h.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          `Int cannot represent non-integer value: ${(0, t.print)(
            h
          )}`,
          {
            nodes: h
          }
        );
      const T = parseInt(h.value, 10);
      if (T > s || T < u)
        throw new a.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${h.value}`,
          {
            nodes: h
          }
        );
      return T;
    }
  });
  Oe.GraphQLInt = c;
  const d = new r.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(h) {
      const T = f(h);
      if (typeof T == "boolean")
        return T ? 1 : 0;
      let O = T;
      if (typeof T == "string" && T !== "" && (O = Number(T)), typeof O != "number" || !Number.isFinite(O))
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            T
          )}`
        );
      return O;
    },
    parseValue(h) {
      if (typeof h != "number" || !Number.isFinite(h))
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            h
          )}`
        );
      return h;
    },
    parseLiteral(h) {
      if (h.kind !== i.Kind.FLOAT && h.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          `Float cannot represent non numeric value: ${(0, t.print)(
            h
          )}`,
          h
        );
      return parseFloat(h.value);
    }
  });
  Oe.GraphQLFloat = d;
  const m = new r.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(h) {
      const T = f(h);
      if (typeof T == "string")
        return T;
      if (typeof T == "boolean")
        return T ? "true" : "false";
      if (typeof T == "number" && Number.isFinite(T))
        return T.toString();
      throw new a.GraphQLError(
        `String cannot represent value: ${(0, e.inspect)(h)}`
      );
    },
    parseValue(h) {
      if (typeof h != "string")
        throw new a.GraphQLError(
          `String cannot represent a non string value: ${(0, e.inspect)(
            h
          )}`
        );
      return h;
    },
    parseLiteral(h) {
      if (h.kind !== i.Kind.STRING)
        throw new a.GraphQLError(
          `String cannot represent a non string value: ${(0, t.print)(
            h
          )}`,
          {
            nodes: h
          }
        );
      return h.value;
    }
  });
  Oe.GraphQLString = m;
  const o = new r.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(h) {
      const T = f(h);
      if (typeof T == "boolean")
        return T;
      if (Number.isFinite(T))
        return T !== 0;
      throw new a.GraphQLError(
        `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
          T
        )}`
      );
    },
    parseValue(h) {
      if (typeof h != "boolean")
        throw new a.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
            h
          )}`
        );
      return h;
    },
    parseLiteral(h) {
      if (h.kind !== i.Kind.BOOLEAN)
        throw new a.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, t.print)(
            h
          )}`,
          {
            nodes: h
          }
        );
      return h.value;
    }
  });
  Oe.GraphQLBoolean = o;
  const p = new r.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(h) {
      const T = f(h);
      if (typeof T == "string")
        return T;
      if (Number.isInteger(T))
        return String(T);
      throw new a.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(h)}`
      );
    },
    parseValue(h) {
      if (typeof h == "string")
        return h;
      if (typeof h == "number" && Number.isInteger(h))
        return h.toString();
      throw new a.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(h)}`
      );
    },
    parseLiteral(h) {
      if (h.kind !== i.Kind.STRING && h.kind !== i.Kind.INT)
        throw new a.GraphQLError(
          "ID cannot represent a non-string and non-integer value: " + (0, t.print)(h),
          {
            nodes: h
          }
        );
      return h.value;
    }
  });
  Oe.GraphQLID = p;
  const y = Object.freeze([
    m,
    c,
    d,
    o,
    p
  ]);
  Oe.specifiedScalarTypes = y;
  function l(h) {
    return y.some(({ name: T }) => h.name === T);
  }
  function f(h) {
    if ((0, n.isObjectLike)(h)) {
      if (typeof h.valueOf == "function") {
        const T = h.valueOf();
        if (!(0, n.isObjectLike)(T))
          return T;
      }
      if (typeof h.toJSON == "function")
        return h.toJSON();
    }
    return h;
  }
  return Oe;
}
var Oa;
function Ve() {
  if (Oa) return ge;
  Oa = 1, Object.defineProperty(ge, "__esModule", {
    value: !0
  }), ge.GraphQLSpecifiedByDirective = ge.GraphQLSkipDirective = ge.GraphQLOneOfDirective = ge.GraphQLIncludeDirective = ge.GraphQLDirective = ge.GraphQLDeprecatedDirective = ge.DEFAULT_DEPRECATION_REASON = void 0, ge.assertDirective = m, ge.isDirective = d, ge.isSpecifiedDirective = R, ge.specifiedDirectives = void 0;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ wr(), i = /* @__PURE__ */ We(), t = /* @__PURE__ */ Ti(), r = /* @__PURE__ */ Hn(), s = /* @__PURE__ */ Cr(), u = /* @__PURE__ */ ue(), c = /* @__PURE__ */ en();
  function d(D) {
    return (0, a.instanceOf)(D, o);
  }
  function m(D) {
    if (!d(D))
      throw new Error(
        `Expected ${(0, n.inspect)(D)} to be a GraphQL directive.`
      );
    return D;
  }
  class o {
    constructor(_) {
      var w, M;
      this.name = (0, s.assertName)(_.name), this.description = _.description, this.locations = _.locations, this.isRepeatable = (w = _.isRepeatable) !== null && w !== void 0 ? w : !1, this.extensions = (0, t.toObjMap)(_.extensions), this.astNode = _.astNode, Array.isArray(_.locations) || (0, e.devAssert)(
        !1,
        `@${_.name} locations must be an Array.`
      );
      const V = (M = _.args) !== null && M !== void 0 ? M : {};
      (0, i.isObjectLike)(V) && !Array.isArray(V) || (0, e.devAssert)(
        !1,
        `@${_.name} args must be an object with argument names as keys.`
      ), this.args = (0, u.defineArguments)(V);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, u.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  ge.GraphQLDirective = o;
  const p = new o({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new u.GraphQLNonNull(c.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  ge.GraphQLIncludeDirective = p;
  const y = new o({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new u.GraphQLNonNull(c.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  ge.GraphQLSkipDirective = y;
  const l = "No longer supported";
  ge.DEFAULT_DEPRECATION_REASON = l;
  const f = new o({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      r.DirectiveLocation.FIELD_DEFINITION,
      r.DirectiveLocation.ARGUMENT_DEFINITION,
      r.DirectiveLocation.INPUT_FIELD_DEFINITION,
      r.DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: c.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: l
      }
    }
  });
  ge.GraphQLDeprecatedDirective = f;
  const h = new o({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [r.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new u.GraphQLNonNull(c.GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  ge.GraphQLSpecifiedByDirective = h;
  const T = new o({
    name: "oneOf",
    description: "Indicates exactly one field must be supplied and this field must not be `null`.",
    locations: [r.DirectiveLocation.INPUT_OBJECT],
    args: {}
  });
  ge.GraphQLOneOfDirective = T;
  const O = Object.freeze([
    p,
    y,
    f,
    h,
    T
  ]);
  ge.specifiedDirectives = O;
  function R(D) {
    return O.some(({ name: _ }) => _ === D.name);
  }
  return ge;
}
var le = {}, Ot = {}, _t = {}, _a;
function bi() {
  if (_a) return _t;
  _a = 1, Object.defineProperty(_t, "__esModule", {
    value: !0
  }), _t.isIterableObject = e;
  function e(n) {
    return typeof n == "object" && typeof (n == null ? void 0 : n[Symbol.iterator]) == "function";
  }
  return _t;
}
var Ia;
function Mr() {
  if (Ia) return Ot;
  Ia = 1, Object.defineProperty(Ot, "__esModule", {
    value: !0
  }), Ot.astFromValue = u;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ bi(), i = /* @__PURE__ */ We(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ ue(), s = /* @__PURE__ */ en();
  function u(d, m) {
    if ((0, r.isNonNullType)(m)) {
      const o = u(d, m.ofType);
      return (o == null ? void 0 : o.kind) === t.Kind.NULL ? null : o;
    }
    if (d === null)
      return {
        kind: t.Kind.NULL
      };
    if (d === void 0)
      return null;
    if ((0, r.isListType)(m)) {
      const o = m.ofType;
      if ((0, a.isIterableObject)(d)) {
        const p = [];
        for (const y of d) {
          const l = u(y, o);
          l != null && p.push(l);
        }
        return {
          kind: t.Kind.LIST,
          values: p
        };
      }
      return u(d, o);
    }
    if ((0, r.isInputObjectType)(m)) {
      if (!(0, i.isObjectLike)(d))
        return null;
      const o = [];
      for (const p of Object.values(m.getFields())) {
        const y = u(d[p.name], p.type);
        y && o.push({
          kind: t.Kind.OBJECT_FIELD,
          name: {
            kind: t.Kind.NAME,
            value: p.name
          },
          value: y
        });
      }
      return {
        kind: t.Kind.OBJECT,
        fields: o
      };
    }
    if ((0, r.isLeafType)(m)) {
      const o = m.serialize(d);
      if (o == null)
        return null;
      if (typeof o == "boolean")
        return {
          kind: t.Kind.BOOLEAN,
          value: o
        };
      if (typeof o == "number" && Number.isFinite(o)) {
        const p = String(o);
        return c.test(p) ? {
          kind: t.Kind.INT,
          value: p
        } : {
          kind: t.Kind.FLOAT,
          value: p
        };
      }
      if (typeof o == "string")
        return (0, r.isEnumType)(m) ? {
          kind: t.Kind.ENUM,
          value: o
        } : m === s.GraphQLID && c.test(o) ? {
          kind: t.Kind.INT,
          value: o
        } : {
          kind: t.Kind.STRING,
          value: o
        };
      throw new TypeError(
        `Cannot convert value to AST: ${(0, e.inspect)(o)}.`
      );
    }
    (0, n.invariant)(
      !1,
      "Unexpected input type: " + (0, e.inspect)(m)
    );
  }
  const c = /^-?(?:0|[1-9][0-9]*)$/;
  return Ot;
}
var Sa;
function Qe() {
  if (Sa) return le;
  Sa = 1, Object.defineProperty(le, "__esModule", {
    value: !0
  }), le.introspectionTypes = le.__TypeKind = le.__Type = le.__Schema = le.__InputValue = le.__Field = le.__EnumValue = le.__DirectiveLocation = le.__Directive = le.TypeNameMetaFieldDef = le.TypeMetaFieldDef = le.TypeKind = le.SchemaMetaFieldDef = void 0, le.isIntrospectionType = D;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ Hn(), i = /* @__PURE__ */ Ge(), t = /* @__PURE__ */ Mr(), r = /* @__PURE__ */ ue(), s = /* @__PURE__ */ en();
  const u = new r.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: s.GraphQLString,
        resolve: (_) => _.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(new r.GraphQLNonNull(m))
        ),
        resolve(_) {
          return Object.values(_.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new r.GraphQLNonNull(m),
        resolve: (_) => _.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: m,
        resolve: (_) => _.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: m,
        resolve: (_) => _.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(c)
          )
        ),
        resolve: (_) => _.getDirectives()
      }
    })
  });
  le.__Schema = u;
  const c = new r.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(s.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: s.GraphQLString,
        resolve: (_) => _.description
      },
      isRepeatable: {
        type: new r.GraphQLNonNull(s.GraphQLBoolean),
        resolve: (_) => _.isRepeatable
      },
      locations: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(d)
          )
        ),
        resolve: (_) => _.locations
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(p)
          )
        ),
        args: {
          includeDeprecated: {
            type: s.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          return w ? _.args : _.args.filter((M) => M.deprecationReason == null);
        }
      }
    })
  });
  le.__Directive = c;
  const d = new r.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: a.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: a.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: a.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: a.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: a.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: a.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: a.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: a.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: a.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: a.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: a.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: a.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: a.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: a.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: a.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: a.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: a.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: a.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: a.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  le.__DirectiveLocation = d;
  const m = new r.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new r.GraphQLNonNull(f),
        resolve(_) {
          if ((0, r.isScalarType)(_))
            return l.SCALAR;
          if ((0, r.isObjectType)(_))
            return l.OBJECT;
          if ((0, r.isInterfaceType)(_))
            return l.INTERFACE;
          if ((0, r.isUnionType)(_))
            return l.UNION;
          if ((0, r.isEnumType)(_))
            return l.ENUM;
          if ((0, r.isInputObjectType)(_))
            return l.INPUT_OBJECT;
          if ((0, r.isListType)(_))
            return l.LIST;
          if ((0, r.isNonNullType)(_))
            return l.NON_NULL;
          (0, n.invariant)(
            !1,
            `Unexpected type: "${(0, e.inspect)(_)}".`
          );
        }
      },
      name: {
        type: s.GraphQLString,
        resolve: (_) => "name" in _ ? _.name : void 0
      },
      description: {
        type: s.GraphQLString,
        resolve: (_) => (
          /* c8 ignore next */
          "description" in _ ? _.description : void 0
        )
      },
      specifiedByURL: {
        type: s.GraphQLString,
        resolve: (_) => "specifiedByURL" in _ ? _.specifiedByURL : void 0
      },
      fields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(o)
        ),
        args: {
          includeDeprecated: {
            type: s.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isObjectType)(_) || (0, r.isInterfaceType)(_)) {
            const M = Object.values(_.getFields());
            return w ? M : M.filter((V) => V.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new r.GraphQLList(new r.GraphQLNonNull(m)),
        resolve(_) {
          if ((0, r.isObjectType)(_) || (0, r.isInterfaceType)(_))
            return _.getInterfaces();
        }
      },
      possibleTypes: {
        type: new r.GraphQLList(new r.GraphQLNonNull(m)),
        resolve(_, w, M, { schema: V }) {
          if ((0, r.isAbstractType)(_))
            return V.getPossibleTypes(_);
        }
      },
      enumValues: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(y)
        ),
        args: {
          includeDeprecated: {
            type: s.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isEnumType)(_)) {
            const M = _.getValues();
            return w ? M : M.filter((V) => V.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(p)
        ),
        args: {
          includeDeprecated: {
            type: s.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isInputObjectType)(_)) {
            const M = Object.values(_.getFields());
            return w ? M : M.filter((V) => V.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: m,
        resolve: (_) => "ofType" in _ ? _.ofType : void 0
      },
      isOneOf: {
        type: s.GraphQLBoolean,
        resolve: (_) => {
          if ((0, r.isInputObjectType)(_))
            return _.isOneOf;
        }
      }
    })
  });
  le.__Type = m;
  const o = new r.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(s.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: s.GraphQLString,
        resolve: (_) => _.description
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(p)
          )
        ),
        args: {
          includeDeprecated: {
            type: s.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          return w ? _.args : _.args.filter((M) => M.deprecationReason == null);
        }
      },
      type: {
        type: new r.GraphQLNonNull(m),
        resolve: (_) => _.type
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(s.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: s.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__Field = o;
  const p = new r.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(s.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: s.GraphQLString,
        resolve: (_) => _.description
      },
      type: {
        type: new r.GraphQLNonNull(m),
        resolve: (_) => _.type
      },
      defaultValue: {
        type: s.GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(_) {
          const { type: w, defaultValue: M } = _, V = (0, t.astFromValue)(M, w);
          return V ? (0, i.print)(V) : null;
        }
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(s.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: s.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__InputValue = p;
  const y = new r.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(s.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: s.GraphQLString,
        resolve: (_) => _.description
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(s.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: s.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__EnumValue = y;
  var l;
  le.TypeKind = l, function(_) {
    _.SCALAR = "SCALAR", _.OBJECT = "OBJECT", _.INTERFACE = "INTERFACE", _.UNION = "UNION", _.ENUM = "ENUM", _.INPUT_OBJECT = "INPUT_OBJECT", _.LIST = "LIST", _.NON_NULL = "NON_NULL";
  }(l || (le.TypeKind = l = {}));
  const f = new r.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: l.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: l.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: l.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: l.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: l.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: l.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: l.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: l.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  le.__TypeKind = f;
  const h = {
    name: "__schema",
    type: new r.GraphQLNonNull(u),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_, w, M, { schema: V }) => V,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.SchemaMetaFieldDef = h;
  const T = {
    name: "__type",
    type: m,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: void 0,
        type: new r.GraphQLNonNull(s.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      }
    ],
    resolve: (_, { name: w }, M, { schema: V }) => V.getType(w),
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeMetaFieldDef = T;
  const O = {
    name: "__typename",
    type: new r.GraphQLNonNull(s.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_, w, M, { parentType: V }) => V.name,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeNameMetaFieldDef = O;
  const R = Object.freeze([
    u,
    c,
    d,
    m,
    o,
    p,
    y,
    f
  ]);
  le.introspectionTypes = R;
  function D(_) {
    return R.some(({ name: w }) => _.name === w);
  }
  return le;
}
var sn = {}, La;
function Rn() {
  if (La) return sn;
  La = 1, Object.defineProperty(sn, "__esModule", {
    value: !0
  }), sn.GraphQLSchema = void 0, sn.assertSchema = m, sn.isSchema = d;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ wr(), i = /* @__PURE__ */ We(), t = /* @__PURE__ */ Ti(), r = /* @__PURE__ */ Ze(), s = /* @__PURE__ */ ue(), u = /* @__PURE__ */ Ve(), c = /* @__PURE__ */ Qe();
  function d(y) {
    return (0, a.instanceOf)(y, o);
  }
  function m(y) {
    if (!d(y))
      throw new Error(
        `Expected ${(0, n.inspect)(y)} to be a GraphQL schema.`
      );
    return y;
  }
  class o {
    // Used as a cache for validateSchema().
    constructor(l) {
      var f, h;
      this.__validationErrors = l.assumeValid === !0 ? [] : void 0, (0, i.isObjectLike)(l) || (0, e.devAssert)(!1, "Must provide configuration object."), !l.types || Array.isArray(l.types) || (0, e.devAssert)(
        !1,
        `"types" must be Array if provided but got: ${(0, n.inspect)(
          l.types
        )}.`
      ), !l.directives || Array.isArray(l.directives) || (0, e.devAssert)(
        !1,
        `"directives" must be Array if provided but got: ${(0, n.inspect)(l.directives)}.`
      ), this.description = l.description, this.extensions = (0, t.toObjMap)(l.extensions), this.astNode = l.astNode, this.extensionASTNodes = (f = l.extensionASTNodes) !== null && f !== void 0 ? f : [], this._queryType = l.query, this._mutationType = l.mutation, this._subscriptionType = l.subscription, this._directives = (h = l.directives) !== null && h !== void 0 ? h : u.specifiedDirectives;
      const T = new Set(l.types);
      if (l.types != null)
        for (const O of l.types)
          T.delete(O), p(O, T);
      this._queryType != null && p(this._queryType, T), this._mutationType != null && p(this._mutationType, T), this._subscriptionType != null && p(this._subscriptionType, T);
      for (const O of this._directives)
        if ((0, u.isDirective)(O))
          for (const R of O.args)
            p(R.type, T);
      p(c.__Schema, T), this._typeMap = /* @__PURE__ */ Object.create(null), this._subTypeMap = /* @__PURE__ */ Object.create(null), this._implementationsMap = /* @__PURE__ */ Object.create(null);
      for (const O of T) {
        if (O == null)
          continue;
        const R = O.name;
        if (R || (0, e.devAssert)(
          !1,
          "One of the provided types for building the Schema is missing a name."
        ), this._typeMap[R] !== void 0)
          throw new Error(
            `Schema must contain uniquely named types but contains multiple types named "${R}".`
          );
        if (this._typeMap[R] = O, (0, s.isInterfaceType)(O)) {
          for (const D of O.getInterfaces())
            if ((0, s.isInterfaceType)(D)) {
              let _ = this._implementationsMap[D.name];
              _ === void 0 && (_ = this._implementationsMap[D.name] = {
                objects: [],
                interfaces: []
              }), _.interfaces.push(O);
            }
        } else if ((0, s.isObjectType)(O)) {
          for (const D of O.getInterfaces())
            if ((0, s.isInterfaceType)(D)) {
              let _ = this._implementationsMap[D.name];
              _ === void 0 && (_ = this._implementationsMap[D.name] = {
                objects: [],
                interfaces: []
              }), _.objects.push(O);
            }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(l) {
      switch (l) {
        case r.OperationTypeNode.QUERY:
          return this.getQueryType();
        case r.OperationTypeNode.MUTATION:
          return this.getMutationType();
        case r.OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(l) {
      return this.getTypeMap()[l];
    }
    getPossibleTypes(l) {
      return (0, s.isUnionType)(l) ? l.getTypes() : this.getImplementations(l).objects;
    }
    getImplementations(l) {
      const f = this._implementationsMap[l.name];
      return f ?? {
        objects: [],
        interfaces: []
      };
    }
    isSubType(l, f) {
      let h = this._subTypeMap[l.name];
      if (h === void 0) {
        if (h = /* @__PURE__ */ Object.create(null), (0, s.isUnionType)(l))
          for (const T of l.getTypes())
            h[T.name] = !0;
        else {
          const T = this.getImplementations(l);
          for (const O of T.objects)
            h[O.name] = !0;
          for (const O of T.interfaces)
            h[O.name] = !0;
        }
        this._subTypeMap[l.name] = h;
      }
      return h[f.name] !== void 0;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(l) {
      return this.getDirectives().find((f) => f.name === l);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== void 0
      };
    }
  }
  sn.GraphQLSchema = o;
  function p(y, l) {
    const f = (0, s.getNamedType)(y);
    if (!l.has(f)) {
      if (l.add(f), (0, s.isUnionType)(f))
        for (const h of f.getTypes())
          p(h, l);
      else if ((0, s.isObjectType)(f) || (0, s.isInterfaceType)(f)) {
        for (const h of f.getInterfaces())
          p(h, l);
        for (const h of Object.values(f.getFields())) {
          p(h.type, l);
          for (const T of h.args)
            p(T.type, l);
        }
      } else if ((0, s.isInputObjectType)(f))
        for (const h of Object.values(f.getFields()))
          p(h.type, l);
    }
    return l;
  }
  return sn;
}
var Ra;
function $r() {
  if (Ra) return wn;
  Ra = 1, Object.defineProperty(wn, "__esModule", {
    value: !0
  }), wn.assertValidSchema = d, wn.validateSchema = c;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Ze(), i = /* @__PURE__ */ Gr(), t = /* @__PURE__ */ ue(), r = /* @__PURE__ */ Ve(), s = /* @__PURE__ */ Qe(), u = /* @__PURE__ */ Rn();
  function c(E) {
    if ((0, u.assertSchema)(E), E.__validationErrors)
      return E.__validationErrors;
    const v = new m(E);
    o(v), y(v), f(v);
    const b = v.getErrors();
    return E.__validationErrors = b, b;
  }
  function d(E) {
    const v = c(E);
    if (v.length !== 0)
      throw new Error(v.map((b) => b.message).join(`

`));
  }
  class m {
    constructor(v) {
      this._errors = [], this.schema = v;
    }
    reportError(v, b) {
      const I = Array.isArray(b) ? b.filter(Boolean) : b;
      this._errors.push(
        new n.GraphQLError(v, {
          nodes: I
        })
      );
    }
    getErrors() {
      return this._errors;
    }
  }
  function o(E) {
    const v = E.schema, b = v.getQueryType();
    if (!b)
      E.reportError("Query root type must be provided.", v.astNode);
    else if (!(0, t.isObjectType)(b)) {
      var I;
      E.reportError(
        `Query root type must be Object type, it cannot be ${(0, e.inspect)(b)}.`,
        (I = p(
          v,
          a.OperationTypeNode.QUERY
        )) !== null && I !== void 0 ? I : b.astNode
      );
    }
    const S = v.getMutationType();
    if (S && !(0, t.isObjectType)(S)) {
      var j;
      E.reportError(
        `Mutation root type must be Object type if provided, it cannot be ${(0, e.inspect)(S)}.`,
        (j = p(
          v,
          a.OperationTypeNode.MUTATION
        )) !== null && j !== void 0 ? j : S.astNode
      );
    }
    const k = v.getSubscriptionType();
    if (k && !(0, t.isObjectType)(k)) {
      var U;
      E.reportError(
        `Subscription root type must be Object type if provided, it cannot be ${(0, e.inspect)(k)}.`,
        (U = p(
          v,
          a.OperationTypeNode.SUBSCRIPTION
        )) !== null && U !== void 0 ? U : k.astNode
      );
    }
  }
  function p(E, v) {
    var b;
    return (b = [E.astNode, ...E.extensionASTNodes].flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (I) => {
        var S;
        return (
          /* c8 ignore next */
          (S = I == null ? void 0 : I.operationTypes) !== null && S !== void 0 ? S : []
        );
      }
    ).find((I) => I.operation === v)) === null || b === void 0 ? void 0 : b.type;
  }
  function y(E) {
    for (const b of E.schema.getDirectives()) {
      if (!(0, r.isDirective)(b)) {
        E.reportError(
          `Expected directive but got: ${(0, e.inspect)(b)}.`,
          b == null ? void 0 : b.astNode
        );
        continue;
      }
      l(E, b), b.locations.length === 0 && E.reportError(
        `Directive @${b.name} must include 1 or more locations.`,
        b.astNode
      );
      for (const I of b.args)
        if (l(E, I), (0, t.isInputType)(I.type) || E.reportError(
          `The type of @${b.name}(${I.name}:) must be Input Type but got: ${(0, e.inspect)(I.type)}.`,
          I.astNode
        ), (0, t.isRequiredArgument)(I) && I.deprecationReason != null) {
          var v;
          E.reportError(
            `Required argument @${b.name}(${I.name}:) cannot be deprecated.`,
            [
              L(I.astNode),
              (v = I.astNode) === null || v === void 0 ? void 0 : v.type
            ]
          );
        }
    }
  }
  function l(E, v) {
    v.name.startsWith("__") && E.reportError(
      `Name "${v.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      v.astNode
    );
  }
  function f(E) {
    const v = V(E), b = E.schema.getTypeMap();
    for (const I of Object.values(b)) {
      if (!(0, t.isNamedType)(I)) {
        E.reportError(
          `Expected GraphQL named type but got: ${(0, e.inspect)(I)}.`,
          I.astNode
        );
        continue;
      }
      (0, s.isIntrospectionType)(I) || l(E, I), (0, t.isObjectType)(I) || (0, t.isInterfaceType)(I) ? (h(E, I), T(E, I)) : (0, t.isUnionType)(I) ? D(E, I) : (0, t.isEnumType)(I) ? _(E, I) : (0, t.isInputObjectType)(I) && (w(E, I), v(I));
    }
  }
  function h(E, v) {
    const b = Object.values(v.getFields());
    b.length === 0 && E.reportError(`Type ${v.name} must define one or more fields.`, [
      v.astNode,
      ...v.extensionASTNodes
    ]);
    for (const k of b) {
      if (l(E, k), !(0, t.isOutputType)(k.type)) {
        var I;
        E.reportError(
          `The type of ${v.name}.${k.name} must be Output Type but got: ${(0, e.inspect)(k.type)}.`,
          (I = k.astNode) === null || I === void 0 ? void 0 : I.type
        );
      }
      for (const U of k.args) {
        const W = U.name;
        if (l(E, U), !(0, t.isInputType)(U.type)) {
          var S;
          E.reportError(
            `The type of ${v.name}.${k.name}(${W}:) must be Input Type but got: ${(0, e.inspect)(U.type)}.`,
            (S = U.astNode) === null || S === void 0 ? void 0 : S.type
          );
        }
        if ((0, t.isRequiredArgument)(U) && U.deprecationReason != null) {
          var j;
          E.reportError(
            `Required argument ${v.name}.${k.name}(${W}:) cannot be deprecated.`,
            [
              L(U.astNode),
              (j = U.astNode) === null || j === void 0 ? void 0 : j.type
            ]
          );
        }
      }
    }
  }
  function T(E, v) {
    const b = /* @__PURE__ */ Object.create(null);
    for (const I of v.getInterfaces()) {
      if (!(0, t.isInterfaceType)(I)) {
        E.reportError(
          `Type ${(0, e.inspect)(
            v
          )} must only implement Interface types, it cannot implement ${(0, e.inspect)(I)}.`,
          N(v, I)
        );
        continue;
      }
      if (v === I) {
        E.reportError(
          `Type ${v.name} cannot implement itself because it would create a circular reference.`,
          N(v, I)
        );
        continue;
      }
      if (b[I.name]) {
        E.reportError(
          `Type ${v.name} can only implement ${I.name} once.`,
          N(v, I)
        );
        continue;
      }
      b[I.name] = !0, R(E, v, I), O(E, v, I);
    }
  }
  function O(E, v, b) {
    const I = v.getFields();
    for (const W of Object.values(b.getFields())) {
      const P = W.name, K = I[P];
      if (!K) {
        E.reportError(
          `Interface field ${b.name}.${P} expected but ${v.name} does not provide it.`,
          [W.astNode, v.astNode, ...v.extensionASTNodes]
        );
        continue;
      }
      if (!(0, i.isTypeSubTypeOf)(
        E.schema,
        K.type,
        W.type
      )) {
        var S, j;
        E.reportError(
          `Interface field ${b.name}.${P} expects type ${(0, e.inspect)(W.type)} but ${v.name}.${P} is type ${(0, e.inspect)(K.type)}.`,
          [
            (S = W.astNode) === null || S === void 0 ? void 0 : S.type,
            (j = K.astNode) === null || j === void 0 ? void 0 : j.type
          ]
        );
      }
      for (const te of W.args) {
        const pe = te.name, G = K.args.find(($) => $.name === pe);
        if (!G) {
          E.reportError(
            `Interface field argument ${b.name}.${P}(${pe}:) expected but ${v.name}.${P} does not provide it.`,
            [te.astNode, K.astNode]
          );
          continue;
        }
        if (!(0, i.isEqualType)(te.type, G.type)) {
          var k, U;
          E.reportError(
            `Interface field argument ${b.name}.${P}(${pe}:) expects type ${(0, e.inspect)(te.type)} but ${v.name}.${P}(${pe}:) is type ${(0, e.inspect)(G.type)}.`,
            [
              (k = te.astNode) === null || k === void 0 ? void 0 : k.type,
              (U = G.astNode) === null || U === void 0 ? void 0 : U.type
            ]
          );
        }
      }
      for (const te of K.args) {
        const pe = te.name;
        !W.args.find(($) => $.name === pe) && (0, t.isRequiredArgument)(te) && E.reportError(
          `Object field ${v.name}.${P} includes required argument ${pe} that is missing from the Interface field ${b.name}.${P}.`,
          [te.astNode, W.astNode]
        );
      }
    }
  }
  function R(E, v, b) {
    const I = v.getInterfaces();
    for (const S of b.getInterfaces())
      I.includes(S) || E.reportError(
        S === v ? `Type ${v.name} cannot implement ${b.name} because it would create a circular reference.` : `Type ${v.name} must implement ${S.name} because it is implemented by ${b.name}.`,
        [
          ...N(b, S),
          ...N(v, b)
        ]
      );
  }
  function D(E, v) {
    const b = v.getTypes();
    b.length === 0 && E.reportError(
      `Union type ${v.name} must define one or more member types.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    const I = /* @__PURE__ */ Object.create(null);
    for (const S of b) {
      if (I[S.name]) {
        E.reportError(
          `Union type ${v.name} can only include type ${S.name} once.`,
          g(v, S.name)
        );
        continue;
      }
      I[S.name] = !0, (0, t.isObjectType)(S) || E.reportError(
        `Union type ${v.name} can only include Object types, it cannot include ${(0, e.inspect)(S)}.`,
        g(v, String(S))
      );
    }
  }
  function _(E, v) {
    const b = v.getValues();
    b.length === 0 && E.reportError(
      `Enum type ${v.name} must define one or more values.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const I of b)
      l(E, I);
  }
  function w(E, v) {
    const b = Object.values(v.getFields());
    b.length === 0 && E.reportError(
      `Input Object type ${v.name} must define one or more fields.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const j of b) {
      if (l(E, j), !(0, t.isInputType)(j.type)) {
        var I;
        E.reportError(
          `The type of ${v.name}.${j.name} must be Input Type but got: ${(0, e.inspect)(j.type)}.`,
          (I = j.astNode) === null || I === void 0 ? void 0 : I.type
        );
      }
      if ((0, t.isRequiredInputField)(j) && j.deprecationReason != null) {
        var S;
        E.reportError(
          `Required input field ${v.name}.${j.name} cannot be deprecated.`,
          [
            L(j.astNode),
            (S = j.astNode) === null || S === void 0 ? void 0 : S.type
          ]
        );
      }
      v.isOneOf && M(v, j, E);
    }
  }
  function M(E, v, b) {
    if ((0, t.isNonNullType)(v.type)) {
      var I;
      b.reportError(
        `OneOf input field ${E.name}.${v.name} must be nullable.`,
        (I = v.astNode) === null || I === void 0 ? void 0 : I.type
      );
    }
    v.defaultValue !== void 0 && b.reportError(
      `OneOf input field ${E.name}.${v.name} cannot have a default value.`,
      v.astNode
    );
  }
  function V(E) {
    const v = /* @__PURE__ */ Object.create(null), b = [], I = /* @__PURE__ */ Object.create(null);
    return S;
    function S(j) {
      if (v[j.name])
        return;
      v[j.name] = !0, I[j.name] = b.length;
      const k = Object.values(j.getFields());
      for (const U of k)
        if ((0, t.isNonNullType)(U.type) && (0, t.isInputObjectType)(U.type.ofType)) {
          const W = U.type.ofType, P = I[W.name];
          if (b.push(U), P === void 0)
            S(W);
          else {
            const K = b.slice(P), te = K.map((pe) => pe.name).join(".");
            E.reportError(
              `Cannot reference Input Object "${W.name}" within itself through a series of non-null fields: "${te}".`,
              K.map((pe) => pe.astNode)
            );
          }
          b.pop();
        }
      I[j.name] = void 0;
    }
  }
  function N(E, v) {
    const { astNode: b, extensionASTNodes: I } = E;
    return (b != null ? [b, ...I] : I).flatMap((j) => {
      var k;
      return (
        /* c8 ignore next */
        (k = j.interfaces) !== null && k !== void 0 ? k : []
      );
    }).filter((j) => j.name.value === v.name);
  }
  function g(E, v) {
    const { astNode: b, extensionASTNodes: I } = E;
    return (b != null ? [b, ...I] : I).flatMap((j) => {
      var k;
      return (
        /* c8 ignore next */
        (k = j.types) !== null && k !== void 0 ? k : []
      );
    }).filter((j) => j.name.value === v);
  }
  function L(E) {
    var v;
    return E == null || (v = E.directives) === null || v === void 0 ? void 0 : v.find(
      (b) => b.name.value === r.GraphQLDeprecatedDirective.name
    );
  }
  return wn;
}
var on = {}, En = {}, It = {}, Da;
function nn() {
  if (Da) return It;
  Da = 1, Object.defineProperty(It, "__esModule", {
    value: !0
  }), It.typeFromAST = a;
  var e = /* @__PURE__ */ oe(), n = /* @__PURE__ */ ue();
  function a(i, t) {
    switch (t.kind) {
      case e.Kind.LIST_TYPE: {
        const r = a(i, t.type);
        return r && new n.GraphQLList(r);
      }
      case e.Kind.NON_NULL_TYPE: {
        const r = a(i, t.type);
        return r && new n.GraphQLNonNull(r);
      }
      case e.Kind.NAMED_TYPE:
        return i.getType(t.name.value);
    }
  }
  return It;
}
var Aa;
function gi() {
  if (Aa) return En;
  Aa = 1, Object.defineProperty(En, "__esModule", {
    value: !0
  }), En.TypeInfo = void 0, En.visitWithTypeInfo = c;
  var e = /* @__PURE__ */ Ze(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Ln(), i = /* @__PURE__ */ ue(), t = /* @__PURE__ */ Qe(), r = /* @__PURE__ */ nn();
  let s = class {
    constructor(m, o, p) {
      this._schema = m, this._typeStack = [], this._parentTypeStack = [], this._inputTypeStack = [], this._fieldDefStack = [], this._defaultValueStack = [], this._directive = null, this._argument = null, this._enumValue = null, this._getFieldDef = p ?? u, o && ((0, i.isInputType)(o) && this._inputTypeStack.push(o), (0, i.isCompositeType)(o) && this._parentTypeStack.push(o), (0, i.isOutputType)(o) && this._typeStack.push(o));
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0)
        return this._typeStack[this._typeStack.length - 1];
    }
    getParentType() {
      if (this._parentTypeStack.length > 0)
        return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
    getInputType() {
      if (this._inputTypeStack.length > 0)
        return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1)
        return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0)
        return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0)
        return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(m) {
      const o = this._schema;
      switch (m.kind) {
        case n.Kind.SELECTION_SET: {
          const y = (0, i.getNamedType)(this.getType());
          this._parentTypeStack.push(
            (0, i.isCompositeType)(y) ? y : void 0
          );
          break;
        }
        case n.Kind.FIELD: {
          const y = this.getParentType();
          let l, f;
          y && (l = this._getFieldDef(o, y, m), l && (f = l.type)), this._fieldDefStack.push(l), this._typeStack.push(
            (0, i.isOutputType)(f) ? f : void 0
          );
          break;
        }
        case n.Kind.DIRECTIVE:
          this._directive = o.getDirective(m.name.value);
          break;
        case n.Kind.OPERATION_DEFINITION: {
          const y = o.getRootType(m.operation);
          this._typeStack.push(
            (0, i.isObjectType)(y) ? y : void 0
          );
          break;
        }
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION: {
          const y = m.typeCondition, l = y ? (0, r.typeFromAST)(o, y) : (0, i.getNamedType)(this.getType());
          this._typeStack.push(
            (0, i.isOutputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.VARIABLE_DEFINITION: {
          const y = (0, r.typeFromAST)(o, m.type);
          this._inputTypeStack.push(
            (0, i.isInputType)(y) ? y : void 0
          );
          break;
        }
        case n.Kind.ARGUMENT: {
          var p;
          let y, l;
          const f = (p = this.getDirective()) !== null && p !== void 0 ? p : this.getFieldDef();
          f && (y = f.args.find(
            (h) => h.name === m.name.value
          ), y && (l = y.type)), this._argument = y, this._defaultValueStack.push(y ? y.defaultValue : void 0), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.LIST: {
          const y = (0, i.getNullableType)(this.getInputType()), l = (0, i.isListType)(y) ? y.ofType : y;
          this._defaultValueStack.push(void 0), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.OBJECT_FIELD: {
          const y = (0, i.getNamedType)(this.getInputType());
          let l, f;
          (0, i.isInputObjectType)(y) && (f = y.getFields()[m.name.value], f && (l = f.type)), this._defaultValueStack.push(
            f ? f.defaultValue : void 0
          ), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.ENUM: {
          const y = (0, i.getNamedType)(this.getInputType());
          let l;
          (0, i.isEnumType)(y) && (l = y.getValue(m.value)), this._enumValue = l;
          break;
        }
      }
    }
    leave(m) {
      switch (m.kind) {
        case n.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case n.Kind.FIELD:
          this._fieldDefStack.pop(), this._typeStack.pop();
          break;
        case n.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case n.Kind.OPERATION_DEFINITION:
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case n.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case n.Kind.ARGUMENT:
          this._argument = null, this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.LIST:
        case n.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.ENUM:
          this._enumValue = null;
          break;
      }
    }
  };
  En.TypeInfo = s;
  function u(d, m, o) {
    const p = o.name.value;
    if (p === t.SchemaMetaFieldDef.name && d.getQueryType() === m)
      return t.SchemaMetaFieldDef;
    if (p === t.TypeMetaFieldDef.name && d.getQueryType() === m)
      return t.TypeMetaFieldDef;
    if (p === t.TypeNameMetaFieldDef.name && (0, i.isCompositeType)(m))
      return t.TypeNameMetaFieldDef;
    if ((0, i.isObjectType)(m) || (0, i.isInterfaceType)(m))
      return m.getFields()[p];
  }
  function c(d, m) {
    return {
      enter(...o) {
        const p = o[0];
        d.enter(p);
        const y = (0, a.getEnterLeaveForKind)(m, p.kind).enter;
        if (y) {
          const l = y.apply(m, o);
          return l !== void 0 && (d.leave(p), (0, e.isNode)(l) && d.enter(l)), l;
        }
      },
      leave(...o) {
        const p = o[0], y = (0, a.getEnterLeaveForKind)(m, p.kind).leave;
        let l;
        return y && (l = y.apply(m, o)), d.leave(p), l;
      }
    };
  }
  return En;
}
var ze = {}, St = {}, Fe = {}, ja;
function Dn() {
  if (ja) return Fe;
  ja = 1, Object.defineProperty(Fe, "__esModule", {
    value: !0
  }), Fe.isConstValueNode = r, Fe.isDefinitionNode = n, Fe.isExecutableDefinitionNode = a, Fe.isSelectionNode = i, Fe.isTypeDefinitionNode = c, Fe.isTypeExtensionNode = m, Fe.isTypeNode = s, Fe.isTypeSystemDefinitionNode = u, Fe.isTypeSystemExtensionNode = d, Fe.isValueNode = t;
  var e = /* @__PURE__ */ oe();
  function n(o) {
    return a(o) || u(o) || d(o);
  }
  function a(o) {
    return o.kind === e.Kind.OPERATION_DEFINITION || o.kind === e.Kind.FRAGMENT_DEFINITION;
  }
  function i(o) {
    return o.kind === e.Kind.FIELD || o.kind === e.Kind.FRAGMENT_SPREAD || o.kind === e.Kind.INLINE_FRAGMENT;
  }
  function t(o) {
    return o.kind === e.Kind.VARIABLE || o.kind === e.Kind.INT || o.kind === e.Kind.FLOAT || o.kind === e.Kind.STRING || o.kind === e.Kind.BOOLEAN || o.kind === e.Kind.NULL || o.kind === e.Kind.ENUM || o.kind === e.Kind.LIST || o.kind === e.Kind.OBJECT;
  }
  function r(o) {
    return t(o) && (o.kind === e.Kind.LIST ? o.values.some(r) : o.kind === e.Kind.OBJECT ? o.fields.some((p) => r(p.value)) : o.kind !== e.Kind.VARIABLE);
  }
  function s(o) {
    return o.kind === e.Kind.NAMED_TYPE || o.kind === e.Kind.LIST_TYPE || o.kind === e.Kind.NON_NULL_TYPE;
  }
  function u(o) {
    return o.kind === e.Kind.SCHEMA_DEFINITION || c(o) || o.kind === e.Kind.DIRECTIVE_DEFINITION;
  }
  function c(o) {
    return o.kind === e.Kind.SCALAR_TYPE_DEFINITION || o.kind === e.Kind.OBJECT_TYPE_DEFINITION || o.kind === e.Kind.INTERFACE_TYPE_DEFINITION || o.kind === e.Kind.UNION_TYPE_DEFINITION || o.kind === e.Kind.ENUM_TYPE_DEFINITION || o.kind === e.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function d(o) {
    return o.kind === e.Kind.SCHEMA_EXTENSION || m(o);
  }
  function m(o) {
    return o.kind === e.Kind.SCALAR_TYPE_EXTENSION || o.kind === e.Kind.OBJECT_TYPE_EXTENSION || o.kind === e.Kind.INTERFACE_TYPE_EXTENSION || o.kind === e.Kind.UNION_TYPE_EXTENSION || o.kind === e.Kind.ENUM_TYPE_EXTENSION || o.kind === e.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  return Fe;
}
var Pa;
function _o() {
  if (Pa) return St;
  Pa = 1, Object.defineProperty(St, "__esModule", {
    value: !0
  }), St.ExecutableDefinitionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Dn();
  function i(t) {
    return {
      Document(r) {
        for (const s of r.definitions)
          if (!(0, a.isExecutableDefinitionNode)(s)) {
            const u = s.kind === n.Kind.SCHEMA_DEFINITION || s.kind === n.Kind.SCHEMA_EXTENSION ? "schema" : '"' + s.name.value + '"';
            t.reportError(
              new e.GraphQLError(
                `The ${u} definition is not executable.`,
                {
                  nodes: s
                }
              )
            );
          }
        return !1;
      }
    };
  }
  return St;
}
var Lt = {}, Fa;
function Io() {
  if (Fa) return Lt;
  Fa = 1, Object.defineProperty(Lt, "__esModule", {
    value: !0
  }), Lt.FieldsOnCorrectTypeRule = r;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ Vr(), a = /* @__PURE__ */ pn(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ ue();
  function r(c) {
    return {
      Field(d) {
        const m = c.getParentType();
        if (m && !c.getFieldDef()) {
          const p = c.getSchema(), y = d.name.value;
          let l = (0, e.didYouMean)(
            "to use an inline fragment on",
            s(p, m, y)
          );
          l === "" && (l = (0, e.didYouMean)(
            u(m, y)
          )), c.reportError(
            new i.GraphQLError(
              `Cannot query field "${y}" on type "${m.name}".` + l,
              {
                nodes: d
              }
            )
          );
        }
      }
    };
  }
  function s(c, d, m) {
    if (!(0, t.isAbstractType)(d))
      return [];
    const o = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ Object.create(null);
    for (const l of c.getPossibleTypes(d))
      if (l.getFields()[m]) {
        o.add(l), p[l.name] = 1;
        for (const f of l.getInterfaces()) {
          var y;
          f.getFields()[m] && (o.add(f), p[f.name] = ((y = p[f.name]) !== null && y !== void 0 ? y : 0) + 1);
        }
      }
    return [...o].sort((l, f) => {
      const h = p[f.name] - p[l.name];
      return h !== 0 ? h : (0, t.isInterfaceType)(l) && c.isSubType(l, f) ? -1 : (0, t.isInterfaceType)(f) && c.isSubType(f, l) ? 1 : (0, n.naturalCompare)(l.name, f.name);
    }).map((l) => l.name);
  }
  function u(c, d) {
    if ((0, t.isObjectType)(c) || (0, t.isInterfaceType)(c)) {
      const m = Object.keys(c.getFields());
      return (0, a.suggestionList)(d, m);
    }
    return [];
  }
  return Lt;
}
var Rt = {}, wa;
function So() {
  if (wa) return Rt;
  wa = 1, Object.defineProperty(Rt, "__esModule", {
    value: !0
  }), Rt.FragmentsOnCompositeTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ Ge(), a = /* @__PURE__ */ ue(), i = /* @__PURE__ */ nn();
  function t(r) {
    return {
      InlineFragment(s) {
        const u = s.typeCondition;
        if (u) {
          const c = (0, i.typeFromAST)(
            r.getSchema(),
            u
          );
          if (c && !(0, a.isCompositeType)(c)) {
            const d = (0, n.print)(u);
            r.reportError(
              new e.GraphQLError(
                `Fragment cannot condition on non composite type "${d}".`,
                {
                  nodes: u
                }
              )
            );
          }
        }
      },
      FragmentDefinition(s) {
        const u = (0, i.typeFromAST)(
          r.getSchema(),
          s.typeCondition
        );
        if (u && !(0, a.isCompositeType)(u)) {
          const c = (0, n.print)(s.typeCondition);
          r.reportError(
            new e.GraphQLError(
              `Fragment "${s.name.value}" cannot condition on non composite type "${c}".`,
              {
                nodes: s.typeCondition
              }
            )
          );
        }
      }
    };
  }
  return Rt;
}
var Vn = {}, ka;
function Lo() {
  if (ka) return Vn;
  ka = 1, Object.defineProperty(Vn, "__esModule", {
    value: !0
  }), Vn.KnownArgumentNamesOnDirectivesRule = s, Vn.KnownArgumentNamesRule = r;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ pn(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Ve();
  function r(u) {
    return {
      // eslint-disable-next-line new-cap
      ...s(u),
      Argument(c) {
        const d = u.getArgument(), m = u.getFieldDef(), o = u.getParentType();
        if (!d && m && o) {
          const p = c.name.value, y = m.args.map((f) => f.name), l = (0, n.suggestionList)(
            p,
            y
          );
          u.reportError(
            new a.GraphQLError(
              `Unknown argument "${p}" on field "${o.name}.${m.name}".` + (0, e.didYouMean)(l),
              {
                nodes: c
              }
            )
          );
        }
      }
    };
  }
  function s(u) {
    const c = /* @__PURE__ */ Object.create(null), d = u.getSchema(), m = d ? d.getDirectives() : t.specifiedDirectives;
    for (const y of m)
      c[y.name] = y.args.map((l) => l.name);
    const o = u.getDocument().definitions;
    for (const y of o)
      if (y.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var p;
        const l = (p = y.arguments) !== null && p !== void 0 ? p : [];
        c[y.name.value] = l.map((f) => f.name.value);
      }
    return {
      Directive(y) {
        const l = y.name.value, f = c[l];
        if (y.arguments && f)
          for (const h of y.arguments) {
            const T = h.name.value;
            if (!f.includes(T)) {
              const O = (0, n.suggestionList)(
                T,
                f
              );
              u.reportError(
                new a.GraphQLError(
                  `Unknown argument "${T}" on directive "@${l}".` + (0, e.didYouMean)(O),
                  {
                    nodes: h
                  }
                )
              );
            }
          }
        return !1;
      }
    };
  }
  return Vn;
}
var Dt = {}, Va;
function Ro() {
  if (Va) return Dt;
  Va = 1, Object.defineProperty(Dt, "__esModule", {
    value: !0
  }), Dt.KnownDirectivesRule = u;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ Ze(), t = /* @__PURE__ */ Hn(), r = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Ve();
  function u(m) {
    const o = /* @__PURE__ */ Object.create(null), p = m.getSchema(), y = p ? p.getDirectives() : s.specifiedDirectives;
    for (const f of y)
      o[f.name] = f.locations;
    const l = m.getDocument().definitions;
    for (const f of l)
      f.kind === r.Kind.DIRECTIVE_DEFINITION && (o[f.name.value] = f.locations.map((h) => h.value));
    return {
      Directive(f, h, T, O, R) {
        const D = f.name.value, _ = o[D];
        if (!_) {
          m.reportError(
            new a.GraphQLError(`Unknown directive "@${D}".`, {
              nodes: f
            })
          );
          return;
        }
        const w = c(R);
        w && !_.includes(w) && m.reportError(
          new a.GraphQLError(
            `Directive "@${D}" may not be used on ${w}.`,
            {
              nodes: f
            }
          )
        );
      }
    };
  }
  function c(m) {
    const o = m[m.length - 1];
    switch ("kind" in o || (0, n.invariant)(!1), o.kind) {
      case r.Kind.OPERATION_DEFINITION:
        return d(o.operation);
      case r.Kind.FIELD:
        return t.DirectiveLocation.FIELD;
      case r.Kind.FRAGMENT_SPREAD:
        return t.DirectiveLocation.FRAGMENT_SPREAD;
      case r.Kind.INLINE_FRAGMENT:
        return t.DirectiveLocation.INLINE_FRAGMENT;
      case r.Kind.FRAGMENT_DEFINITION:
        return t.DirectiveLocation.FRAGMENT_DEFINITION;
      case r.Kind.VARIABLE_DEFINITION:
        return t.DirectiveLocation.VARIABLE_DEFINITION;
      case r.Kind.SCHEMA_DEFINITION:
      case r.Kind.SCHEMA_EXTENSION:
        return t.DirectiveLocation.SCHEMA;
      case r.Kind.SCALAR_TYPE_DEFINITION:
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return t.DirectiveLocation.SCALAR;
      case r.Kind.OBJECT_TYPE_DEFINITION:
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.OBJECT;
      case r.Kind.FIELD_DEFINITION:
        return t.DirectiveLocation.FIELD_DEFINITION;
      case r.Kind.INTERFACE_TYPE_DEFINITION:
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return t.DirectiveLocation.INTERFACE;
      case r.Kind.UNION_TYPE_DEFINITION:
      case r.Kind.UNION_TYPE_EXTENSION:
        return t.DirectiveLocation.UNION;
      case r.Kind.ENUM_TYPE_DEFINITION:
      case r.Kind.ENUM_TYPE_EXTENSION:
        return t.DirectiveLocation.ENUM;
      case r.Kind.ENUM_VALUE_DEFINITION:
        return t.DirectiveLocation.ENUM_VALUE;
      case r.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.INPUT_OBJECT;
      case r.Kind.INPUT_VALUE_DEFINITION: {
        const p = m[m.length - 3];
        return "kind" in p || (0, n.invariant)(!1), p.kind === r.Kind.INPUT_OBJECT_TYPE_DEFINITION ? t.DirectiveLocation.INPUT_FIELD_DEFINITION : t.DirectiveLocation.ARGUMENT_DEFINITION;
      }
      // Not reachable, all possible types have been considered.
      /* c8 ignore next */
      default:
        (0, n.invariant)(
          !1,
          "Unexpected kind: " + (0, e.inspect)(o.kind)
        );
    }
  }
  function d(m) {
    switch (m) {
      case i.OperationTypeNode.QUERY:
        return t.DirectiveLocation.QUERY;
      case i.OperationTypeNode.MUTATION:
        return t.DirectiveLocation.MUTATION;
      case i.OperationTypeNode.SUBSCRIPTION:
        return t.DirectiveLocation.SUBSCRIPTION;
    }
  }
  return Dt;
}
var At = {}, Ca;
function Do() {
  if (Ca) return At;
  Ca = 1, Object.defineProperty(At, "__esModule", {
    value: !0
  }), At.KnownFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    return {
      FragmentSpread(i) {
        const t = i.name.value;
        a.getFragment(t) || a.reportError(
          new e.GraphQLError(
            `Unknown fragment "${t}".`,
            {
              nodes: i.name
            }
          )
        );
      }
    };
  }
  return At;
}
var jt = {}, Ga;
function Ao() {
  if (Ga) return jt;
  Ga = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.KnownTypeNamesRule = s;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ pn(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ Dn(), t = /* @__PURE__ */ Qe(), r = /* @__PURE__ */ en();
  function s(d) {
    const m = d.getSchema(), o = m ? m.getTypeMap() : /* @__PURE__ */ Object.create(null), p = /* @__PURE__ */ Object.create(null);
    for (const l of d.getDocument().definitions)
      (0, i.isTypeDefinitionNode)(l) && (p[l.name.value] = !0);
    const y = [
      ...Object.keys(o),
      ...Object.keys(p)
    ];
    return {
      NamedType(l, f, h, T, O) {
        const R = l.name.value;
        if (!o[R] && !p[R]) {
          var D;
          const _ = (D = O[2]) !== null && D !== void 0 ? D : h, w = _ != null && c(_);
          if (w && u.includes(R))
            return;
          const M = (0, n.suggestionList)(
            R,
            w ? u.concat(y) : y
          );
          d.reportError(
            new a.GraphQLError(
              `Unknown type "${R}".` + (0, e.didYouMean)(M),
              {
                nodes: l
              }
            )
          );
        }
      }
    };
  }
  const u = [
    ...r.specifiedScalarTypes,
    ...t.introspectionTypes
  ].map((d) => d.name);
  function c(d) {
    return "kind" in d && ((0, i.isTypeSystemDefinitionNode)(d) || (0, i.isTypeSystemExtensionNode)(d));
  }
  return jt;
}
var Pt = {}, Ma;
function jo() {
  if (Ma) return Pt;
  Ma = 1, Object.defineProperty(Pt, "__esModule", {
    value: !0
  }), Pt.LoneAnonymousOperationRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  function a(i) {
    let t = 0;
    return {
      Document(r) {
        t = r.definitions.filter(
          (s) => s.kind === n.Kind.OPERATION_DEFINITION
        ).length;
      },
      OperationDefinition(r) {
        !r.name && t > 1 && i.reportError(
          new e.GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return Pt;
}
var Ft = {}, $a;
function Po() {
  if ($a) return Ft;
  $a = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.LoneSchemaDefinitionRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    var i, t, r;
    const s = a.getSchema(), u = (i = (t = (r = s == null ? void 0 : s.astNode) !== null && r !== void 0 ? r : s == null ? void 0 : s.getQueryType()) !== null && t !== void 0 ? t : s == null ? void 0 : s.getMutationType()) !== null && i !== void 0 ? i : s == null ? void 0 : s.getSubscriptionType();
    let c = 0;
    return {
      SchemaDefinition(d) {
        if (u) {
          a.reportError(
            new e.GraphQLError(
              "Cannot define a new schema within a schema extension.",
              {
                nodes: d
              }
            )
          );
          return;
        }
        c > 0 && a.reportError(
          new e.GraphQLError(
            "Must provide only one schema definition.",
            {
              nodes: d
            }
          )
        ), ++c;
      }
    };
  }
  return Ft;
}
var wt = {}, Ua;
function Fo() {
  if (Ua) return wt;
  Ua = 1, Object.defineProperty(wt, "__esModule", {
    value: !0
  }), wt.MaxIntrospectionDepthRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  const a = 3;
  function i(t) {
    function r(s, u = /* @__PURE__ */ Object.create(null), c = 0) {
      if (s.kind === n.Kind.FRAGMENT_SPREAD) {
        const d = s.name.value;
        if (u[d] === !0)
          return !1;
        const m = t.getFragment(d);
        if (!m)
          return !1;
        try {
          return u[d] = !0, r(m, u, c);
        } finally {
          u[d] = void 0;
        }
      }
      if (s.kind === n.Kind.FIELD && // check all introspection lists
      (s.name.value === "fields" || s.name.value === "interfaces" || s.name.value === "possibleTypes" || s.name.value === "inputFields") && (c++, c >= a))
        return !0;
      if ("selectionSet" in s && s.selectionSet) {
        for (const d of s.selectionSet.selections)
          if (r(d, u, c))
            return !0;
      }
      return !1;
    }
    return {
      Field(s) {
        if ((s.name.value === "__schema" || s.name.value === "__type") && r(s))
          return t.reportError(
            new e.GraphQLError(
              "Maximum introspection depth exceeded",
              {
                nodes: [s]
              }
            )
          ), !1;
      }
    };
  }
  return wt;
}
var kt = {}, Qa;
function wo() {
  if (Qa) return kt;
  Qa = 1, Object.defineProperty(kt, "__esModule", {
    value: !0
  }), kt.NoFragmentCyclesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = [], r = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(u) {
        return s(u), !1;
      }
    };
    function s(u) {
      if (i[u.name.value])
        return;
      const c = u.name.value;
      i[c] = !0;
      const d = a.getFragmentSpreads(u.selectionSet);
      if (d.length !== 0) {
        r[c] = t.length;
        for (const m of d) {
          const o = m.name.value, p = r[o];
          if (t.push(m), p === void 0) {
            const y = a.getFragment(o);
            y && s(y);
          } else {
            const y = t.slice(p), l = y.slice(0, -1).map((f) => '"' + f.name.value + '"').join(", ");
            a.reportError(
              new e.GraphQLError(
                `Cannot spread fragment "${o}" within itself` + (l !== "" ? ` via ${l}.` : "."),
                {
                  nodes: y
                }
              )
            );
          }
          t.pop();
        }
        r[c] = void 0;
      }
    }
  }
  return kt;
}
var Vt = {}, qa;
function ko() {
  if (qa) return Vt;
  qa = 1, Object.defineProperty(Vt, "__esModule", {
    value: !0
  }), Vt.NoUndefinedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    let i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          i = /* @__PURE__ */ Object.create(null);
        },
        leave(t) {
          const r = a.getRecursiveVariableUsages(t);
          for (const { node: s } of r) {
            const u = s.name.value;
            i[u] !== !0 && a.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${u}" is not defined by operation "${t.name.value}".` : `Variable "$${u}" is not defined.`,
                {
                  nodes: [s, t]
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i[t.variable.name.value] = !0;
      }
    };
  }
  return Vt;
}
var Ct = {}, Ka;
function Vo() {
  if (Ka) return Ct;
  Ka = 1, Object.defineProperty(Ct, "__esModule", {
    value: !0
  }), Ct.NoUnusedFragmentsRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = [], t = [];
    return {
      OperationDefinition(r) {
        return i.push(r), !1;
      },
      FragmentDefinition(r) {
        return t.push(r), !1;
      },
      Document: {
        leave() {
          const r = /* @__PURE__ */ Object.create(null);
          for (const s of i)
            for (const u of a.getRecursivelyReferencedFragments(
              s
            ))
              r[u.name.value] = !0;
          for (const s of t) {
            const u = s.name.value;
            r[u] !== !0 && a.reportError(
              new e.GraphQLError(
                `Fragment "${u}" is never used.`,
                {
                  nodes: s
                }
              )
            );
          }
        }
      }
    };
  }
  return Ct;
}
var Gt = {}, xa;
function Co() {
  if (xa) return Gt;
  xa = 1, Object.defineProperty(Gt, "__esModule", {
    value: !0
  }), Gt.NoUnusedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    let i = [];
    return {
      OperationDefinition: {
        enter() {
          i = [];
        },
        leave(t) {
          const r = /* @__PURE__ */ Object.create(null), s = a.getRecursiveVariableUsages(t);
          for (const { node: u } of s)
            r[u.name.value] = !0;
          for (const u of i) {
            const c = u.variable.name.value;
            r[c] !== !0 && a.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${c}" is never used in operation "${t.name.value}".` : `Variable "$${c}" is never used.`,
                {
                  nodes: u
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i.push(t);
      }
    };
  }
  return Gt;
}
var Mt = {}, $t = {}, Ba;
function Go() {
  if (Ba) return $t;
  Ba = 1, Object.defineProperty($t, "__esModule", {
    value: !0
  }), $t.sortValueNode = a;
  var e = /* @__PURE__ */ Vr(), n = /* @__PURE__ */ oe();
  function a(t) {
    switch (t.kind) {
      case n.Kind.OBJECT:
        return { ...t, fields: i(t.fields) };
      case n.Kind.LIST:
        return { ...t, values: t.values.map(a) };
      case n.Kind.INT:
      case n.Kind.FLOAT:
      case n.Kind.STRING:
      case n.Kind.BOOLEAN:
      case n.Kind.NULL:
      case n.Kind.ENUM:
      case n.Kind.VARIABLE:
        return t;
    }
  }
  function i(t) {
    return t.map((r) => ({
      ...r,
      value: a(r.value)
    })).sort(
      (r, s) => (0, e.naturalCompare)(r.name.value, s.name.value)
    );
  }
  return $t;
}
var Ya;
function Mo() {
  if (Ya) return Mt;
  Ya = 1, Object.defineProperty(Mt, "__esModule", {
    value: !0
  }), Mt.OverlappingFieldsCanBeMergedRule = c;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Ge(), t = /* @__PURE__ */ ue(), r = /* @__PURE__ */ Go(), s = /* @__PURE__ */ nn();
  function u(N) {
    return Array.isArray(N) ? N.map(
      ([g, L]) => `subfields "${g}" conflict because ` + u(L)
    ).join(" and ") : N;
  }
  function c(N) {
    const g = new M(), L = new V(), E = /* @__PURE__ */ new Map();
    return {
      SelectionSet(v) {
        const b = d(
          N,
          E,
          g,
          L,
          N.getParentType(),
          v
        );
        for (const [[I, S], j, k] of b) {
          const U = u(S);
          N.reportError(
            new n.GraphQLError(
              `Fields "${I}" conflict because ${U}. Use different aliases on the fields to fetch both if this was intentional.`,
              {
                nodes: j.concat(k)
              }
            )
          );
        }
      }
    };
  }
  function d(N, g, L, E, v, b) {
    const I = [], [S, j] = R(
      N,
      g,
      v,
      b
    );
    if (y(
      N,
      I,
      g,
      L,
      E,
      S
    ), j.length !== 0)
      for (let k = 0; k < j.length; k++) {
        m(
          N,
          I,
          g,
          L,
          E,
          !1,
          S,
          j[k]
        );
        for (let U = k + 1; U < j.length; U++)
          o(
            N,
            I,
            g,
            L,
            E,
            !1,
            j[k],
            j[U]
          );
      }
    return I;
  }
  function m(N, g, L, E, v, b, I, S) {
    if (E.has(
      I,
      S,
      b
    ))
      return;
    E.add(
      I,
      S,
      b
    );
    const j = N.getFragment(S);
    if (!j)
      return;
    const [k, U] = D(
      N,
      L,
      j
    );
    if (I !== k) {
      l(
        N,
        g,
        L,
        E,
        v,
        b,
        I,
        k
      );
      for (const W of U)
        m(
          N,
          g,
          L,
          E,
          v,
          b,
          I,
          W
        );
    }
  }
  function o(N, g, L, E, v, b, I, S) {
    if (I === S || v.has(
      I,
      S,
      b
    ))
      return;
    v.add(I, S, b);
    const j = N.getFragment(I), k = N.getFragment(S);
    if (!j || !k)
      return;
    const [U, W] = D(
      N,
      L,
      j
    ), [P, K] = D(
      N,
      L,
      k
    );
    l(
      N,
      g,
      L,
      E,
      v,
      b,
      U,
      P
    );
    for (const te of K)
      o(
        N,
        g,
        L,
        E,
        v,
        b,
        I,
        te
      );
    for (const te of W)
      o(
        N,
        g,
        L,
        E,
        v,
        b,
        te,
        S
      );
  }
  function p(N, g, L, E, v, b, I, S, j) {
    const k = [], [U, W] = R(
      N,
      g,
      b,
      I
    ), [P, K] = R(
      N,
      g,
      S,
      j
    );
    l(
      N,
      k,
      g,
      L,
      E,
      v,
      U,
      P
    );
    for (const te of K)
      m(
        N,
        k,
        g,
        L,
        E,
        v,
        U,
        te
      );
    for (const te of W)
      m(
        N,
        k,
        g,
        L,
        E,
        v,
        P,
        te
      );
    for (const te of W)
      for (const pe of K)
        o(
          N,
          k,
          g,
          L,
          E,
          v,
          te,
          pe
        );
    return k;
  }
  function y(N, g, L, E, v, b) {
    for (const [I, S] of Object.entries(b))
      if (S.length > 1)
        for (let j = 0; j < S.length; j++)
          for (let k = j + 1; k < S.length; k++) {
            const U = f(
              N,
              L,
              E,
              v,
              !1,
              // within one collection is never mutually exclusive
              I,
              S[j],
              S[k]
            );
            U && g.push(U);
          }
  }
  function l(N, g, L, E, v, b, I, S) {
    for (const [j, k] of Object.entries(I)) {
      const U = S[j];
      if (U)
        for (const W of k)
          for (const P of U) {
            const K = f(
              N,
              L,
              E,
              v,
              b,
              j,
              W,
              P
            );
            K && g.push(K);
          }
    }
  }
  function f(N, g, L, E, v, b, I, S) {
    const [j, k, U] = I, [W, P, K] = S, te = v || j !== W && (0, t.isObjectType)(j) && (0, t.isObjectType)(W);
    if (!te) {
      const B = k.name.value, ee = P.name.value;
      if (B !== ee)
        return [
          [b, `"${B}" and "${ee}" are different fields`],
          [k],
          [P]
        ];
      if (!h(k, P))
        return [
          [b, "they have differing arguments"],
          [k],
          [P]
        ];
    }
    const pe = U == null ? void 0 : U.type, G = K == null ? void 0 : K.type;
    if (pe && G && O(pe, G))
      return [
        [
          b,
          `they return conflicting types "${(0, e.inspect)(
            pe
          )}" and "${(0, e.inspect)(G)}"`
        ],
        [k],
        [P]
      ];
    const $ = k.selectionSet, x = P.selectionSet;
    if ($ && x) {
      const B = p(
        N,
        g,
        L,
        E,
        te,
        (0, t.getNamedType)(pe),
        $,
        (0, t.getNamedType)(G),
        x
      );
      return w(B, b, k, P);
    }
  }
  function h(N, g) {
    const L = N.arguments, E = g.arguments;
    if (L === void 0 || L.length === 0)
      return E === void 0 || E.length === 0;
    if (E === void 0 || E.length === 0 || L.length !== E.length)
      return !1;
    const v = new Map(E.map(({ name: b, value: I }) => [b.value, I]));
    return L.every((b) => {
      const I = b.value, S = v.get(b.name.value);
      return S === void 0 ? !1 : T(I) === T(S);
    });
  }
  function T(N) {
    return (0, i.print)((0, r.sortValueNode)(N));
  }
  function O(N, g) {
    return (0, t.isListType)(N) ? (0, t.isListType)(g) ? O(N.ofType, g.ofType) : !0 : (0, t.isListType)(g) ? !0 : (0, t.isNonNullType)(N) ? (0, t.isNonNullType)(g) ? O(N.ofType, g.ofType) : !0 : (0, t.isNonNullType)(g) ? !0 : (0, t.isLeafType)(N) || (0, t.isLeafType)(g) ? N !== g : !1;
  }
  function R(N, g, L, E) {
    const v = g.get(E);
    if (v)
      return v;
    const b = /* @__PURE__ */ Object.create(null), I = /* @__PURE__ */ Object.create(null);
    _(
      N,
      L,
      E,
      b,
      I
    );
    const S = [b, Object.keys(I)];
    return g.set(E, S), S;
  }
  function D(N, g, L) {
    const E = g.get(L.selectionSet);
    if (E)
      return E;
    const v = (0, s.typeFromAST)(
      N.getSchema(),
      L.typeCondition
    );
    return R(
      N,
      g,
      v,
      L.selectionSet
    );
  }
  function _(N, g, L, E, v) {
    for (const b of L.selections)
      switch (b.kind) {
        case a.Kind.FIELD: {
          const I = b.name.value;
          let S;
          ((0, t.isObjectType)(g) || (0, t.isInterfaceType)(g)) && (S = g.getFields()[I]);
          const j = b.alias ? b.alias.value : I;
          E[j] || (E[j] = []), E[j].push([g, b, S]);
          break;
        }
        case a.Kind.FRAGMENT_SPREAD:
          v[b.name.value] = !0;
          break;
        case a.Kind.INLINE_FRAGMENT: {
          const I = b.typeCondition, S = I ? (0, s.typeFromAST)(N.getSchema(), I) : g;
          _(
            N,
            S,
            b.selectionSet,
            E,
            v
          );
          break;
        }
      }
  }
  function w(N, g, L, E) {
    if (N.length > 0)
      return [
        [g, N.map(([v]) => v)],
        [L, ...N.map(([, v]) => v).flat()],
        [E, ...N.map(([, , v]) => v).flat()]
      ];
  }
  class M {
    constructor() {
      this._data = /* @__PURE__ */ new Map();
    }
    has(g, L, E) {
      var v;
      const b = (v = this._data.get(g)) === null || v === void 0 ? void 0 : v.get(L);
      return b === void 0 ? !1 : E ? !0 : E === b;
    }
    add(g, L, E) {
      const v = this._data.get(g);
      v === void 0 ? this._data.set(g, /* @__PURE__ */ new Map([[L, E]])) : v.set(L, E);
    }
  }
  class V {
    constructor() {
      this._orderedPairSet = new M();
    }
    has(g, L, E) {
      return g < L ? this._orderedPairSet.has(g, L, E) : this._orderedPairSet.has(L, g, E);
    }
    add(g, L, E) {
      g < L ? this._orderedPairSet.add(g, L, E) : this._orderedPairSet.add(L, g, E);
    }
  }
  return Mt;
}
var Ut = {}, Ja;
function $o() {
  if (Ja) return Ut;
  Ja = 1, Object.defineProperty(Ut, "__esModule", {
    value: !0
  }), Ut.PossibleFragmentSpreadsRule = r;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ ue(), i = /* @__PURE__ */ Gr(), t = /* @__PURE__ */ nn();
  function r(u) {
    return {
      InlineFragment(c) {
        const d = u.getType(), m = u.getParentType();
        if ((0, a.isCompositeType)(d) && (0, a.isCompositeType)(m) && !(0, i.doTypesOverlap)(
          u.getSchema(),
          d,
          m
        )) {
          const o = (0, e.inspect)(m), p = (0, e.inspect)(d);
          u.reportError(
            new n.GraphQLError(
              `Fragment cannot be spread here as objects of type "${o}" can never be of type "${p}".`,
              {
                nodes: c
              }
            )
          );
        }
      },
      FragmentSpread(c) {
        const d = c.name.value, m = s(u, d), o = u.getParentType();
        if (m && o && !(0, i.doTypesOverlap)(
          u.getSchema(),
          m,
          o
        )) {
          const p = (0, e.inspect)(o), y = (0, e.inspect)(m);
          u.reportError(
            new n.GraphQLError(
              `Fragment "${d}" cannot be spread here as objects of type "${p}" can never be of type "${y}".`,
              {
                nodes: c
              }
            )
          );
        }
      }
    };
  }
  function s(u, c) {
    const d = u.getFragment(c);
    if (d) {
      const m = (0, t.typeFromAST)(
        u.getSchema(),
        d.typeCondition
      );
      if ((0, a.isCompositeType)(m))
        return m;
    }
  }
  return Ut;
}
var Qt = {}, za;
function Uo() {
  if (za) return Qt;
  za = 1, Object.defineProperty(Qt, "__esModule", {
    value: !0
  }), Qt.PossibleTypeExtensionsRule = c;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Re(), i = /* @__PURE__ */ pn(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Dn(), u = /* @__PURE__ */ ue();
  function c(p) {
    const y = p.getSchema(), l = /* @__PURE__ */ Object.create(null);
    for (const h of p.getDocument().definitions)
      (0, s.isTypeDefinitionNode)(h) && (l[h.name.value] = h);
    return {
      ScalarTypeExtension: f,
      ObjectTypeExtension: f,
      InterfaceTypeExtension: f,
      UnionTypeExtension: f,
      EnumTypeExtension: f,
      InputObjectTypeExtension: f
    };
    function f(h) {
      const T = h.name.value, O = l[T], R = y == null ? void 0 : y.getType(T);
      let D;
      if (O ? D = d[O.kind] : R && (D = m(R)), D) {
        if (D !== h.kind) {
          const _ = o(h.kind);
          p.reportError(
            new t.GraphQLError(
              `Cannot extend non-${_} type "${T}".`,
              {
                nodes: O ? [O, h] : h
              }
            )
          );
        }
      } else {
        const _ = Object.keys({
          ...l,
          ...y == null ? void 0 : y.getTypeMap()
        }), w = (0, i.suggestionList)(
          T,
          _
        );
        p.reportError(
          new t.GraphQLError(
            `Cannot extend type "${T}" because it is not defined.` + (0, e.didYouMean)(w),
            {
              nodes: h.name
            }
          )
        );
      }
    }
  }
  const d = {
    [r.Kind.SCALAR_TYPE_DEFINITION]: r.Kind.SCALAR_TYPE_EXTENSION,
    [r.Kind.OBJECT_TYPE_DEFINITION]: r.Kind.OBJECT_TYPE_EXTENSION,
    [r.Kind.INTERFACE_TYPE_DEFINITION]: r.Kind.INTERFACE_TYPE_EXTENSION,
    [r.Kind.UNION_TYPE_DEFINITION]: r.Kind.UNION_TYPE_EXTENSION,
    [r.Kind.ENUM_TYPE_DEFINITION]: r.Kind.ENUM_TYPE_EXTENSION,
    [r.Kind.INPUT_OBJECT_TYPE_DEFINITION]: r.Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
  function m(p) {
    if ((0, u.isScalarType)(p))
      return r.Kind.SCALAR_TYPE_EXTENSION;
    if ((0, u.isObjectType)(p))
      return r.Kind.OBJECT_TYPE_EXTENSION;
    if ((0, u.isInterfaceType)(p))
      return r.Kind.INTERFACE_TYPE_EXTENSION;
    if ((0, u.isUnionType)(p))
      return r.Kind.UNION_TYPE_EXTENSION;
    if ((0, u.isEnumType)(p))
      return r.Kind.ENUM_TYPE_EXTENSION;
    if ((0, u.isInputObjectType)(p))
      return r.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    (0, a.invariant)(
      !1,
      "Unexpected type: " + (0, n.inspect)(p)
    );
  }
  function o(p) {
    switch (p) {
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case r.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case r.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      // Not reachable. All possible types have been considered
      /* c8 ignore next */
      default:
        (0, a.invariant)(
          !1,
          "Unexpected kind: " + (0, n.inspect)(p)
        );
    }
  }
  return Qt;
}
var Cn = {}, Xa;
function Qo() {
  if (Xa) return Cn;
  Xa = 1, Object.defineProperty(Cn, "__esModule", {
    value: !0
  }), Cn.ProvidedRequiredArgumentsOnDirectivesRule = c, Cn.ProvidedRequiredArgumentsRule = u;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ln(), a = /* @__PURE__ */ ne(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Ge(), r = /* @__PURE__ */ ue(), s = /* @__PURE__ */ Ve();
  function u(m) {
    return {
      // eslint-disable-next-line new-cap
      ...c(m),
      Field: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(o) {
          var p;
          const y = m.getFieldDef();
          if (!y)
            return !1;
          const l = new Set(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */
            (p = o.arguments) === null || p === void 0 ? void 0 : p.map((f) => f.name.value)
          );
          for (const f of y.args)
            if (!l.has(f.name) && (0, r.isRequiredArgument)(f)) {
              const h = (0, e.inspect)(f.type);
              m.reportError(
                new a.GraphQLError(
                  `Field "${y.name}" argument "${f.name}" of type "${h}" is required, but it was not provided.`,
                  {
                    nodes: o
                  }
                )
              );
            }
        }
      }
    };
  }
  function c(m) {
    var o;
    const p = /* @__PURE__ */ Object.create(null), y = m.getSchema(), l = (o = y == null ? void 0 : y.getDirectives()) !== null && o !== void 0 ? o : s.specifiedDirectives;
    for (const T of l)
      p[T.name] = (0, n.keyMap)(
        T.args.filter(r.isRequiredArgument),
        (O) => O.name
      );
    const f = m.getDocument().definitions;
    for (const T of f)
      if (T.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var h;
        const O = (h = T.arguments) !== null && h !== void 0 ? h : [];
        p[T.name.value] = (0, n.keyMap)(
          O.filter(d),
          (R) => R.name.value
        );
      }
    return {
      Directive: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(T) {
          const O = T.name.value, R = p[O];
          if (R) {
            var D;
            const _ = (D = T.arguments) !== null && D !== void 0 ? D : [], w = new Set(_.map((M) => M.name.value));
            for (const [M, V] of Object.entries(R))
              if (!w.has(M)) {
                const N = (0, r.isType)(V.type) ? (0, e.inspect)(V.type) : (0, t.print)(V.type);
                m.reportError(
                  new a.GraphQLError(
                    `Directive "@${O}" argument "${M}" of type "${N}" is required, but it was not provided.`,
                    {
                      nodes: T
                    }
                  )
                );
              }
          }
        }
      }
    };
  }
  function d(m) {
    return m.type.kind === i.Kind.NON_NULL_TYPE && m.defaultValue == null;
  }
  return Cn;
}
var qt = {}, Ha;
function qo() {
  if (Ha) return qt;
  Ha = 1, Object.defineProperty(qt, "__esModule", {
    value: !0
  }), qt.ScalarLeafsRule = i;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ ue();
  function i(t) {
    return {
      Field(r) {
        const s = t.getType(), u = r.selectionSet;
        if (s)
          if ((0, a.isLeafType)((0, a.getNamedType)(s))) {
            if (u) {
              const c = r.name.value, d = (0, e.inspect)(s);
              t.reportError(
                new n.GraphQLError(
                  `Field "${c}" must not have a selection since type "${d}" has no subfields.`,
                  {
                    nodes: u
                  }
                )
              );
            }
          } else if (u) {
            if (u.selections.length === 0) {
              const c = r.name.value, d = (0, e.inspect)(s);
              t.reportError(
                new n.GraphQLError(
                  `Field "${c}" of type "${d}" must have at least one field selected.`,
                  {
                    nodes: r
                  }
                )
              );
            }
          } else {
            const c = r.name.value, d = (0, e.inspect)(s);
            t.reportError(
              new n.GraphQLError(
                `Field "${c}" of type "${d}" must have a selection of subfields. Did you mean "${c} { ... }"?`,
                {
                  nodes: r
                }
              )
            );
          }
      }
    };
  }
  return qt;
}
var Kt = {}, Gn = {}, Nn = {}, xt = {}, Wa;
function Ko() {
  if (Wa) return xt;
  Wa = 1, Object.defineProperty(xt, "__esModule", {
    value: !0
  }), xt.printPathArray = e;
  function e(n) {
    return n.map(
      (a) => typeof a == "number" ? "[" + a.toString() + "]" : "." + a
    ).join("");
  }
  return xt;
}
var Bt = {}, Mn = {}, Za;
function Ur() {
  if (Za) return Mn;
  Za = 1, Object.defineProperty(Mn, "__esModule", {
    value: !0
  }), Mn.addPath = e, Mn.pathToArray = n;
  function e(a, i, t) {
    return {
      prev: a,
      key: i,
      typename: t
    };
  }
  function n(a) {
    const i = [];
    let t = a;
    for (; t; )
      i.push(t.key), t = t.prev;
    return i.reverse();
  }
  return Mn;
}
var es;
function xo() {
  if (es) return Bt;
  es = 1, Object.defineProperty(Bt, "__esModule", {
    value: !0
  }), Bt.coerceInputValue = m;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Re(), i = /* @__PURE__ */ bi(), t = /* @__PURE__ */ We(), r = /* @__PURE__ */ Ur(), s = /* @__PURE__ */ Ko(), u = /* @__PURE__ */ pn(), c = /* @__PURE__ */ ne(), d = /* @__PURE__ */ ue();
  function m(y, l, f = o) {
    return p(y, l, f, void 0);
  }
  function o(y, l, f) {
    let h = "Invalid value " + (0, n.inspect)(l);
    throw y.length > 0 && (h += ` at "value${(0, s.printPathArray)(y)}"`), f.message = h + ": " + f.message, f;
  }
  function p(y, l, f, h) {
    if ((0, d.isNonNullType)(l)) {
      if (y != null)
        return p(y, l.ofType, f, h);
      f(
        (0, r.pathToArray)(h),
        y,
        new c.GraphQLError(
          `Expected non-nullable type "${(0, n.inspect)(
            l
          )}" not to be null.`
        )
      );
      return;
    }
    if (y == null)
      return null;
    if ((0, d.isListType)(l)) {
      const T = l.ofType;
      return (0, i.isIterableObject)(y) ? Array.from(y, (O, R) => {
        const D = (0, r.addPath)(h, R, void 0);
        return p(O, T, f, D);
      }) : [p(y, T, f, h)];
    }
    if ((0, d.isInputObjectType)(l)) {
      if (!(0, t.isObjectLike)(y)) {
        f(
          (0, r.pathToArray)(h),
          y,
          new c.GraphQLError(
            `Expected type "${l.name}" to be an object.`
          )
        );
        return;
      }
      const T = {}, O = l.getFields();
      for (const R of Object.values(O)) {
        const D = y[R.name];
        if (D === void 0) {
          if (R.defaultValue !== void 0)
            T[R.name] = R.defaultValue;
          else if ((0, d.isNonNullType)(R.type)) {
            const _ = (0, n.inspect)(R.type);
            f(
              (0, r.pathToArray)(h),
              y,
              new c.GraphQLError(
                `Field "${R.name}" of required type "${_}" was not provided.`
              )
            );
          }
          continue;
        }
        T[R.name] = p(
          D,
          R.type,
          f,
          (0, r.addPath)(h, R.name, l.name)
        );
      }
      for (const R of Object.keys(y))
        if (!O[R]) {
          const D = (0, u.suggestionList)(
            R,
            Object.keys(l.getFields())
          );
          f(
            (0, r.pathToArray)(h),
            y,
            new c.GraphQLError(
              `Field "${R}" is not defined by type "${l.name}".` + (0, e.didYouMean)(D)
            )
          );
        }
      if (l.isOneOf) {
        const R = Object.keys(T);
        R.length !== 1 && f(
          (0, r.pathToArray)(h),
          y,
          new c.GraphQLError(
            `Exactly one key must be specified for OneOf type "${l.name}".`
          )
        );
        const D = R[0], _ = T[D];
        _ === null && f(
          (0, r.pathToArray)(h).concat(D),
          _,
          new c.GraphQLError(`Field "${D}" must be non-null.`)
        );
      }
      return T;
    }
    if ((0, d.isLeafType)(l)) {
      let T;
      try {
        T = l.parseValue(y);
      } catch (O) {
        O instanceof c.GraphQLError ? f((0, r.pathToArray)(h), y, O) : f(
          (0, r.pathToArray)(h),
          y,
          new c.GraphQLError(
            `Expected type "${l.name}". ` + O.message,
            {
              originalError: O
            }
          )
        );
        return;
      }
      return T === void 0 && f(
        (0, r.pathToArray)(h),
        y,
        new c.GraphQLError(`Expected type "${l.name}".`)
      ), T;
    }
    (0, a.invariant)(
      !1,
      "Unexpected input type: " + (0, n.inspect)(l)
    );
  }
  return Bt;
}
var Yt = {}, ns;
function Qr() {
  if (ns) return Yt;
  ns = 1, Object.defineProperty(Yt, "__esModule", {
    value: !0
  }), Yt.valueFromAST = r;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ ln(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ ue();
  function r(u, c, d) {
    if (u) {
      if (u.kind === i.Kind.VARIABLE) {
        const m = u.name.value;
        if (d == null || d[m] === void 0)
          return;
        const o = d[m];
        return o === null && (0, t.isNonNullType)(c) ? void 0 : o;
      }
      if ((0, t.isNonNullType)(c))
        return u.kind === i.Kind.NULL ? void 0 : r(u, c.ofType, d);
      if (u.kind === i.Kind.NULL)
        return null;
      if ((0, t.isListType)(c)) {
        const m = c.ofType;
        if (u.kind === i.Kind.LIST) {
          const p = [];
          for (const y of u.values)
            if (s(y, d)) {
              if ((0, t.isNonNullType)(m))
                return;
              p.push(null);
            } else {
              const l = r(y, m, d);
              if (l === void 0)
                return;
              p.push(l);
            }
          return p;
        }
        const o = r(u, m, d);
        return o === void 0 ? void 0 : [o];
      }
      if ((0, t.isInputObjectType)(c)) {
        if (u.kind !== i.Kind.OBJECT)
          return;
        const m = /* @__PURE__ */ Object.create(null), o = (0, a.keyMap)(
          u.fields,
          (p) => p.name.value
        );
        for (const p of Object.values(c.getFields())) {
          const y = o[p.name];
          if (!y || s(y.value, d)) {
            if (p.defaultValue !== void 0)
              m[p.name] = p.defaultValue;
            else if ((0, t.isNonNullType)(p.type))
              return;
            continue;
          }
          const l = r(y.value, p.type, d);
          if (l === void 0)
            return;
          m[p.name] = l;
        }
        if (c.isOneOf) {
          const p = Object.keys(m);
          if (p.length !== 1 || m[p[0]] === null)
            return;
        }
        return m;
      }
      if ((0, t.isLeafType)(c)) {
        let m;
        try {
          m = c.parseLiteral(u, d);
        } catch {
          return;
        }
        return m === void 0 ? void 0 : m;
      }
      (0, n.invariant)(
        !1,
        "Unexpected input type: " + (0, e.inspect)(c)
      );
    }
  }
  function s(u, c) {
    return u.kind === i.Kind.VARIABLE && (c == null || c[u.name.value] === void 0);
  }
  return Yt;
}
var ts;
function Zn() {
  if (ts) return Nn;
  ts = 1, Object.defineProperty(Nn, "__esModule", {
    value: !0
  }), Nn.getArgumentValues = p, Nn.getDirectiveValues = y, Nn.getVariableValues = m;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ln(), a = /* @__PURE__ */ Ko(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Ge(), s = /* @__PURE__ */ ue(), u = /* @__PURE__ */ xo(), c = /* @__PURE__ */ nn(), d = /* @__PURE__ */ Qr();
  function m(f, h, T, O) {
    const R = [], D = O == null ? void 0 : O.maxErrors;
    try {
      const _ = o(
        f,
        h,
        T,
        (w) => {
          if (D != null && R.length >= D)
            throw new i.GraphQLError(
              "Too many errors processing variables, error limit reached. Execution aborted."
            );
          R.push(w);
        }
      );
      if (R.length === 0)
        return {
          coerced: _
        };
    } catch (_) {
      R.push(_);
    }
    return {
      errors: R
    };
  }
  function o(f, h, T, O) {
    const R = {};
    for (const D of h) {
      const _ = D.variable.name.value, w = (0, c.typeFromAST)(f, D.type);
      if (!(0, s.isInputType)(w)) {
        const V = (0, r.print)(D.type);
        O(
          new i.GraphQLError(
            `Variable "$${_}" expected value of type "${V}" which cannot be used as an input type.`,
            {
              nodes: D.type
            }
          )
        );
        continue;
      }
      if (!l(T, _)) {
        if (D.defaultValue)
          R[_] = (0, d.valueFromAST)(
            D.defaultValue,
            w
          );
        else if ((0, s.isNonNullType)(w)) {
          const V = (0, e.inspect)(w);
          O(
            new i.GraphQLError(
              `Variable "$${_}" of required type "${V}" was not provided.`,
              {
                nodes: D
              }
            )
          );
        }
        continue;
      }
      const M = T[_];
      if (M === null && (0, s.isNonNullType)(w)) {
        const V = (0, e.inspect)(w);
        O(
          new i.GraphQLError(
            `Variable "$${_}" of non-null type "${V}" must not be null.`,
            {
              nodes: D
            }
          )
        );
        continue;
      }
      R[_] = (0, u.coerceInputValue)(
        M,
        w,
        (V, N, g) => {
          let L = `Variable "$${_}" got invalid value ` + (0, e.inspect)(N);
          V.length > 0 && (L += ` at "${_}${(0, a.printPathArray)(
            V
          )}"`), O(
            new i.GraphQLError(L + "; " + g.message, {
              nodes: D,
              originalError: g
            })
          );
        }
      );
    }
    return R;
  }
  function p(f, h, T) {
    var O;
    const R = {}, D = (O = h.arguments) !== null && O !== void 0 ? O : [], _ = (0, n.keyMap)(
      D,
      (w) => w.name.value
    );
    for (const w of f.args) {
      const M = w.name, V = w.type, N = _[M];
      if (!N) {
        if (w.defaultValue !== void 0)
          R[M] = w.defaultValue;
        else if ((0, s.isNonNullType)(V))
          throw new i.GraphQLError(
            `Argument "${M}" of required type "${(0, e.inspect)(
              V
            )}" was not provided.`,
            {
              nodes: h
            }
          );
        continue;
      }
      const g = N.value;
      let L = g.kind === t.Kind.NULL;
      if (g.kind === t.Kind.VARIABLE) {
        const v = g.name.value;
        if (T == null || !l(T, v)) {
          if (w.defaultValue !== void 0)
            R[M] = w.defaultValue;
          else if ((0, s.isNonNullType)(V))
            throw new i.GraphQLError(
              `Argument "${M}" of required type "${(0, e.inspect)(
                V
              )}" was provided the variable "$${v}" which was not provided a runtime value.`,
              {
                nodes: g
              }
            );
          continue;
        }
        L = T[v] == null;
      }
      if (L && (0, s.isNonNullType)(V))
        throw new i.GraphQLError(
          `Argument "${M}" of non-null type "${(0, e.inspect)(
            V
          )}" must not be null.`,
          {
            nodes: g
          }
        );
      const E = (0, d.valueFromAST)(
        g,
        V,
        T
      );
      if (E === void 0)
        throw new i.GraphQLError(
          `Argument "${M}" has invalid value ${(0, r.print)(
            g
          )}.`,
          {
            nodes: g
          }
        );
      R[M] = E;
    }
    return R;
  }
  function y(f, h, T) {
    var O;
    const R = (O = h.directives) === null || O === void 0 ? void 0 : O.find(
      (D) => D.name.value === f.name
    );
    if (R)
      return p(f, R, T);
  }
  function l(f, h) {
    return Object.prototype.hasOwnProperty.call(f, h);
  }
  return Nn;
}
var rs;
function Ei() {
  if (rs) return Gn;
  rs = 1, Object.defineProperty(Gn, "__esModule", {
    value: !0
  }), Gn.collectFields = r, Gn.collectSubfields = s;
  var e = /* @__PURE__ */ oe(), n = /* @__PURE__ */ ue(), a = /* @__PURE__ */ Ve(), i = /* @__PURE__ */ nn(), t = /* @__PURE__ */ Zn();
  function r(o, p, y, l, f) {
    const h = /* @__PURE__ */ new Map();
    return u(
      o,
      p,
      y,
      l,
      f,
      h,
      /* @__PURE__ */ new Set()
    ), h;
  }
  function s(o, p, y, l, f) {
    const h = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Set();
    for (const O of f)
      O.selectionSet && u(
        o,
        p,
        y,
        l,
        O.selectionSet,
        h,
        T
      );
    return h;
  }
  function u(o, p, y, l, f, h, T) {
    for (const O of f.selections)
      switch (O.kind) {
        case e.Kind.FIELD: {
          if (!c(y, O))
            continue;
          const R = m(O), D = h.get(R);
          D !== void 0 ? D.push(O) : h.set(R, [O]);
          break;
        }
        case e.Kind.INLINE_FRAGMENT: {
          if (!c(y, O) || !d(o, O, l))
            continue;
          u(
            o,
            p,
            y,
            l,
            O.selectionSet,
            h,
            T
          );
          break;
        }
        case e.Kind.FRAGMENT_SPREAD: {
          const R = O.name.value;
          if (T.has(R) || !c(y, O))
            continue;
          T.add(R);
          const D = p[R];
          if (!D || !d(o, D, l))
            continue;
          u(
            o,
            p,
            y,
            l,
            D.selectionSet,
            h,
            T
          );
          break;
        }
      }
  }
  function c(o, p) {
    const y = (0, t.getDirectiveValues)(
      a.GraphQLSkipDirective,
      p,
      o
    );
    if ((y == null ? void 0 : y.if) === !0)
      return !1;
    const l = (0, t.getDirectiveValues)(
      a.GraphQLIncludeDirective,
      p,
      o
    );
    return (l == null ? void 0 : l.if) !== !1;
  }
  function d(o, p, y) {
    const l = p.typeCondition;
    if (!l)
      return !0;
    const f = (0, i.typeFromAST)(
      o,
      l
    );
    return f === y ? !0 : (0, n.isAbstractType)(f) ? o.isSubType(f, y) : !1;
  }
  function m(o) {
    return o.alias ? o.alias.value : o.name.value;
  }
  return Gn;
}
var is;
function Bo() {
  if (is) return Kt;
  is = 1, Object.defineProperty(Kt, "__esModule", {
    value: !0
  }), Kt.SingleFieldSubscriptionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Ei();
  function i(t) {
    return {
      OperationDefinition(r) {
        if (r.operation === "subscription") {
          const s = t.getSchema(), u = s.getSubscriptionType();
          if (u) {
            const c = r.name ? r.name.value : null, d = /* @__PURE__ */ Object.create(null), m = t.getDocument(), o = /* @__PURE__ */ Object.create(null);
            for (const y of m.definitions)
              y.kind === n.Kind.FRAGMENT_DEFINITION && (o[y.name.value] = y);
            const p = (0, a.collectFields)(
              s,
              o,
              d,
              u,
              r.selectionSet
            );
            if (p.size > 1) {
              const f = [...p.values()].slice(1).flat();
              t.reportError(
                new e.GraphQLError(
                  c != null ? `Subscription "${c}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                  {
                    nodes: f
                  }
                )
              );
            }
            for (const y of p.values())
              y[0].name.value.startsWith("__") && t.reportError(
                new e.GraphQLError(
                  c != null ? `Subscription "${c}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: y
                  }
                )
              );
          }
        }
      }
    };
  }
  return Kt;
}
var Jt = {}, zt = {}, as;
function Ni() {
  if (as) return zt;
  as = 1, Object.defineProperty(zt, "__esModule", {
    value: !0
  }), zt.groupBy = e;
  function e(n, a) {
    const i = /* @__PURE__ */ new Map();
    for (const t of n) {
      const r = a(t), s = i.get(r);
      s === void 0 ? i.set(r, [t]) : s.push(t);
    }
    return i;
  }
  return zt;
}
var ss;
function Yo() {
  if (ss) return Jt;
  ss = 1, Object.defineProperty(Jt, "__esModule", {
    value: !0
  }), Jt.UniqueArgumentDefinitionNamesRule = a;
  var e = /* @__PURE__ */ Ni(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      DirectiveDefinition(s) {
        var u;
        const c = (u = s.arguments) !== null && u !== void 0 ? u : [];
        return r(`@${s.name.value}`, c);
      },
      InterfaceTypeDefinition: t,
      InterfaceTypeExtension: t,
      ObjectTypeDefinition: t,
      ObjectTypeExtension: t
    };
    function t(s) {
      var u;
      const c = s.name.value, d = (u = s.fields) !== null && u !== void 0 ? u : [];
      for (const o of d) {
        var m;
        const p = o.name.value, y = (m = o.arguments) !== null && m !== void 0 ? m : [];
        r(`${c}.${p}`, y);
      }
      return !1;
    }
    function r(s, u) {
      const c = (0, e.groupBy)(
        u,
        (d) => d.name.value
      );
      for (const [d, m] of c)
        m.length > 1 && i.reportError(
          new n.GraphQLError(
            `Argument "${s}(${d}:)" can only be defined once.`,
            {
              nodes: m.map((o) => o.name)
            }
          )
        );
      return !1;
    }
  }
  return Jt;
}
var Xt = {}, os;
function Jo() {
  if (os) return Xt;
  os = 1, Object.defineProperty(Xt, "__esModule", {
    value: !0
  }), Xt.UniqueArgumentNamesRule = a;
  var e = /* @__PURE__ */ Ni(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      Field: t,
      Directive: t
    };
    function t(r) {
      var s;
      const u = (s = r.arguments) !== null && s !== void 0 ? s : [], c = (0, e.groupBy)(
        u,
        (d) => d.name.value
      );
      for (const [d, m] of c)
        m.length > 1 && i.reportError(
          new n.GraphQLError(
            `There can be only one argument named "${d}".`,
            {
              nodes: m.map((o) => o.name)
            }
          )
        );
    }
  }
  return Xt;
}
var Ht = {}, us;
function zo() {
  if (us) return Ht;
  us = 1, Object.defineProperty(Ht, "__esModule", {
    value: !0
  }), Ht.UniqueDirectiveNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = a.getSchema();
    return {
      DirectiveDefinition(r) {
        const s = r.name.value;
        if (t != null && t.getDirective(s)) {
          a.reportError(
            new e.GraphQLError(
              `Directive "@${s}" already exists in the schema. It cannot be redefined.`,
              {
                nodes: r.name
              }
            )
          );
          return;
        }
        return i[s] ? a.reportError(
          new e.GraphQLError(
            `There can be only one directive named "@${s}".`,
            {
              nodes: [i[s], r.name]
            }
          )
        ) : i[s] = r.name, !1;
      }
    };
  }
  return Ht;
}
var Wt = {}, cs;
function Xo() {
  if (cs) return Wt;
  cs = 1, Object.defineProperty(Wt, "__esModule", {
    value: !0
  }), Wt.UniqueDirectivesPerLocationRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Dn(), i = /* @__PURE__ */ Ve();
  function t(r) {
    const s = /* @__PURE__ */ Object.create(null), u = r.getSchema(), c = u ? u.getDirectives() : i.specifiedDirectives;
    for (const p of c)
      s[p.name] = !p.isRepeatable;
    const d = r.getDocument().definitions;
    for (const p of d)
      p.kind === n.Kind.DIRECTIVE_DEFINITION && (s[p.name.value] = !p.repeatable);
    const m = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
    return {
      // Many different AST nodes may contain directives. Rather than listing
      // them all, just listen for entering any node, and check to see if it
      // defines any directives.
      enter(p) {
        if (!("directives" in p) || !p.directives)
          return;
        let y;
        if (p.kind === n.Kind.SCHEMA_DEFINITION || p.kind === n.Kind.SCHEMA_EXTENSION)
          y = m;
        else if ((0, a.isTypeDefinitionNode)(p) || (0, a.isTypeExtensionNode)(p)) {
          const l = p.name.value;
          y = o[l], y === void 0 && (o[l] = y = /* @__PURE__ */ Object.create(null));
        } else
          y = /* @__PURE__ */ Object.create(null);
        for (const l of p.directives) {
          const f = l.name.value;
          s[f] && (y[f] ? r.reportError(
            new e.GraphQLError(
              `The directive "@${f}" can only be used once at this location.`,
              {
                nodes: [y[f], l]
              }
            )
          ) : y[f] = l);
        }
      }
    };
  }
  return Wt;
}
var Zt = {}, ls;
function Ho() {
  if (ls) return Zt;
  ls = 1, Object.defineProperty(Zt, "__esModule", {
    value: !0
  }), Zt.UniqueEnumValueNamesRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ ue();
  function a(i) {
    const t = i.getSchema(), r = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
    return {
      EnumTypeDefinition: u,
      EnumTypeExtension: u
    };
    function u(c) {
      var d;
      const m = c.name.value;
      s[m] || (s[m] = /* @__PURE__ */ Object.create(null));
      const o = (d = c.values) !== null && d !== void 0 ? d : [], p = s[m];
      for (const y of o) {
        const l = y.name.value, f = r[m];
        (0, n.isEnumType)(f) && f.getValue(l) ? i.reportError(
          new e.GraphQLError(
            `Enum value "${m}.${l}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: y.name
            }
          )
        ) : p[l] ? i.reportError(
          new e.GraphQLError(
            `Enum value "${m}.${l}" can only be defined once.`,
            {
              nodes: [p[l], y.name]
            }
          )
        ) : p[l] = y.name;
      }
      return !1;
    }
  }
  return Zt;
}
var er = {}, ps;
function Wo() {
  if (ps) return er;
  ps = 1, Object.defineProperty(er, "__esModule", {
    value: !0
  }), er.UniqueFieldDefinitionNamesRule = a;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ ue();
  function a(t) {
    const r = t.getSchema(), s = r ? r.getTypeMap() : /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null);
    return {
      InputObjectTypeDefinition: c,
      InputObjectTypeExtension: c,
      InterfaceTypeDefinition: c,
      InterfaceTypeExtension: c,
      ObjectTypeDefinition: c,
      ObjectTypeExtension: c
    };
    function c(d) {
      var m;
      const o = d.name.value;
      u[o] || (u[o] = /* @__PURE__ */ Object.create(null));
      const p = (m = d.fields) !== null && m !== void 0 ? m : [], y = u[o];
      for (const l of p) {
        const f = l.name.value;
        i(s[o], f) ? t.reportError(
          new e.GraphQLError(
            `Field "${o}.${f}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: l.name
            }
          )
        ) : y[f] ? t.reportError(
          new e.GraphQLError(
            `Field "${o}.${f}" can only be defined once.`,
            {
              nodes: [y[f], l.name]
            }
          )
        ) : y[f] = l.name;
      }
      return !1;
    }
  }
  function i(t, r) {
    return (0, n.isObjectType)(t) || (0, n.isInterfaceType)(t) || (0, n.isInputObjectType)(t) ? t.getFields()[r] != null : !1;
  }
  return er;
}
var nr = {}, ds;
function Zo() {
  if (ds) return nr;
  ds = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.UniqueFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(t) {
        const r = t.name.value;
        return i[r] ? a.reportError(
          new e.GraphQLError(
            `There can be only one fragment named "${r}".`,
            {
              nodes: [i[r], t.name]
            }
          )
        ) : i[r] = t.name, !1;
      }
    };
  }
  return nr;
}
var tr = {}, fs;
function eu() {
  if (fs) return tr;
  fs = 1, Object.defineProperty(tr, "__esModule", {
    value: !0
  }), tr.UniqueInputFieldNamesRule = a;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ne();
  function a(i) {
    const t = [];
    let r = /* @__PURE__ */ Object.create(null);
    return {
      ObjectValue: {
        enter() {
          t.push(r), r = /* @__PURE__ */ Object.create(null);
        },
        leave() {
          const s = t.pop();
          s || (0, e.invariant)(!1), r = s;
        }
      },
      ObjectField(s) {
        const u = s.name.value;
        r[u] ? i.reportError(
          new n.GraphQLError(
            `There can be only one input field named "${u}".`,
            {
              nodes: [r[u], s.name]
            }
          )
        ) : r[u] = s.name;
      }
    };
  }
  return tr;
}
var rr = {}, ms;
function nu() {
  if (ms) return rr;
  ms = 1, Object.defineProperty(rr, "__esModule", {
    value: !0
  }), rr.UniqueOperationNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition(t) {
        const r = t.name;
        return r && (i[r.value] ? a.reportError(
          new e.GraphQLError(
            `There can be only one operation named "${r.value}".`,
            {
              nodes: [
                i[r.value],
                r
              ]
            }
          )
        ) : i[r.value] = r), !1;
      },
      FragmentDefinition: () => !1
    };
  }
  return rr;
}
var ir = {}, hs;
function tu() {
  if (hs) return ir;
  hs = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.UniqueOperationTypesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = a.getSchema(), t = /* @__PURE__ */ Object.create(null), r = i ? {
      query: i.getQueryType(),
      mutation: i.getMutationType(),
      subscription: i.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: s,
      SchemaExtension: s
    };
    function s(u) {
      var c;
      const d = (c = u.operationTypes) !== null && c !== void 0 ? c : [];
      for (const m of d) {
        const o = m.operation, p = t[o];
        r[o] ? a.reportError(
          new e.GraphQLError(
            `Type for ${o} already defined in the schema. It cannot be redefined.`,
            {
              nodes: m
            }
          )
        ) : p ? a.reportError(
          new e.GraphQLError(
            `There can be only one ${o} type in schema.`,
            {
              nodes: [p, m]
            }
          )
        ) : t[o] = m;
      }
      return !1;
    }
  }
  return ir;
}
var ar = {}, ys;
function ru() {
  if (ys) return ar;
  ys = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.UniqueTypeNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(a) {
    const i = /* @__PURE__ */ Object.create(null), t = a.getSchema();
    return {
      ScalarTypeDefinition: r,
      ObjectTypeDefinition: r,
      InterfaceTypeDefinition: r,
      UnionTypeDefinition: r,
      EnumTypeDefinition: r,
      InputObjectTypeDefinition: r
    };
    function r(s) {
      const u = s.name.value;
      if (t != null && t.getType(u)) {
        a.reportError(
          new e.GraphQLError(
            `Type "${u}" already exists in the schema. It cannot also be defined in this type definition.`,
            {
              nodes: s.name
            }
          )
        );
        return;
      }
      return i[u] ? a.reportError(
        new e.GraphQLError(
          `There can be only one type named "${u}".`,
          {
            nodes: [i[u], s.name]
          }
        )
      ) : i[u] = s.name, !1;
    }
  }
  return ar;
}
var sr = {}, vs;
function iu() {
  if (vs) return sr;
  vs = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.UniqueVariableNamesRule = a;
  var e = /* @__PURE__ */ Ni(), n = /* @__PURE__ */ ne();
  function a(i) {
    return {
      OperationDefinition(t) {
        var r;
        const s = (r = t.variableDefinitions) !== null && r !== void 0 ? r : [], u = (0, e.groupBy)(
          s,
          (c) => c.variable.name.value
        );
        for (const [c, d] of u)
          d.length > 1 && i.reportError(
            new n.GraphQLError(
              `There can be only one variable named "$${c}".`,
              {
                nodes: d.map((m) => m.variable.name)
              }
            )
          );
      }
    };
  }
  return sr;
}
var or = {}, Ts;
function au() {
  if (Ts) return or;
  Ts = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.ValuesOfCorrectTypeRule = c;
  var e = /* @__PURE__ */ cn(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ ln(), i = /* @__PURE__ */ pn(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Ge(), u = /* @__PURE__ */ ue();
  function c(o) {
    let p = {};
    return {
      OperationDefinition: {
        enter() {
          p = {};
        }
      },
      VariableDefinition(y) {
        p[y.variable.name.value] = y;
      },
      ListValue(y) {
        const l = (0, u.getNullableType)(
          o.getParentInputType()
        );
        if (!(0, u.isListType)(l))
          return d(o, y), !1;
      },
      ObjectValue(y) {
        const l = (0, u.getNamedType)(o.getInputType());
        if (!(0, u.isInputObjectType)(l))
          return d(o, y), !1;
        const f = (0, a.keyMap)(
          y.fields,
          (h) => h.name.value
        );
        for (const h of Object.values(l.getFields()))
          if (!f[h.name] && (0, u.isRequiredInputField)(h)) {
            const O = (0, n.inspect)(h.type);
            o.reportError(
              new t.GraphQLError(
                `Field "${l.name}.${h.name}" of required type "${O}" was not provided.`,
                {
                  nodes: y
                }
              )
            );
          }
        l.isOneOf && m(
          o,
          y,
          l,
          f,
          p
        );
      },
      ObjectField(y) {
        const l = (0, u.getNamedType)(
          o.getParentInputType()
        );
        if (!o.getInputType() && (0, u.isInputObjectType)(l)) {
          const h = (0, i.suggestionList)(
            y.name.value,
            Object.keys(l.getFields())
          );
          o.reportError(
            new t.GraphQLError(
              `Field "${y.name.value}" is not defined by type "${l.name}".` + (0, e.didYouMean)(h),
              {
                nodes: y
              }
            )
          );
        }
      },
      NullValue(y) {
        const l = o.getInputType();
        (0, u.isNonNullType)(l) && o.reportError(
          new t.GraphQLError(
            `Expected value of type "${(0, n.inspect)(
              l
            )}", found ${(0, s.print)(y)}.`,
            {
              nodes: y
            }
          )
        );
      },
      EnumValue: (y) => d(o, y),
      IntValue: (y) => d(o, y),
      FloatValue: (y) => d(o, y),
      StringValue: (y) => d(o, y),
      BooleanValue: (y) => d(o, y)
    };
  }
  function d(o, p) {
    const y = o.getInputType();
    if (!y)
      return;
    const l = (0, u.getNamedType)(y);
    if (!(0, u.isLeafType)(l)) {
      const f = (0, n.inspect)(y);
      o.reportError(
        new t.GraphQLError(
          `Expected value of type "${f}", found ${(0, s.print)(
            p
          )}.`,
          {
            nodes: p
          }
        )
      );
      return;
    }
    try {
      if (l.parseLiteral(
        p,
        void 0
        /* variables */
      ) === void 0) {
        const h = (0, n.inspect)(y);
        o.reportError(
          new t.GraphQLError(
            `Expected value of type "${h}", found ${(0, s.print)(
              p
            )}.`,
            {
              nodes: p
            }
          )
        );
      }
    } catch (f) {
      const h = (0, n.inspect)(y);
      f instanceof t.GraphQLError ? o.reportError(f) : o.reportError(
        new t.GraphQLError(
          `Expected value of type "${h}", found ${(0, s.print)(
            p
          )}; ` + f.message,
          {
            nodes: p,
            originalError: f
          }
        )
      );
    }
  }
  function m(o, p, y, l, f) {
    var h;
    const T = Object.keys(l);
    if (T.length !== 1) {
      o.reportError(
        new t.GraphQLError(
          `OneOf Input Object "${y.name}" must specify exactly one key.`,
          {
            nodes: [p]
          }
        )
      );
      return;
    }
    const R = (h = l[T[0]]) === null || h === void 0 ? void 0 : h.value, D = !R || R.kind === r.Kind.NULL, _ = (R == null ? void 0 : R.kind) === r.Kind.VARIABLE;
    if (D) {
      o.reportError(
        new t.GraphQLError(
          `Field "${y.name}.${T[0]}" must be non-null.`,
          {
            nodes: [p]
          }
        )
      );
      return;
    }
    if (_) {
      const w = R.name.value;
      f[w].type.kind !== r.Kind.NON_NULL_TYPE && o.reportError(
        new t.GraphQLError(
          `Variable "${w}" must be non-nullable to be used for OneOf Input Object "${y.name}".`,
          {
            nodes: [p]
          }
        )
      );
    }
  }
  return or;
}
var ur = {}, bs;
function su() {
  if (bs) return ur;
  bs = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.VariablesAreInputTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ Ge(), a = /* @__PURE__ */ ue(), i = /* @__PURE__ */ nn();
  function t(r) {
    return {
      VariableDefinition(s) {
        const u = (0, i.typeFromAST)(
          r.getSchema(),
          s.type
        );
        if (u !== void 0 && !(0, a.isInputType)(u)) {
          const c = s.variable.name.value, d = (0, n.print)(s.type);
          r.reportError(
            new e.GraphQLError(
              `Variable "$${c}" cannot be non-input type "${d}".`,
              {
                nodes: s.type
              }
            )
          );
        }
      }
    };
  }
  return ur;
}
var cr = {}, gs;
function ou() {
  if (gs) return cr;
  gs = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.VariablesInAllowedPositionRule = s;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ oe(), i = /* @__PURE__ */ ue(), t = /* @__PURE__ */ Gr(), r = /* @__PURE__ */ nn();
  function s(c) {
    let d = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          d = /* @__PURE__ */ Object.create(null);
        },
        leave(m) {
          const o = c.getRecursiveVariableUsages(m);
          for (const { node: p, type: y, defaultValue: l } of o) {
            const f = p.name.value, h = d[f];
            if (h && y) {
              const T = c.getSchema(), O = (0, r.typeFromAST)(T, h.type);
              if (O && !u(
                T,
                O,
                h.defaultValue,
                y,
                l
              )) {
                const R = (0, e.inspect)(O), D = (0, e.inspect)(y);
                c.reportError(
                  new n.GraphQLError(
                    `Variable "$${f}" of type "${R}" used in position expecting type "${D}".`,
                    {
                      nodes: [h, p]
                    }
                  )
                );
              }
            }
          }
        }
      },
      VariableDefinition(m) {
        d[m.variable.name.value] = m;
      }
    };
  }
  function u(c, d, m, o, p) {
    if ((0, i.isNonNullType)(o) && !(0, i.isNonNullType)(d)) {
      if (!(m != null && m.kind !== a.Kind.NULL) && !(p !== void 0))
        return !1;
      const f = o.ofType;
      return (0, t.isTypeSubTypeOf)(
        c,
        d,
        f
      );
    }
    return (0, t.isTypeSubTypeOf)(c, d, o);
  }
  return cr;
}
var Es;
function uu() {
  if (Es) return ze;
  Es = 1, Object.defineProperty(ze, "__esModule", {
    value: !0
  }), ze.specifiedSDLRules = ze.specifiedRules = ze.recommendedRules = void 0;
  var e = /* @__PURE__ */ _o(), n = /* @__PURE__ */ Io(), a = /* @__PURE__ */ So(), i = /* @__PURE__ */ Lo(), t = /* @__PURE__ */ Ro(), r = /* @__PURE__ */ Do(), s = /* @__PURE__ */ Ao(), u = /* @__PURE__ */ jo(), c = /* @__PURE__ */ Po(), d = /* @__PURE__ */ Fo(), m = /* @__PURE__ */ wo(), o = /* @__PURE__ */ ko(), p = /* @__PURE__ */ Vo(), y = /* @__PURE__ */ Co(), l = /* @__PURE__ */ Mo(), f = /* @__PURE__ */ $o(), h = /* @__PURE__ */ Uo(), T = /* @__PURE__ */ Qo(), O = /* @__PURE__ */ qo(), R = /* @__PURE__ */ Bo(), D = /* @__PURE__ */ Yo(), _ = /* @__PURE__ */ Jo(), w = /* @__PURE__ */ zo(), M = /* @__PURE__ */ Xo(), V = /* @__PURE__ */ Ho(), N = /* @__PURE__ */ Wo(), g = /* @__PURE__ */ Zo(), L = /* @__PURE__ */ eu(), E = /* @__PURE__ */ nu(), v = /* @__PURE__ */ tu(), b = /* @__PURE__ */ ru(), I = /* @__PURE__ */ iu(), S = /* @__PURE__ */ au(), j = /* @__PURE__ */ su(), k = /* @__PURE__ */ ou();
  const U = Object.freeze([
    d.MaxIntrospectionDepthRule
  ]);
  ze.recommendedRules = U;
  const W = Object.freeze([
    e.ExecutableDefinitionsRule,
    E.UniqueOperationNamesRule,
    u.LoneAnonymousOperationRule,
    R.SingleFieldSubscriptionsRule,
    s.KnownTypeNamesRule,
    a.FragmentsOnCompositeTypesRule,
    j.VariablesAreInputTypesRule,
    O.ScalarLeafsRule,
    n.FieldsOnCorrectTypeRule,
    g.UniqueFragmentNamesRule,
    r.KnownFragmentNamesRule,
    p.NoUnusedFragmentsRule,
    f.PossibleFragmentSpreadsRule,
    m.NoFragmentCyclesRule,
    I.UniqueVariableNamesRule,
    o.NoUndefinedVariablesRule,
    y.NoUnusedVariablesRule,
    t.KnownDirectivesRule,
    M.UniqueDirectivesPerLocationRule,
    i.KnownArgumentNamesRule,
    _.UniqueArgumentNamesRule,
    S.ValuesOfCorrectTypeRule,
    T.ProvidedRequiredArgumentsRule,
    k.VariablesInAllowedPositionRule,
    l.OverlappingFieldsCanBeMergedRule,
    L.UniqueInputFieldNamesRule,
    ...U
  ]);
  ze.specifiedRules = W;
  const P = Object.freeze([
    c.LoneSchemaDefinitionRule,
    v.UniqueOperationTypesRule,
    b.UniqueTypeNamesRule,
    V.UniqueEnumValueNamesRule,
    N.UniqueFieldDefinitionNamesRule,
    D.UniqueArgumentDefinitionNamesRule,
    w.UniqueDirectiveNamesRule,
    s.KnownTypeNamesRule,
    t.KnownDirectivesRule,
    M.UniqueDirectivesPerLocationRule,
    h.PossibleTypeExtensionsRule,
    i.KnownArgumentNamesOnDirectivesRule,
    _.UniqueArgumentNamesRule,
    L.UniqueInputFieldNamesRule,
    T.ProvidedRequiredArgumentsOnDirectivesRule
  ]);
  return ze.specifiedSDLRules = P, ze;
}
var Xe = {}, Ns;
function cu() {
  if (Ns) return Xe;
  Ns = 1, Object.defineProperty(Xe, "__esModule", {
    value: !0
  }), Xe.ValidationContext = Xe.SDLValidationContext = Xe.ASTValidationContext = void 0;
  var e = /* @__PURE__ */ oe(), n = /* @__PURE__ */ Ln(), a = /* @__PURE__ */ gi();
  class i {
    constructor(u, c) {
      this._ast = u, this._fragments = void 0, this._fragmentSpreads = /* @__PURE__ */ new Map(), this._recursivelyReferencedFragments = /* @__PURE__ */ new Map(), this._onError = c;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(u) {
      this._onError(u);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(u) {
      let c;
      if (this._fragments)
        c = this._fragments;
      else {
        c = /* @__PURE__ */ Object.create(null);
        for (const d of this.getDocument().definitions)
          d.kind === e.Kind.FRAGMENT_DEFINITION && (c[d.name.value] = d);
        this._fragments = c;
      }
      return c[u];
    }
    getFragmentSpreads(u) {
      let c = this._fragmentSpreads.get(u);
      if (!c) {
        c = [];
        const d = [u];
        let m;
        for (; m = d.pop(); )
          for (const o of m.selections)
            o.kind === e.Kind.FRAGMENT_SPREAD ? c.push(o) : o.selectionSet && d.push(o.selectionSet);
        this._fragmentSpreads.set(u, c);
      }
      return c;
    }
    getRecursivelyReferencedFragments(u) {
      let c = this._recursivelyReferencedFragments.get(u);
      if (!c) {
        c = [];
        const d = /* @__PURE__ */ Object.create(null), m = [u.selectionSet];
        let o;
        for (; o = m.pop(); )
          for (const p of this.getFragmentSpreads(o)) {
            const y = p.name.value;
            if (d[y] !== !0) {
              d[y] = !0;
              const l = this.getFragment(y);
              l && (c.push(l), m.push(l.selectionSet));
            }
          }
        this._recursivelyReferencedFragments.set(u, c);
      }
      return c;
    }
  }
  Xe.ASTValidationContext = i;
  class t extends i {
    constructor(u, c, d) {
      super(u, d), this._schema = c;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  }
  Xe.SDLValidationContext = t;
  let r = class extends i {
    constructor(u, c, d, m) {
      super(c, m), this._schema = u, this._typeInfo = d, this._variableUsages = /* @__PURE__ */ new Map(), this._recursiveVariableUsages = /* @__PURE__ */ new Map();
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(u) {
      let c = this._variableUsages.get(u);
      if (!c) {
        const d = [], m = new a.TypeInfo(this._schema);
        (0, n.visit)(
          u,
          (0, a.visitWithTypeInfo)(m, {
            VariableDefinition: () => !1,
            Variable(o) {
              d.push({
                node: o,
                type: m.getInputType(),
                defaultValue: m.getDefaultValue()
              });
            }
          })
        ), c = d, this._variableUsages.set(u, c);
      }
      return c;
    }
    getRecursiveVariableUsages(u) {
      let c = this._recursiveVariableUsages.get(u);
      if (!c) {
        c = this.getVariableUsages(u);
        for (const d of this.getRecursivelyReferencedFragments(u))
          c = c.concat(this.getVariableUsages(d));
        this._recursiveVariableUsages.set(u, c);
      }
      return c;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  };
  return Xe.ValidationContext = r, Xe;
}
var Os;
function qr() {
  if (Os) return on;
  Os = 1, Object.defineProperty(on, "__esModule", {
    value: !0
  }), on.assertValidSDL = d, on.assertValidSDLExtension = m, on.validate = u, on.validateSDL = c;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Ln(), i = /* @__PURE__ */ $r(), t = /* @__PURE__ */ gi(), r = /* @__PURE__ */ uu(), s = /* @__PURE__ */ cu();
  function u(o, p, y = r.specifiedRules, l, f = new t.TypeInfo(o)) {
    var h;
    const T = (h = l == null ? void 0 : l.maxErrors) !== null && h !== void 0 ? h : 100;
    p || (0, e.devAssert)(!1, "Must provide document."), (0, i.assertValidSchema)(o);
    const O = Object.freeze({}), R = [], D = new s.ValidationContext(
      o,
      p,
      f,
      (w) => {
        if (R.length >= T)
          throw R.push(
            new n.GraphQLError(
              "Too many validation errors, error limit reached. Validation aborted."
            )
          ), O;
        R.push(w);
      }
    ), _ = (0, a.visitInParallel)(
      y.map((w) => w(D))
    );
    try {
      (0, a.visit)(
        p,
        (0, t.visitWithTypeInfo)(f, _)
      );
    } catch (w) {
      if (w !== O)
        throw w;
    }
    return R;
  }
  function c(o, p, y = r.specifiedSDLRules) {
    const l = [], f = new s.SDLValidationContext(
      o,
      p,
      (T) => {
        l.push(T);
      }
    ), h = y.map((T) => T(f));
    return (0, a.visit)(o, (0, a.visitInParallel)(h)), l;
  }
  function d(o) {
    const p = c(o);
    if (p.length !== 0)
      throw new Error(p.map((y) => y.message).join(`

`));
  }
  function m(o, p) {
    const y = c(o, p);
    if (y.length !== 0)
      throw new Error(y.map((l) => l.message).join(`

`));
  }
  return on;
}
var we = {}, lr = {}, _s;
function Ec() {
  if (_s) return lr;
  _s = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.memoize3 = e;
  function e(n) {
    let a;
    return function(t, r, s) {
      a === void 0 && (a = /* @__PURE__ */ new WeakMap());
      let u = a.get(t);
      u === void 0 && (u = /* @__PURE__ */ new WeakMap(), a.set(t, u));
      let c = u.get(r);
      c === void 0 && (c = /* @__PURE__ */ new WeakMap(), u.set(r, c));
      let d = c.get(s);
      return d === void 0 && (d = n(t, r, s), c.set(s, d)), d;
    };
  }
  return lr;
}
var pr = {}, Is;
function Nc() {
  if (Is) return pr;
  Is = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.promiseForObject = e;
  function e(n) {
    return Promise.all(Object.values(n)).then((a) => {
      const i = /* @__PURE__ */ Object.create(null);
      for (const [t, r] of Object.keys(n).entries())
        i[r] = a[t];
      return i;
    });
  }
  return pr;
}
var dr = {}, Ss;
function Oc() {
  if (Ss) return dr;
  Ss = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.promiseReduce = n;
  var e = /* @__PURE__ */ mi();
  function n(a, i, t) {
    let r = t;
    for (const s of a)
      r = (0, e.isPromise)(r) ? r.then((u) => i(u, s)) : i(r, s);
    return r;
  }
  return dr;
}
var Ls;
function Kr() {
  if (Ls) return we;
  Ls = 1, Object.defineProperty(we, "__esModule", {
    value: !0
  }), we.assertValidExecutionArguments = M, we.buildExecutionContext = V, we.buildResolveInfo = v, we.defaultTypeResolver = we.defaultFieldResolver = void 0, we.execute = D, we.executeSync = _, we.getFieldDef = pe;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Re(), i = /* @__PURE__ */ bi(), t = /* @__PURE__ */ We(), r = /* @__PURE__ */ mi(), s = /* @__PURE__ */ Ec(), u = /* @__PURE__ */ Ur(), c = /* @__PURE__ */ Nc(), d = /* @__PURE__ */ Oc(), m = /* @__PURE__ */ ne(), o = /* @__PURE__ */ fi(), p = /* @__PURE__ */ Ze(), y = /* @__PURE__ */ oe(), l = /* @__PURE__ */ ue(), f = /* @__PURE__ */ Qe(), h = /* @__PURE__ */ $r(), T = /* @__PURE__ */ Ei(), O = /* @__PURE__ */ Zn();
  const R = (0, s.memoize3)(
    (G, $, x) => (0, T.collectSubfields)(
      G.schema,
      G.fragments,
      G.variableValues,
      $,
      x
    )
  );
  function D(G) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const { schema: $, document: x, variableValues: B, rootValue: ee } = G;
    M($, x, B);
    const Y = V(G);
    if (!("schema" in Y))
      return {
        errors: Y
      };
    try {
      const { operation: Z } = Y, re = N(Y, Z, ee);
      return (0, r.isPromise)(re) ? re.then(
        (ce) => w(ce, Y.errors),
        (ce) => (Y.errors.push(ce), w(null, Y.errors))
      ) : w(re, Y.errors);
    } catch (Z) {
      return Y.errors.push(Z), w(null, Y.errors);
    }
  }
  function _(G) {
    const $ = D(G);
    if ((0, r.isPromise)($))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return $;
  }
  function w(G, $) {
    return $.length === 0 ? {
      data: G
    } : {
      errors: $,
      data: G
    };
  }
  function M(G, $, x) {
    $ || (0, e.devAssert)(!1, "Must provide document."), (0, h.assertValidSchema)(G), x == null || (0, t.isObjectLike)(x) || (0, e.devAssert)(
      !1,
      "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
    );
  }
  function V(G) {
    var $, x;
    const {
      schema: B,
      document: ee,
      rootValue: Y,
      contextValue: Z,
      variableValues: re,
      operationName: ce,
      fieldResolver: de,
      typeResolver: be,
      subscribeFieldResolver: Ie
    } = G;
    let ve;
    const Ee = /* @__PURE__ */ Object.create(null);
    for (const Ce of ee.definitions)
      switch (Ce.kind) {
        case y.Kind.OPERATION_DEFINITION:
          if (ce == null) {
            if (ve !== void 0)
              return [
                new m.GraphQLError(
                  "Must provide operation name if query contains multiple operations."
                )
              ];
            ve = Ce;
          } else (($ = Ce.name) === null || $ === void 0 ? void 0 : $.value) === ce && (ve = Ce);
          break;
        case y.Kind.FRAGMENT_DEFINITION:
          Ee[Ce.name.value] = Ce;
          break;
      }
    if (!ve)
      return ce != null ? [
        new m.GraphQLError(
          `Unknown operation named "${ce}".`
        )
      ] : [new m.GraphQLError("Must provide an operation.")];
    const De = (x = ve.variableDefinitions) !== null && x !== void 0 ? x : [], je = (0, O.getVariableValues)(
      B,
      De,
      re ?? {},
      {
        maxErrors: 50
      }
    );
    return je.errors ? je.errors : {
      schema: B,
      fragments: Ee,
      rootValue: Y,
      contextValue: Z,
      operation: ve,
      variableValues: je.coerced,
      fieldResolver: de ?? te,
      typeResolver: be ?? K,
      subscribeFieldResolver: Ie ?? te,
      errors: []
    };
  }
  function N(G, $, x) {
    const B = G.schema.getRootType($.operation);
    if (B == null)
      throw new m.GraphQLError(
        `Schema is not configured to execute ${$.operation} operation.`,
        {
          nodes: $
        }
      );
    const ee = (0, T.collectFields)(
      G.schema,
      G.fragments,
      G.variableValues,
      B,
      $.selectionSet
    ), Y = void 0;
    switch ($.operation) {
      case p.OperationTypeNode.QUERY:
        return L(G, B, x, Y, ee);
      case p.OperationTypeNode.MUTATION:
        return g(
          G,
          B,
          x,
          Y,
          ee
        );
      case p.OperationTypeNode.SUBSCRIPTION:
        return L(G, B, x, Y, ee);
    }
  }
  function g(G, $, x, B, ee) {
    return (0, d.promiseReduce)(
      ee.entries(),
      (Y, [Z, re]) => {
        const ce = (0, u.addPath)(B, Z, $.name), de = E(
          G,
          $,
          x,
          re,
          ce
        );
        return de === void 0 ? Y : (0, r.isPromise)(de) ? de.then((be) => (Y[Z] = be, Y)) : (Y[Z] = de, Y);
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
  function L(G, $, x, B, ee) {
    const Y = /* @__PURE__ */ Object.create(null);
    let Z = !1;
    try {
      for (const [re, ce] of ee.entries()) {
        const de = (0, u.addPath)(B, re, $.name), be = E(
          G,
          $,
          x,
          ce,
          de
        );
        be !== void 0 && (Y[re] = be, (0, r.isPromise)(be) && (Z = !0));
      }
    } catch (re) {
      if (Z)
        return (0, c.promiseForObject)(Y).finally(() => {
          throw re;
        });
      throw re;
    }
    return Z ? (0, c.promiseForObject)(Y) : Y;
  }
  function E(G, $, x, B, ee) {
    var Y;
    const Z = pe(G.schema, $, B[0]);
    if (!Z)
      return;
    const re = Z.type, ce = (Y = Z.resolve) !== null && Y !== void 0 ? Y : G.fieldResolver, de = v(
      G,
      Z,
      B,
      $,
      ee
    );
    try {
      const be = (0, O.getArgumentValues)(
        Z,
        B[0],
        G.variableValues
      ), Ie = G.contextValue, ve = ce(x, be, Ie, de);
      let Ee;
      return (0, r.isPromise)(ve) ? Ee = ve.then(
        (De) => I(G, re, B, de, ee, De)
      ) : Ee = I(
        G,
        re,
        B,
        de,
        ee,
        ve
      ), (0, r.isPromise)(Ee) ? Ee.then(void 0, (De) => {
        const je = (0, o.locatedError)(
          De,
          B,
          (0, u.pathToArray)(ee)
        );
        return b(je, re, G);
      }) : Ee;
    } catch (be) {
      const Ie = (0, o.locatedError)(
        be,
        B,
        (0, u.pathToArray)(ee)
      );
      return b(Ie, re, G);
    }
  }
  function v(G, $, x, B, ee) {
    return {
      fieldName: $.name,
      fieldNodes: x,
      returnType: $.type,
      parentType: B,
      path: ee,
      schema: G.schema,
      fragments: G.fragments,
      rootValue: G.rootValue,
      operation: G.operation,
      variableValues: G.variableValues
    };
  }
  function b(G, $, x) {
    if ((0, l.isNonNullType)($))
      throw G;
    return x.errors.push(G), null;
  }
  function I(G, $, x, B, ee, Y) {
    if (Y instanceof Error)
      throw Y;
    if ((0, l.isNonNullType)($)) {
      const Z = I(
        G,
        $.ofType,
        x,
        B,
        ee,
        Y
      );
      if (Z === null)
        throw new Error(
          `Cannot return null for non-nullable field ${B.parentType.name}.${B.fieldName}.`
        );
      return Z;
    }
    if (Y == null)
      return null;
    if ((0, l.isListType)($))
      return S(
        G,
        $,
        x,
        B,
        ee,
        Y
      );
    if ((0, l.isLeafType)($))
      return j($, Y);
    if ((0, l.isAbstractType)($))
      return k(
        G,
        $,
        x,
        B,
        ee,
        Y
      );
    if ((0, l.isObjectType)($))
      return W(
        G,
        $,
        x,
        B,
        ee,
        Y
      );
    (0, a.invariant)(
      !1,
      "Cannot complete value of unexpected output type: " + (0, n.inspect)($)
    );
  }
  function S(G, $, x, B, ee, Y) {
    if (!(0, i.isIterableObject)(Y))
      throw new m.GraphQLError(
        `Expected Iterable, but did not find one for field "${B.parentType.name}.${B.fieldName}".`
      );
    const Z = $.ofType;
    let re = !1;
    const ce = Array.from(Y, (de, be) => {
      const Ie = (0, u.addPath)(ee, be, void 0);
      try {
        let ve;
        return (0, r.isPromise)(de) ? ve = de.then(
          (Ee) => I(
            G,
            Z,
            x,
            B,
            Ie,
            Ee
          )
        ) : ve = I(
          G,
          Z,
          x,
          B,
          Ie,
          de
        ), (0, r.isPromise)(ve) ? (re = !0, ve.then(void 0, (Ee) => {
          const De = (0, o.locatedError)(
            Ee,
            x,
            (0, u.pathToArray)(Ie)
          );
          return b(De, Z, G);
        })) : ve;
      } catch (ve) {
        const Ee = (0, o.locatedError)(
          ve,
          x,
          (0, u.pathToArray)(Ie)
        );
        return b(Ee, Z, G);
      }
    });
    return re ? Promise.all(ce) : ce;
  }
  function j(G, $) {
    const x = G.serialize($);
    if (x == null)
      throw new Error(
        `Expected \`${(0, n.inspect)(G)}.serialize(${(0, n.inspect)($)})\` to return non-nullable value, returned: ${(0, n.inspect)(
          x
        )}`
      );
    return x;
  }
  function k(G, $, x, B, ee, Y) {
    var Z;
    const re = (Z = $.resolveType) !== null && Z !== void 0 ? Z : G.typeResolver, ce = G.contextValue, de = re(Y, ce, B, $);
    return (0, r.isPromise)(de) ? de.then(
      (be) => W(
        G,
        U(
          be,
          G,
          $,
          x,
          B,
          Y
        ),
        x,
        B,
        ee,
        Y
      )
    ) : W(
      G,
      U(
        de,
        G,
        $,
        x,
        B,
        Y
      ),
      x,
      B,
      ee,
      Y
    );
  }
  function U(G, $, x, B, ee, Y) {
    if (G == null)
      throw new m.GraphQLError(
        `Abstract type "${x.name}" must resolve to an Object type at runtime for field "${ee.parentType.name}.${ee.fieldName}". Either the "${x.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
        B
      );
    if ((0, l.isObjectType)(G))
      throw new m.GraphQLError(
        "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
      );
    if (typeof G != "string")
      throw new m.GraphQLError(
        `Abstract type "${x.name}" must resolve to an Object type at runtime for field "${ee.parentType.name}.${ee.fieldName}" with value ${(0, n.inspect)(Y)}, received "${(0, n.inspect)(G)}".`
      );
    const Z = $.schema.getType(G);
    if (Z == null)
      throw new m.GraphQLError(
        `Abstract type "${x.name}" was resolved to a type "${G}" that does not exist inside the schema.`,
        {
          nodes: B
        }
      );
    if (!(0, l.isObjectType)(Z))
      throw new m.GraphQLError(
        `Abstract type "${x.name}" was resolved to a non-object type "${G}".`,
        {
          nodes: B
        }
      );
    if (!$.schema.isSubType(x, Z))
      throw new m.GraphQLError(
        `Runtime Object type "${Z.name}" is not a possible type for "${x.name}".`,
        {
          nodes: B
        }
      );
    return Z;
  }
  function W(G, $, x, B, ee, Y) {
    const Z = R(G, $, x);
    if ($.isTypeOf) {
      const re = $.isTypeOf(Y, G.contextValue, B);
      if ((0, r.isPromise)(re))
        return re.then((ce) => {
          if (!ce)
            throw P($, Y, x);
          return L(
            G,
            $,
            Y,
            ee,
            Z
          );
        });
      if (!re)
        throw P($, Y, x);
    }
    return L(G, $, Y, ee, Z);
  }
  function P(G, $, x) {
    return new m.GraphQLError(
      `Expected value of type "${G.name}" but got: ${(0, n.inspect)($)}.`,
      {
        nodes: x
      }
    );
  }
  const K = function(G, $, x, B) {
    if ((0, t.isObjectLike)(G) && typeof G.__typename == "string")
      return G.__typename;
    const ee = x.schema.getPossibleTypes(B), Y = [];
    for (let Z = 0; Z < ee.length; Z++) {
      const re = ee[Z];
      if (re.isTypeOf) {
        const ce = re.isTypeOf(G, $, x);
        if ((0, r.isPromise)(ce))
          Y[Z] = ce;
        else if (ce)
          return re.name;
      }
    }
    if (Y.length)
      return Promise.all(Y).then((Z) => {
        for (let re = 0; re < Z.length; re++)
          if (Z[re])
            return ee[re].name;
      });
  };
  we.defaultTypeResolver = K;
  const te = function(G, $, x, B) {
    if ((0, t.isObjectLike)(G) || typeof G == "function") {
      const ee = G[B.fieldName];
      return typeof ee == "function" ? G[B.fieldName]($, x, B) : ee;
    }
  };
  we.defaultFieldResolver = te;
  function pe(G, $, x) {
    const B = x.name.value;
    return B === f.SchemaMetaFieldDef.name && G.getQueryType() === $ ? f.SchemaMetaFieldDef : B === f.TypeMetaFieldDef.name && G.getQueryType() === $ ? f.TypeMetaFieldDef : B === f.TypeNameMetaFieldDef.name ? f.TypeNameMetaFieldDef : $.getFields()[B];
  }
  return we;
}
var Rs;
function _c() {
  if (Rs) return Pn;
  Rs = 1, Object.defineProperty(Pn, "__esModule", {
    value: !0
  }), Pn.graphql = s, Pn.graphqlSync = u;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ mi(), a = /* @__PURE__ */ Wn(), i = /* @__PURE__ */ $r(), t = /* @__PURE__ */ qr(), r = /* @__PURE__ */ Kr();
  function s(d) {
    return new Promise((m) => m(c(d)));
  }
  function u(d) {
    const m = c(d);
    if ((0, n.isPromise)(m))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return m;
  }
  function c(d) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const {
      schema: m,
      source: o,
      rootValue: p,
      contextValue: y,
      variableValues: l,
      operationName: f,
      fieldResolver: h,
      typeResolver: T
    } = d, O = (0, i.validateSchema)(m);
    if (O.length > 0)
      return {
        errors: O
      };
    let R;
    try {
      R = (0, a.parse)(o);
    } catch (_) {
      return {
        errors: [_]
      };
    }
    const D = (0, t.validate)(m, R);
    return D.length > 0 ? {
      errors: D
    } : (0, r.execute)({
      schema: m,
      document: R,
      rootValue: p,
      contextValue: y,
      variableValues: l,
      operationName: f,
      fieldResolver: h,
      typeResolver: T
    });
  }
  return Pn;
}
var Jr = {}, Ds;
function Ic() {
  return Ds || (Ds = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return t.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return t.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return t.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return t.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return a.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return a.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return n.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return t.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return a.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return r.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return r.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return r.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return r.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return r.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return r.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return r.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return r.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return r.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return a.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return a.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return a.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return u.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return a.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return a.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return a.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return u.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return a.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return a.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return a.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return a.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return a.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return a.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return n.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return a.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return a.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return s.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return a.assertWrappingType;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return a.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return a.getNullableType;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return r.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return a.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return a.isCompositeType;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return a.isEnumType;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return a.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return a.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return a.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return r.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return a.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return a.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return a.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return a.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return a.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return a.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return a.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return a.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return a.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return a.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return n.isSchema;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return t.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return a.isType;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return a.isUnionType;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return a.isWrappingType;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return a.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return a.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return t.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return s.validateSchema;
      }
    });
    var n = /* @__PURE__ */ Rn(), a = /* @__PURE__ */ ue(), i = /* @__PURE__ */ Ve(), t = /* @__PURE__ */ en(), r = /* @__PURE__ */ Qe(), s = /* @__PURE__ */ $r(), u = /* @__PURE__ */ Cr();
  }(Jr)), Jr;
}
var zr = {}, As;
function Sc() {
  return As || (As = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return d.BREAK;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return p.DirectiveLocation;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return s.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return m.Location;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return m.OperationTypeNode;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return n.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return m.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return r.TokenKind;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return d.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return a.getLocation;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return d.getVisitFn;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return o.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return o.isSelectionNode;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return o.isValueNode;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return u.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return u.parseConstValue;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return u.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return u.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return c.print;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return i.printLocation;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return i.printSourceLocation;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return d.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return d.visitInParallel;
      }
    });
    var n = /* @__PURE__ */ vi(), a = /* @__PURE__ */ pi(), i = /* @__PURE__ */ go(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Fr(), s = /* @__PURE__ */ yi(), u = /* @__PURE__ */ Wn(), c = /* @__PURE__ */ Ge(), d = /* @__PURE__ */ Ln(), m = /* @__PURE__ */ Ze(), o = /* @__PURE__ */ Dn(), p = /* @__PURE__ */ Hn();
  }(zr)), zr;
}
var Xr = {}, $n = {}, fr = {}, js;
function Lc() {
  if (js) return fr;
  js = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.isAsyncIterable = e;
  function e(n) {
    return typeof (n == null ? void 0 : n[Symbol.asyncIterator]) == "function";
  }
  return fr;
}
var mr = {}, Ps;
function Rc() {
  if (Ps) return mr;
  Ps = 1, Object.defineProperty(mr, "__esModule", {
    value: !0
  }), mr.mapAsyncIterator = e;
  function e(n, a) {
    const i = n[Symbol.asyncIterator]();
    async function t(r) {
      if (r.done)
        return r;
      try {
        return {
          value: await a(r.value),
          done: !1
        };
      } catch (s) {
        if (typeof i.return == "function")
          try {
            await i.return();
          } catch {
          }
        throw s;
      }
    }
    return {
      async next() {
        return t(await i.next());
      },
      async return() {
        return typeof i.return == "function" ? t(await i.return()) : {
          value: void 0,
          done: !0
        };
      },
      async throw(r) {
        if (typeof i.throw == "function")
          return t(await i.throw(r));
        throw r;
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  return mr;
}
var Fs;
function Dc() {
  if (Fs) return $n;
  Fs = 1, Object.defineProperty($n, "__esModule", {
    value: !0
  }), $n.createSourceEventStream = p, $n.subscribe = m;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Lc(), i = /* @__PURE__ */ Ur(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ fi(), s = /* @__PURE__ */ Ei(), u = /* @__PURE__ */ Kr(), c = /* @__PURE__ */ Rc(), d = /* @__PURE__ */ Zn();
  async function m(l) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const f = await p(l);
    if (!(0, a.isAsyncIterable)(f))
      return f;
    const h = (T) => (0, u.execute)({ ...l, rootValue: T });
    return (0, c.mapAsyncIterator)(
      f,
      h
    );
  }
  function o(l) {
    const f = l[0];
    return f && "document" in f ? f : {
      schema: f,
      // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
      document: l[1],
      rootValue: l[2],
      contextValue: l[3],
      variableValues: l[4],
      operationName: l[5],
      subscribeFieldResolver: l[6]
    };
  }
  async function p(...l) {
    const f = o(l), { schema: h, document: T, variableValues: O } = f;
    (0, u.assertValidExecutionArguments)(h, T, O);
    const R = (0, u.buildExecutionContext)(f);
    if (!("schema" in R))
      return {
        errors: R
      };
    try {
      const D = await y(R);
      if (!(0, a.isAsyncIterable)(D))
        throw new Error(
          `Subscription field must return Async Iterable. Received: ${(0, n.inspect)(D)}.`
        );
      return D;
    } catch (D) {
      if (D instanceof t.GraphQLError)
        return {
          errors: [D]
        };
      throw D;
    }
  }
  async function y(l) {
    const { schema: f, fragments: h, operation: T, variableValues: O, rootValue: R } = l, D = f.getSubscriptionType();
    if (D == null)
      throw new t.GraphQLError(
        "Schema is not configured to execute subscription operation.",
        {
          nodes: T
        }
      );
    const _ = (0, s.collectFields)(
      f,
      h,
      O,
      D,
      T.selectionSet
    ), [w, M] = [..._.entries()][0], V = (0, u.getFieldDef)(f, D, M[0]);
    if (!V) {
      const E = M[0].name.value;
      throw new t.GraphQLError(
        `The subscription field "${E}" is not defined.`,
        {
          nodes: M
        }
      );
    }
    const N = (0, i.addPath)(void 0, w, D.name), g = (0, u.buildResolveInfo)(
      l,
      V,
      M,
      D,
      N
    );
    try {
      var L;
      const E = (0, d.getArgumentValues)(
        V,
        M[0],
        O
      ), v = l.contextValue, I = await ((L = V.subscribe) !== null && L !== void 0 ? L : l.subscribeFieldResolver)(R, E, v, g);
      if (I instanceof Error)
        throw I;
      return I;
    } catch (E) {
      throw (0, r.locatedError)(
        E,
        M,
        (0, i.pathToArray)(N)
      );
    }
  }
  return $n;
}
var ws;
function Ac() {
  return ws || (ws = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return i.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return a.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return a.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return a.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return a.executeSync;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return t.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return t.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return t.getVariableValues;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return n.pathToArray;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return i.subscribe;
      }
    });
    var n = /* @__PURE__ */ Ur(), a = /* @__PURE__ */ Kr(), i = /* @__PURE__ */ Dc(), t = /* @__PURE__ */ Zn();
  }(Xr)), Xr;
}
var Hr = {}, hr = {}, ks;
function jc() {
  if (ks) return hr;
  ks = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.NoDeprecatedCustomRule = i;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ ue();
  function i(t) {
    return {
      Field(r) {
        const s = t.getFieldDef(), u = s == null ? void 0 : s.deprecationReason;
        if (s && u != null) {
          const c = t.getParentType();
          c != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The field ${c.name}.${s.name} is deprecated. ${u}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      Argument(r) {
        const s = t.getArgument(), u = s == null ? void 0 : s.deprecationReason;
        if (s && u != null) {
          const c = t.getDirective();
          if (c != null)
            t.reportError(
              new n.GraphQLError(
                `Directive "@${c.name}" argument "${s.name}" is deprecated. ${u}`,
                {
                  nodes: r
                }
              )
            );
          else {
            const d = t.getParentType(), m = t.getFieldDef();
            d != null && m != null || (0, e.invariant)(!1), t.reportError(
              new n.GraphQLError(
                `Field "${d.name}.${m.name}" argument "${s.name}" is deprecated. ${u}`,
                {
                  nodes: r
                }
              )
            );
          }
        }
      },
      ObjectField(r) {
        const s = (0, a.getNamedType)(
          t.getParentInputType()
        );
        if ((0, a.isInputObjectType)(s)) {
          const u = s.getFields()[r.name.value], c = u == null ? void 0 : u.deprecationReason;
          c != null && t.reportError(
            new n.GraphQLError(
              `The input field ${s.name}.${u.name} is deprecated. ${c}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      EnumValue(r) {
        const s = t.getEnumValue(), u = s == null ? void 0 : s.deprecationReason;
        if (s && u != null) {
          const c = (0, a.getNamedType)(
            t.getInputType()
          );
          c != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The enum value "${c.name}.${s.name}" is deprecated. ${u}`,
              {
                nodes: r
              }
            )
          );
        }
      }
    };
  }
  return hr;
}
var yr = {}, Vs;
function Pc() {
  if (Vs) return yr;
  Vs = 1, Object.defineProperty(yr, "__esModule", {
    value: !0
  }), yr.NoSchemaIntrospectionCustomRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ ue(), a = /* @__PURE__ */ Qe();
  function i(t) {
    return {
      Field(r) {
        const s = (0, n.getNamedType)(t.getType());
        s && (0, a.isIntrospectionType)(s) && t.reportError(
          new e.GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${r.name.value}".`,
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return yr;
}
var Cs;
function Fc() {
  return Cs || (Cs = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return t.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return r.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return s.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return u.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return c.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return d.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return m.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return o.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return I.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return b.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return te.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return p.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return pe.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return y.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return l.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return f.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return h.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return T.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return K.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return O.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return R.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return D.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return W.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return _.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return P.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return w.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return k.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return U.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return M.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return V.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return N.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return S.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return j.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return g.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return a.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return L.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return E.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return v.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return i.recommendedRules;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return i.specifiedRules;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.validate;
      }
    });
    var n = /* @__PURE__ */ qr(), a = /* @__PURE__ */ cu(), i = /* @__PURE__ */ uu(), t = /* @__PURE__ */ _o(), r = /* @__PURE__ */ Io(), s = /* @__PURE__ */ So(), u = /* @__PURE__ */ Lo(), c = /* @__PURE__ */ Ro(), d = /* @__PURE__ */ Do(), m = /* @__PURE__ */ Ao(), o = /* @__PURE__ */ jo(), p = /* @__PURE__ */ wo(), y = /* @__PURE__ */ ko(), l = /* @__PURE__ */ Vo(), f = /* @__PURE__ */ Co(), h = /* @__PURE__ */ Mo(), T = /* @__PURE__ */ $o(), O = /* @__PURE__ */ Qo(), R = /* @__PURE__ */ qo(), D = /* @__PURE__ */ Bo(), _ = /* @__PURE__ */ Jo(), w = /* @__PURE__ */ Xo(), M = /* @__PURE__ */ Zo(), V = /* @__PURE__ */ eu(), N = /* @__PURE__ */ nu(), g = /* @__PURE__ */ iu(), L = /* @__PURE__ */ au(), E = /* @__PURE__ */ su(), v = /* @__PURE__ */ ou(), b = /* @__PURE__ */ Fo(), I = /* @__PURE__ */ Po(), S = /* @__PURE__ */ tu(), j = /* @__PURE__ */ ru(), k = /* @__PURE__ */ Ho(), U = /* @__PURE__ */ Wo(), W = /* @__PURE__ */ Yo(), P = /* @__PURE__ */ zo(), K = /* @__PURE__ */ Uo(), te = /* @__PURE__ */ jc(), pe = /* @__PURE__ */ Pc();
  }(Hr)), Hr;
}
var Wr = {}, vr = {}, Gs;
function lu() {
  if (Gs) return vr;
  Gs = 1, Object.defineProperty(vr, "__esModule", {
    value: !0
  }), vr.getIntrospectionQuery = e;
  function e(n) {
    const a = {
      descriptions: !0,
      specifiedByUrl: !1,
      directiveIsRepeatable: !1,
      schemaDescription: !1,
      inputValueDeprecation: !1,
      oneOf: !1,
      ...n
    }, i = a.descriptions ? "description" : "", t = a.specifiedByUrl ? "specifiedByURL" : "", r = a.directiveIsRepeatable ? "isRepeatable" : "", s = a.schemaDescription ? i : "";
    function u(d) {
      return a.inputValueDeprecation ? d : "";
    }
    const c = a.oneOf ? "isOneOf" : "";
    return `
    query IntrospectionQuery {
      __schema {
        ${s}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${i}
          ${r}
          locations
          args${u("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${i}
      ${t}
      ${c}
      fields(includeDeprecated: true) {
        name
        ${i}
        args${u("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${u("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${i}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${i}
      type { ...TypeRef }
      defaultValue
      ${u("isDeprecated")}
      ${u("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  }
  return vr;
}
var Tr = {}, Ms;
function wc() {
  if (Ms) return Tr;
  Ms = 1, Object.defineProperty(Tr, "__esModule", {
    value: !0
  }), Tr.getOperationAST = n;
  var e = /* @__PURE__ */ oe();
  function n(a, i) {
    let t = null;
    for (const s of a.definitions)
      if (s.kind === e.Kind.OPERATION_DEFINITION) {
        var r;
        if (i == null) {
          if (t)
            return null;
          t = s;
        } else if (((r = s.name) === null || r === void 0 ? void 0 : r.value) === i)
          return s;
      }
    return t;
  }
  return Tr;
}
var br = {}, $s;
function kc() {
  if ($s) return br;
  $s = 1, Object.defineProperty(br, "__esModule", {
    value: !0
  }), br.getOperationRootType = n;
  var e = /* @__PURE__ */ ne();
  function n(a, i) {
    if (i.operation === "query") {
      const t = a.getQueryType();
      if (!t)
        throw new e.GraphQLError(
          "Schema does not define the required query root type.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "mutation") {
      const t = a.getMutationType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for mutations.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "subscription") {
      const t = a.getSubscriptionType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for subscriptions.",
          {
            nodes: i
          }
        );
      return t;
    }
    throw new e.GraphQLError(
      "Can only have query, mutation and subscription operations.",
      {
        nodes: i
      }
    );
  }
  return br;
}
var gr = {}, Us;
function Vc() {
  if (Us) return gr;
  Us = 1, Object.defineProperty(gr, "__esModule", {
    value: !0
  }), gr.introspectionFromSchema = t;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ Wn(), a = /* @__PURE__ */ Kr(), i = /* @__PURE__ */ lu();
  function t(r, s) {
    const u = {
      specifiedByUrl: !0,
      directiveIsRepeatable: !0,
      schemaDescription: !0,
      inputValueDeprecation: !0,
      oneOf: !0,
      ...s
    }, c = (0, n.parse)(
      (0, i.getIntrospectionQuery)(u)
    ), d = (0, a.executeSync)({
      schema: r,
      document: c
    });
    return !d.errors && d.data || (0, e.invariant)(!1), d.data;
  }
  return gr;
}
var Er = {}, Qs;
function Cc() {
  if (Qs) return Er;
  Qs = 1, Object.defineProperty(Er, "__esModule", {
    value: !0
  }), Er.buildClientSchema = o;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ We(), i = /* @__PURE__ */ kr(), t = /* @__PURE__ */ Wn(), r = /* @__PURE__ */ ue(), s = /* @__PURE__ */ Ve(), u = /* @__PURE__ */ Qe(), c = /* @__PURE__ */ en(), d = /* @__PURE__ */ Rn(), m = /* @__PURE__ */ Qr();
  function o(p, y) {
    (0, a.isObjectLike)(p) && (0, a.isObjectLike)(p.__schema) || (0, e.devAssert)(
      !1,
      `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, n.inspect)(p)}.`
    );
    const l = p.__schema, f = (0, i.keyValMap)(
      l.types,
      (P) => P.name,
      (P) => V(P)
    );
    for (const P of [
      ...c.specifiedScalarTypes,
      ...u.introspectionTypes
    ])
      f[P.name] && (f[P.name] = P);
    const h = l.queryType ? w(l.queryType) : null, T = l.mutationType ? w(l.mutationType) : null, O = l.subscriptionType ? w(l.subscriptionType) : null, R = l.directives ? l.directives.map(W) : [];
    return new d.GraphQLSchema({
      description: l.description,
      query: h,
      mutation: T,
      subscription: O,
      types: Object.values(f),
      directives: R,
      assumeValid: y == null ? void 0 : y.assumeValid
    });
    function D(P) {
      if (P.kind === u.TypeKind.LIST) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        return new r.GraphQLList(D(K));
      }
      if (P.kind === u.TypeKind.NON_NULL) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        const te = D(K);
        return new r.GraphQLNonNull(
          (0, r.assertNullableType)(te)
        );
      }
      return _(P);
    }
    function _(P) {
      const K = P.name;
      if (!K)
        throw new Error(
          `Unknown type reference: ${(0, n.inspect)(P)}.`
        );
      const te = f[K];
      if (!te)
        throw new Error(
          `Invalid or incomplete schema, unknown type: ${K}. Ensure that a full introspection query is used in order to build a client schema.`
        );
      return te;
    }
    function w(P) {
      return (0, r.assertObjectType)(_(P));
    }
    function M(P) {
      return (0, r.assertInterfaceType)(_(P));
    }
    function V(P) {
      if (P != null && P.name != null && P.kind != null)
        switch (P.kind) {
          case u.TypeKind.SCALAR:
            return N(P);
          case u.TypeKind.OBJECT:
            return L(P);
          case u.TypeKind.INTERFACE:
            return E(P);
          case u.TypeKind.UNION:
            return v(P);
          case u.TypeKind.ENUM:
            return b(P);
          case u.TypeKind.INPUT_OBJECT:
            return I(P);
        }
      const K = (0, n.inspect)(P);
      throw new Error(
        `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${K}.`
      );
    }
    function N(P) {
      return new r.GraphQLScalarType({
        name: P.name,
        description: P.description,
        specifiedByURL: P.specifiedByURL
      });
    }
    function g(P) {
      if (P.interfaces === null && P.kind === u.TypeKind.INTERFACE)
        return [];
      if (!P.interfaces) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing interfaces: ${K}.`
        );
      }
      return P.interfaces.map(M);
    }
    function L(P) {
      return new r.GraphQLObjectType({
        name: P.name,
        description: P.description,
        interfaces: () => g(P),
        fields: () => S(P)
      });
    }
    function E(P) {
      return new r.GraphQLInterfaceType({
        name: P.name,
        description: P.description,
        interfaces: () => g(P),
        fields: () => S(P)
      });
    }
    function v(P) {
      if (!P.possibleTypes) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing possibleTypes: ${K}.`
        );
      }
      return new r.GraphQLUnionType({
        name: P.name,
        description: P.description,
        types: () => P.possibleTypes.map(w)
      });
    }
    function b(P) {
      if (!P.enumValues) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing enumValues: ${K}.`
        );
      }
      return new r.GraphQLEnumType({
        name: P.name,
        description: P.description,
        values: (0, i.keyValMap)(
          P.enumValues,
          (K) => K.name,
          (K) => ({
            description: K.description,
            deprecationReason: K.deprecationReason
          })
        )
      });
    }
    function I(P) {
      if (!P.inputFields) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing inputFields: ${K}.`
        );
      }
      return new r.GraphQLInputObjectType({
        name: P.name,
        description: P.description,
        fields: () => k(P.inputFields),
        isOneOf: P.isOneOf
      });
    }
    function S(P) {
      if (!P.fields)
        throw new Error(
          `Introspection result missing fields: ${(0, n.inspect)(
            P
          )}.`
        );
      return (0, i.keyValMap)(
        P.fields,
        (K) => K.name,
        j
      );
    }
    function j(P) {
      const K = D(P.type);
      if (!(0, r.isOutputType)(K)) {
        const te = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide output type for fields, but received: ${te}.`
        );
      }
      if (!P.args) {
        const te = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing field args: ${te}.`
        );
      }
      return {
        description: P.description,
        deprecationReason: P.deprecationReason,
        type: K,
        args: k(P.args)
      };
    }
    function k(P) {
      return (0, i.keyValMap)(
        P,
        (K) => K.name,
        U
      );
    }
    function U(P) {
      const K = D(P.type);
      if (!(0, r.isInputType)(K)) {
        const pe = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide input type for arguments, but received: ${pe}.`
        );
      }
      const te = P.defaultValue != null ? (0, m.valueFromAST)(
        (0, t.parseValue)(P.defaultValue),
        K
      ) : void 0;
      return {
        description: P.description,
        type: K,
        defaultValue: te,
        deprecationReason: P.deprecationReason
      };
    }
    function W(P) {
      if (!P.args) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive args: ${K}.`
        );
      }
      if (!P.locations) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive locations: ${K}.`
        );
      }
      return new s.GraphQLDirective({
        name: P.name,
        description: P.description,
        isRepeatable: P.isRepeatable,
        locations: P.locations.slice(),
        args: k(P.args)
      });
    }
  }
  return Er;
}
var Un = {}, Qn = {}, qs;
function pu() {
  if (qs) return Qn;
  qs = 1, Object.defineProperty(Qn, "__esModule", {
    value: !0
  }), Qn.extendSchema = f, Qn.extendSchemaImpl = h;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ fe(), a = /* @__PURE__ */ Re(), i = /* @__PURE__ */ ln(), t = /* @__PURE__ */ No(), r = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Dn(), u = /* @__PURE__ */ ue(), c = /* @__PURE__ */ Ve(), d = /* @__PURE__ */ Qe(), m = /* @__PURE__ */ en(), o = /* @__PURE__ */ Rn(), p = /* @__PURE__ */ qr(), y = /* @__PURE__ */ Zn(), l = /* @__PURE__ */ Qr();
  function f(_, w, M) {
    (0, o.assertSchema)(_), w != null && w.kind === r.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), (M == null ? void 0 : M.assumeValid) !== !0 && (M == null ? void 0 : M.assumeValidSDL) !== !0 && (0, p.assertValidSDLExtension)(w, _);
    const V = _.toConfig(), N = h(V, w, M);
    return V === N ? _ : new o.GraphQLSchema(N);
  }
  function h(_, w, M) {
    var V, N, g, L;
    const E = [], v = /* @__PURE__ */ Object.create(null), b = [];
    let I;
    const S = [];
    for (const C of w.definitions)
      if (C.kind === r.Kind.SCHEMA_DEFINITION)
        I = C;
      else if (C.kind === r.Kind.SCHEMA_EXTENSION)
        S.push(C);
      else if ((0, s.isTypeDefinitionNode)(C))
        E.push(C);
      else if ((0, s.isTypeExtensionNode)(C)) {
        const J = C.name.value, q = v[J];
        v[J] = q ? q.concat([C]) : [C];
      } else C.kind === r.Kind.DIRECTIVE_DEFINITION && b.push(C);
    if (Object.keys(v).length === 0 && E.length === 0 && b.length === 0 && S.length === 0 && I == null)
      return _;
    const j = /* @__PURE__ */ Object.create(null);
    for (const C of _.types)
      j[C.name] = te(C);
    for (const C of E) {
      var k;
      const J = C.name.value;
      j[J] = (k = T[J]) !== null && k !== void 0 ? k : et(C);
    }
    const U = {
      // Get the extended root operation types.
      query: _.query && P(_.query),
      mutation: _.mutation && P(_.mutation),
      subscription: _.subscription && P(_.subscription),
      // Then, incorporate schema definition and all schema extensions.
      ...I && re([I]),
      ...re(S)
    };
    return {
      description: (V = I) === null || V === void 0 || (N = V.description) === null || N === void 0 ? void 0 : N.value,
      ...U,
      types: Object.values(j),
      directives: [
        ..._.directives.map(K),
        ...b.map(be)
      ],
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: (g = I) !== null && g !== void 0 ? g : _.astNode,
      extensionASTNodes: _.extensionASTNodes.concat(S),
      assumeValid: (L = M == null ? void 0 : M.assumeValid) !== null && L !== void 0 ? L : !1
    };
    function W(C) {
      return (0, u.isListType)(C) ? new u.GraphQLList(W(C.ofType)) : (0, u.isNonNullType)(C) ? new u.GraphQLNonNull(W(C.ofType)) : P(C);
    }
    function P(C) {
      return j[C.name];
    }
    function K(C) {
      const J = C.toConfig();
      return new c.GraphQLDirective({
        ...J,
        args: (0, t.mapValue)(J.args, Z)
      });
    }
    function te(C) {
      if ((0, d.isIntrospectionType)(C) || (0, m.isSpecifiedScalarType)(C))
        return C;
      if ((0, u.isScalarType)(C))
        return $(C);
      if ((0, u.isObjectType)(C))
        return x(C);
      if ((0, u.isInterfaceType)(C))
        return B(C);
      if ((0, u.isUnionType)(C))
        return ee(C);
      if ((0, u.isEnumType)(C))
        return G(C);
      if ((0, u.isInputObjectType)(C))
        return pe(C);
      (0, a.invariant)(
        !1,
        "Unexpected type: " + (0, n.inspect)(C)
      );
    }
    function pe(C) {
      var J;
      const q = C.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new u.GraphQLInputObjectType({
        ...q,
        fields: () => ({
          ...(0, t.mapValue)(q.fields, (me) => ({
            ...me,
            type: W(me.type)
          })),
          ...Ee(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function G(C) {
      var J;
      const q = C.toConfig(), z = (J = v[C.name]) !== null && J !== void 0 ? J : [];
      return new u.GraphQLEnumType({
        ...q,
        values: { ...q.values, ...De(z) },
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function $(C) {
      var J;
      const q = C.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      let me = q.specifiedByURL;
      for (const he of z) {
        var Ne;
        me = (Ne = R(he)) !== null && Ne !== void 0 ? Ne : me;
      }
      return new u.GraphQLScalarType({
        ...q,
        specifiedByURL: me,
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function x(C) {
      var J;
      const q = C.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new u.GraphQLObjectType({
        ...q,
        interfaces: () => [
          ...C.getInterfaces().map(P),
          ...je(z)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, Y),
          ...Ie(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function B(C) {
      var J;
      const q = C.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new u.GraphQLInterfaceType({
        ...q,
        interfaces: () => [
          ...C.getInterfaces().map(P),
          ...je(z)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, Y),
          ...Ie(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function ee(C) {
      var J;
      const q = C.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new u.GraphQLUnionType({
        ...q,
        types: () => [
          ...C.getTypes().map(P),
          ...Ce(z)
        ],
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function Y(C) {
      return {
        ...C,
        type: W(C.type),
        args: C.args && (0, t.mapValue)(C.args, Z)
      };
    }
    function Z(C) {
      return { ...C, type: W(C.type) };
    }
    function re(C) {
      const J = {};
      for (const z of C) {
        var q;
        const me = (
          /* c8 ignore next */
          (q = z.operationTypes) !== null && q !== void 0 ? q : []
        );
        for (const Ne of me)
          J[Ne.operation] = ce(Ne.type);
      }
      return J;
    }
    function ce(C) {
      var J;
      const q = C.name.value, z = (J = T[q]) !== null && J !== void 0 ? J : j[q];
      if (z === void 0)
        throw new Error(`Unknown type: "${q}".`);
      return z;
    }
    function de(C) {
      return C.kind === r.Kind.LIST_TYPE ? new u.GraphQLList(de(C.type)) : C.kind === r.Kind.NON_NULL_TYPE ? new u.GraphQLNonNull(de(C.type)) : ce(C);
    }
    function be(C) {
      var J;
      return new c.GraphQLDirective({
        name: C.name.value,
        description: (J = C.description) === null || J === void 0 ? void 0 : J.value,
        // @ts-expect-error
        locations: C.locations.map(({ value: q }) => q),
        isRepeatable: C.repeatable,
        args: ve(C.arguments),
        astNode: C
      });
    }
    function Ie(C) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const me of C) {
        var q;
        const Ne = (
          /* c8 ignore next */
          (q = me.fields) !== null && q !== void 0 ? q : []
        );
        for (const he of Ne) {
          var z;
          J[he.name.value] = {
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            type: de(he.type),
            description: (z = he.description) === null || z === void 0 ? void 0 : z.value,
            args: ve(he.arguments),
            deprecationReason: O(he),
            astNode: he
          };
        }
      }
      return J;
    }
    function ve(C) {
      const J = (
        /* c8 ignore next */
        C ?? []
      ), q = /* @__PURE__ */ Object.create(null);
      for (const me of J) {
        var z;
        const Ne = de(me.type);
        q[me.name.value] = {
          type: Ne,
          description: (z = me.description) === null || z === void 0 ? void 0 : z.value,
          defaultValue: (0, l.valueFromAST)(me.defaultValue, Ne),
          deprecationReason: O(me),
          astNode: me
        };
      }
      return q;
    }
    function Ee(C) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const me of C) {
        var q;
        const Ne = (
          /* c8 ignore next */
          (q = me.fields) !== null && q !== void 0 ? q : []
        );
        for (const he of Ne) {
          var z;
          const Be = de(he.type);
          J[he.name.value] = {
            type: Be,
            description: (z = he.description) === null || z === void 0 ? void 0 : z.value,
            defaultValue: (0, l.valueFromAST)(
              he.defaultValue,
              Be
            ),
            deprecationReason: O(he),
            astNode: he
          };
        }
      }
      return J;
    }
    function De(C) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const me of C) {
        var q;
        const Ne = (
          /* c8 ignore next */
          (q = me.values) !== null && q !== void 0 ? q : []
        );
        for (const he of Ne) {
          var z;
          J[he.name.value] = {
            description: (z = he.description) === null || z === void 0 ? void 0 : z.value,
            deprecationReason: O(he),
            astNode: he
          };
        }
      }
      return J;
    }
    function je(C) {
      return C.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (J) => {
          var q, z;
          return (
            /* c8 ignore next */
            (q = (z = J.interfaces) === null || z === void 0 ? void 0 : z.map(ce)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function Ce(C) {
      return C.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (J) => {
          var q, z;
          return (
            /* c8 ignore next */
            (q = (z = J.types) === null || z === void 0 ? void 0 : z.map(ce)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function et(C) {
      var J;
      const q = C.name.value, z = (J = v[q]) !== null && J !== void 0 ? J : [];
      switch (C.kind) {
        case r.Kind.OBJECT_TYPE_DEFINITION: {
          var me;
          const Se = [C, ...z];
          return new u.GraphQLObjectType({
            name: q,
            description: (me = C.description) === null || me === void 0 ? void 0 : me.value,
            interfaces: () => je(Se),
            fields: () => Ie(Se),
            astNode: C,
            extensionASTNodes: z
          });
        }
        case r.Kind.INTERFACE_TYPE_DEFINITION: {
          var Ne;
          const Se = [C, ...z];
          return new u.GraphQLInterfaceType({
            name: q,
            description: (Ne = C.description) === null || Ne === void 0 ? void 0 : Ne.value,
            interfaces: () => je(Se),
            fields: () => Ie(Se),
            astNode: C,
            extensionASTNodes: z
          });
        }
        case r.Kind.ENUM_TYPE_DEFINITION: {
          var he;
          const Se = [C, ...z];
          return new u.GraphQLEnumType({
            name: q,
            description: (he = C.description) === null || he === void 0 ? void 0 : he.value,
            values: De(Se),
            astNode: C,
            extensionASTNodes: z
          });
        }
        case r.Kind.UNION_TYPE_DEFINITION: {
          var Be;
          const Se = [C, ...z];
          return new u.GraphQLUnionType({
            name: q,
            description: (Be = C.description) === null || Be === void 0 ? void 0 : Be.value,
            types: () => Ce(Se),
            astNode: C,
            extensionASTNodes: z
          });
        }
        case r.Kind.SCALAR_TYPE_DEFINITION: {
          var An;
          return new u.GraphQLScalarType({
            name: q,
            description: (An = C.description) === null || An === void 0 ? void 0 : An.value,
            specifiedByURL: R(C),
            astNode: C,
            extensionASTNodes: z
          });
        }
        case r.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var dn;
          const Se = [C, ...z];
          return new u.GraphQLInputObjectType({
            name: q,
            description: (dn = C.description) === null || dn === void 0 ? void 0 : dn.value,
            fields: () => Ee(Se),
            astNode: C,
            extensionASTNodes: z,
            isOneOf: D(C)
          });
        }
      }
    }
  }
  const T = (0, i.keyMap)(
    [...m.specifiedScalarTypes, ...d.introspectionTypes],
    (_) => _.name
  );
  function O(_) {
    const w = (0, y.getDirectiveValues)(
      c.GraphQLDeprecatedDirective,
      _
    );
    return w == null ? void 0 : w.reason;
  }
  function R(_) {
    const w = (0, y.getDirectiveValues)(
      c.GraphQLSpecifiedByDirective,
      _
    );
    return w == null ? void 0 : w.url;
  }
  function D(_) {
    return !!(0, y.getDirectiveValues)(c.GraphQLOneOfDirective, _);
  }
  return Qn;
}
var Ks;
function Gc() {
  if (Ks) return Un;
  Ks = 1, Object.defineProperty(Un, "__esModule", {
    value: !0
  }), Un.buildASTSchema = u, Un.buildSchema = c;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Wn(), i = /* @__PURE__ */ Ve(), t = /* @__PURE__ */ Rn(), r = /* @__PURE__ */ qr(), s = /* @__PURE__ */ pu();
  function u(d, m) {
    d != null && d.kind === n.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), (m == null ? void 0 : m.assumeValid) !== !0 && (m == null ? void 0 : m.assumeValidSDL) !== !0 && (0, r.assertValidSDL)(d);
    const o = {
      description: void 0,
      types: [],
      directives: [],
      extensions: /* @__PURE__ */ Object.create(null),
      extensionASTNodes: [],
      assumeValid: !1
    }, p = (0, s.extendSchemaImpl)(
      o,
      d,
      m
    );
    if (p.astNode == null)
      for (const l of p.types)
        switch (l.name) {
          // Note: While this could make early assertions to get the correctly
          // typed values below, that would throw immediately while type system
          // validation with validateSchema() will produce more actionable results.
          case "Query":
            p.query = l;
            break;
          case "Mutation":
            p.mutation = l;
            break;
          case "Subscription":
            p.subscription = l;
            break;
        }
    const y = [
      ...p.directives,
      // If specified directives were not explicitly declared, add them.
      ...i.specifiedDirectives.filter(
        (l) => p.directives.every(
          (f) => f.name !== l.name
        )
      )
    ];
    return new t.GraphQLSchema({ ...p, directives: y });
  }
  function c(d, m) {
    const o = (0, a.parse)(d, {
      noLocation: m == null ? void 0 : m.noLocation,
      allowLegacyFragmentVariables: m == null ? void 0 : m.allowLegacyFragmentVariables
    });
    return u(o, {
      assumeValidSDL: m == null ? void 0 : m.assumeValidSDL,
      assumeValid: m == null ? void 0 : m.assumeValid
    });
  }
  return Un;
}
var Nr = {}, xs;
function Mc() {
  if (xs) return Nr;
  xs = 1, Object.defineProperty(Nr, "__esModule", {
    value: !0
  }), Nr.lexicographicSortSchema = c;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ kr(), i = /* @__PURE__ */ Vr(), t = /* @__PURE__ */ ue(), r = /* @__PURE__ */ Ve(), s = /* @__PURE__ */ Qe(), u = /* @__PURE__ */ Rn();
  function c(p) {
    const y = p.toConfig(), l = (0, a.keyValMap)(
      m(y.types),
      (V) => V.name,
      M
    );
    return new u.GraphQLSchema({
      ...y,
      types: Object.values(l),
      directives: m(y.directives).map(O),
      query: T(y.query),
      mutation: T(y.mutation),
      subscription: T(y.subscription)
    });
    function f(V) {
      return (0, t.isListType)(V) ? new t.GraphQLList(f(V.ofType)) : (0, t.isNonNullType)(V) ? new t.GraphQLNonNull(f(V.ofType)) : h(V);
    }
    function h(V) {
      return l[V.name];
    }
    function T(V) {
      return V && h(V);
    }
    function O(V) {
      const N = V.toConfig();
      return new r.GraphQLDirective({
        ...N,
        locations: o(N.locations, (g) => g),
        args: R(N.args)
      });
    }
    function R(V) {
      return d(V, (N) => ({ ...N, type: f(N.type) }));
    }
    function D(V) {
      return d(V, (N) => ({
        ...N,
        type: f(N.type),
        args: N.args && R(N.args)
      }));
    }
    function _(V) {
      return d(V, (N) => ({
        ...N,
        type: f(N.type)
      }));
    }
    function w(V) {
      return m(V).map(h);
    }
    function M(V) {
      if ((0, t.isScalarType)(V) || (0, s.isIntrospectionType)(V))
        return V;
      if ((0, t.isObjectType)(V)) {
        const N = V.toConfig();
        return new t.GraphQLObjectType({
          ...N,
          interfaces: () => w(N.interfaces),
          fields: () => D(N.fields)
        });
      }
      if ((0, t.isInterfaceType)(V)) {
        const N = V.toConfig();
        return new t.GraphQLInterfaceType({
          ...N,
          interfaces: () => w(N.interfaces),
          fields: () => D(N.fields)
        });
      }
      if ((0, t.isUnionType)(V)) {
        const N = V.toConfig();
        return new t.GraphQLUnionType({
          ...N,
          types: () => w(N.types)
        });
      }
      if ((0, t.isEnumType)(V)) {
        const N = V.toConfig();
        return new t.GraphQLEnumType({
          ...N,
          values: d(N.values, (g) => g)
        });
      }
      if ((0, t.isInputObjectType)(V)) {
        const N = V.toConfig();
        return new t.GraphQLInputObjectType({
          ...N,
          fields: () => _(N.fields)
        });
      }
      (0, n.invariant)(
        !1,
        "Unexpected type: " + (0, e.inspect)(V)
      );
    }
  }
  function d(p, y) {
    const l = /* @__PURE__ */ Object.create(null);
    for (const f of Object.keys(p).sort(i.naturalCompare))
      l[f] = y(p[f]);
    return l;
  }
  function m(p) {
    return o(p, (y) => y.name);
  }
  function o(p, y) {
    return p.slice().sort((l, f) => {
      const h = y(l), T = y(f);
      return (0, i.naturalCompare)(h, T);
    });
  }
  return Nr;
}
var On = {}, Bs;
function $c() {
  if (Bs) return On;
  Bs = 1, Object.defineProperty(On, "__esModule", {
    value: !0
  }), On.printIntrospectionSchema = o, On.printSchema = m, On.printType = h;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ Pr(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Ge(), r = /* @__PURE__ */ ue(), s = /* @__PURE__ */ Ve(), u = /* @__PURE__ */ Qe(), c = /* @__PURE__ */ en(), d = /* @__PURE__ */ Mr();
  function m(S) {
    return y(
      S,
      (j) => !(0, s.isSpecifiedDirective)(j),
      p
    );
  }
  function o(S) {
    return y(
      S,
      s.isSpecifiedDirective,
      u.isIntrospectionType
    );
  }
  function p(S) {
    return !(0, c.isSpecifiedScalarType)(S) && !(0, u.isIntrospectionType)(S);
  }
  function y(S, j, k) {
    const U = S.getDirectives().filter(j), W = Object.values(S.getTypeMap()).filter(k);
    return [
      l(S),
      ...U.map((P) => E(P)),
      ...W.map((P) => h(P))
    ].filter(Boolean).join(`

`);
  }
  function l(S) {
    if (S.description == null && f(S))
      return;
    const j = [], k = S.getQueryType();
    k && j.push(`  query: ${k.name}`);
    const U = S.getMutationType();
    U && j.push(`  mutation: ${U.name}`);
    const W = S.getSubscriptionType();
    return W && j.push(`  subscription: ${W.name}`), I(S) + `schema {
${j.join(`
`)}
}`;
  }
  function f(S) {
    const j = S.getQueryType();
    if (j && j.name !== "Query")
      return !1;
    const k = S.getMutationType();
    if (k && k.name !== "Mutation")
      return !1;
    const U = S.getSubscriptionType();
    return !(U && U.name !== "Subscription");
  }
  function h(S) {
    if ((0, r.isScalarType)(S))
      return T(S);
    if ((0, r.isObjectType)(S))
      return R(S);
    if ((0, r.isInterfaceType)(S))
      return D(S);
    if ((0, r.isUnionType)(S))
      return _(S);
    if ((0, r.isEnumType)(S))
      return w(S);
    if ((0, r.isInputObjectType)(S))
      return M(S);
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(S)
    );
  }
  function T(S) {
    return I(S) + `scalar ${S.name}` + b(S);
  }
  function O(S) {
    const j = S.getInterfaces();
    return j.length ? " implements " + j.map((k) => k.name).join(" & ") : "";
  }
  function R(S) {
    return I(S) + `type ${S.name}` + O(S) + V(S);
  }
  function D(S) {
    return I(S) + `interface ${S.name}` + O(S) + V(S);
  }
  function _(S) {
    const j = S.getTypes(), k = j.length ? " = " + j.join(" | ") : "";
    return I(S) + "union " + S.name + k;
  }
  function w(S) {
    const j = S.getValues().map(
      (k, U) => I(k, "  ", !U) + "  " + k.name + v(k.deprecationReason)
    );
    return I(S) + `enum ${S.name}` + N(j);
  }
  function M(S) {
    const j = Object.values(S.getFields()).map(
      (k, U) => I(k, "  ", !U) + "  " + L(k)
    );
    return I(S) + `input ${S.name}` + (S.isOneOf ? " @oneOf" : "") + N(j);
  }
  function V(S) {
    const j = Object.values(S.getFields()).map(
      (k, U) => I(k, "  ", !U) + "  " + k.name + g(k.args, "  ") + ": " + String(k.type) + v(k.deprecationReason)
    );
    return N(j);
  }
  function N(S) {
    return S.length !== 0 ? ` {
` + S.join(`
`) + `
}` : "";
  }
  function g(S, j = "") {
    return S.length === 0 ? "" : S.every((k) => !k.description) ? "(" + S.map(L).join(", ") + ")" : `(
` + S.map(
      (k, U) => I(k, "  " + j, !U) + "  " + j + L(k)
    ).join(`
`) + `
` + j + ")";
  }
  function L(S) {
    const j = (0, d.astFromValue)(
      S.defaultValue,
      S.type
    );
    let k = S.name + ": " + String(S.type);
    return j && (k += ` = ${(0, t.print)(j)}`), k + v(S.deprecationReason);
  }
  function E(S) {
    return I(S) + "directive @" + S.name + g(S.args) + (S.isRepeatable ? " repeatable" : "") + " on " + S.locations.join(" | ");
  }
  function v(S) {
    return S == null ? "" : S !== s.DEFAULT_DEPRECATION_REASON ? ` @deprecated(reason: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: S
    })})` : " @deprecated";
  }
  function b(S) {
    return S.specifiedByURL == null ? "" : ` @specifiedBy(url: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: S.specifiedByURL
    })})`;
  }
  function I(S, j = "", k = !0) {
    const { description: U } = S;
    if (U == null)
      return "";
    const W = (0, t.print)({
      kind: i.Kind.STRING,
      value: U,
      block: (0, a.isPrintableAsBlockString)(U)
    });
    return (j && !k ? `
` + j : j) + W.replace(/\n/g, `
` + j) + `
`;
  }
  return On;
}
var Or = {}, Ys;
function Uc() {
  if (Ys) return Or;
  Ys = 1, Object.defineProperty(Or, "__esModule", {
    value: !0
  }), Or.concatAST = n;
  var e = /* @__PURE__ */ oe();
  function n(a) {
    const i = [];
    for (const t of a)
      i.push(...t.definitions);
    return {
      kind: e.Kind.DOCUMENT,
      definitions: i
    };
  }
  return Or;
}
var _r = {}, Js;
function Qc() {
  if (Js) return _r;
  Js = 1, Object.defineProperty(_r, "__esModule", {
    value: !0
  }), _r.separateOperations = a;
  var e = /* @__PURE__ */ oe(), n = /* @__PURE__ */ Ln();
  function a(r) {
    const s = [], u = /* @__PURE__ */ Object.create(null);
    for (const d of r.definitions)
      switch (d.kind) {
        case e.Kind.OPERATION_DEFINITION:
          s.push(d);
          break;
        case e.Kind.FRAGMENT_DEFINITION:
          u[d.name.value] = t(
            d.selectionSet
          );
          break;
      }
    const c = /* @__PURE__ */ Object.create(null);
    for (const d of s) {
      const m = /* @__PURE__ */ new Set();
      for (const p of t(d.selectionSet))
        i(m, u, p);
      const o = d.name ? d.name.value : "";
      c[o] = {
        kind: e.Kind.DOCUMENT,
        definitions: r.definitions.filter(
          (p) => p === d || p.kind === e.Kind.FRAGMENT_DEFINITION && m.has(p.name.value)
        )
      };
    }
    return c;
  }
  function i(r, s, u) {
    if (!r.has(u)) {
      r.add(u);
      const c = s[u];
      if (c !== void 0)
        for (const d of c)
          i(r, s, d);
    }
  }
  function t(r) {
    const s = [];
    return (0, n.visit)(r, {
      FragmentSpread(u) {
        s.push(u.name.value);
      }
    }), s;
  }
  return _r;
}
var Ir = {}, zs;
function qc() {
  if (zs) return Ir;
  zs = 1, Object.defineProperty(Ir, "__esModule", {
    value: !0
  }), Ir.stripIgnoredCharacters = t;
  var e = /* @__PURE__ */ Pr(), n = /* @__PURE__ */ yi(), a = /* @__PURE__ */ vi(), i = /* @__PURE__ */ Fr();
  function t(r) {
    const s = (0, a.isSource)(r) ? r : new a.Source(r), u = s.body, c = new n.Lexer(s);
    let d = "", m = !1;
    for (; c.advance().kind !== i.TokenKind.EOF; ) {
      const o = c.token, p = o.kind, y = !(0, n.isPunctuatorTokenKind)(
        o.kind
      );
      m && (y || o.kind === i.TokenKind.SPREAD) && (d += " ");
      const l = u.slice(o.start, o.end);
      p === i.TokenKind.BLOCK_STRING ? d += (0, e.printBlockString)(o.value, {
        minimize: !0
      }) : d += l, m = y;
    }
    return d;
  }
  return Ir;
}
var qn = {}, Xs;
function Kc() {
  if (Xs) return qn;
  Xs = 1, Object.defineProperty(qn, "__esModule", {
    value: !0
  }), qn.assertValidName = i, qn.isValidNameError = t;
  var e = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ ne(), a = /* @__PURE__ */ Cr();
  function i(r) {
    const s = t(r);
    if (s)
      throw s;
    return r;
  }
  function t(r) {
    if (typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.startsWith("__"))
      return new n.GraphQLError(
        `Name "${r}" must not begin with "__", which is reserved by GraphQL introspection.`
      );
    try {
      (0, a.assertName)(r);
    } catch (s) {
      return s;
    }
  }
  return qn;
}
var $e = {}, Hs;
function xc() {
  if (Hs) return $e;
  Hs = 1, Object.defineProperty($e, "__esModule", {
    value: !0
  }), $e.DangerousChangeType = $e.BreakingChangeType = void 0, $e.findBreakingChanges = m, $e.findDangerousChanges = o;
  var e = /* @__PURE__ */ fe(), n = /* @__PURE__ */ Re(), a = /* @__PURE__ */ ln(), i = /* @__PURE__ */ Ge(), t = /* @__PURE__ */ ue(), r = /* @__PURE__ */ en(), s = /* @__PURE__ */ Mr(), u = /* @__PURE__ */ Go(), c;
  $e.BreakingChangeType = c, function(g) {
    g.TYPE_REMOVED = "TYPE_REMOVED", g.TYPE_CHANGED_KIND = "TYPE_CHANGED_KIND", g.TYPE_REMOVED_FROM_UNION = "TYPE_REMOVED_FROM_UNION", g.VALUE_REMOVED_FROM_ENUM = "VALUE_REMOVED_FROM_ENUM", g.REQUIRED_INPUT_FIELD_ADDED = "REQUIRED_INPUT_FIELD_ADDED", g.IMPLEMENTED_INTERFACE_REMOVED = "IMPLEMENTED_INTERFACE_REMOVED", g.FIELD_REMOVED = "FIELD_REMOVED", g.FIELD_CHANGED_KIND = "FIELD_CHANGED_KIND", g.REQUIRED_ARG_ADDED = "REQUIRED_ARG_ADDED", g.ARG_REMOVED = "ARG_REMOVED", g.ARG_CHANGED_KIND = "ARG_CHANGED_KIND", g.DIRECTIVE_REMOVED = "DIRECTIVE_REMOVED", g.DIRECTIVE_ARG_REMOVED = "DIRECTIVE_ARG_REMOVED", g.REQUIRED_DIRECTIVE_ARG_ADDED = "REQUIRED_DIRECTIVE_ARG_ADDED", g.DIRECTIVE_REPEATABLE_REMOVED = "DIRECTIVE_REPEATABLE_REMOVED", g.DIRECTIVE_LOCATION_REMOVED = "DIRECTIVE_LOCATION_REMOVED";
  }(
    c || ($e.BreakingChangeType = c = {})
  );
  var d;
  $e.DangerousChangeType = d, function(g) {
    g.VALUE_ADDED_TO_ENUM = "VALUE_ADDED_TO_ENUM", g.TYPE_ADDED_TO_UNION = "TYPE_ADDED_TO_UNION", g.OPTIONAL_INPUT_FIELD_ADDED = "OPTIONAL_INPUT_FIELD_ADDED", g.OPTIONAL_ARG_ADDED = "OPTIONAL_ARG_ADDED", g.IMPLEMENTED_INTERFACE_ADDED = "IMPLEMENTED_INTERFACE_ADDED", g.ARG_DEFAULT_VALUE_CHANGE = "ARG_DEFAULT_VALUE_CHANGE";
  }(
    d || ($e.DangerousChangeType = d = {})
  );
  function m(g, L) {
    return p(g, L).filter(
      (E) => E.type in c
    );
  }
  function o(g, L) {
    return p(g, L).filter(
      (E) => E.type in d
    );
  }
  function p(g, L) {
    return [
      ...l(g, L),
      ...y(g, L)
    ];
  }
  function y(g, L) {
    const E = [], v = N(
      g.getDirectives(),
      L.getDirectives()
    );
    for (const b of v.removed)
      E.push({
        type: c.DIRECTIVE_REMOVED,
        description: `${b.name} was removed.`
      });
    for (const [b, I] of v.persisted) {
      const S = N(b.args, I.args);
      for (const j of S.added)
        (0, t.isRequiredArgument)(j) && E.push({
          type: c.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${j.name} on directive ${b.name} was added.`
        });
      for (const j of S.removed)
        E.push({
          type: c.DIRECTIVE_ARG_REMOVED,
          description: `${j.name} was removed from ${b.name}.`
        });
      b.isRepeatable && !I.isRepeatable && E.push({
        type: c.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${b.name}.`
      });
      for (const j of b.locations)
        I.locations.includes(j) || E.push({
          type: c.DIRECTIVE_LOCATION_REMOVED,
          description: `${j} was removed from ${b.name}.`
        });
    }
    return E;
  }
  function l(g, L) {
    const E = [], v = N(
      Object.values(g.getTypeMap()),
      Object.values(L.getTypeMap())
    );
    for (const b of v.removed)
      E.push({
        type: c.TYPE_REMOVED,
        description: (0, r.isSpecifiedScalarType)(b) ? `Standard scalar ${b.name} was removed because it is not referenced anymore.` : `${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      (0, t.isEnumType)(b) && (0, t.isEnumType)(I) ? E.push(...T(b, I)) : (0, t.isUnionType)(b) && (0, t.isUnionType)(I) ? E.push(...h(b, I)) : (0, t.isInputObjectType)(b) && (0, t.isInputObjectType)(I) ? E.push(...f(b, I)) : (0, t.isObjectType)(b) && (0, t.isObjectType)(I) ? E.push(
        ...R(b, I),
        ...O(b, I)
      ) : (0, t.isInterfaceType)(b) && (0, t.isInterfaceType)(I) ? E.push(
        ...R(b, I),
        ...O(b, I)
      ) : b.constructor !== I.constructor && E.push({
        type: c.TYPE_CHANGED_KIND,
        description: `${b.name} changed from ${M(b)} to ${M(I)}.`
      });
    return E;
  }
  function f(g, L) {
    const E = [], v = N(
      Object.values(g.getFields()),
      Object.values(L.getFields())
    );
    for (const b of v.added)
      (0, t.isRequiredInputField)(b) ? E.push({
        type: c.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${b.name} on input type ${g.name} was added.`
      }) : E.push({
        type: d.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${b.name} on input type ${g.name} was added.`
      });
    for (const b of v.removed)
      E.push({
        type: c.FIELD_REMOVED,
        description: `${g.name}.${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      w(
        b.type,
        I.type
      ) || E.push({
        type: c.FIELD_CHANGED_KIND,
        description: `${g.name}.${b.name} changed type from ${String(b.type)} to ${String(I.type)}.`
      });
    return E;
  }
  function h(g, L) {
    const E = [], v = N(g.getTypes(), L.getTypes());
    for (const b of v.added)
      E.push({
        type: d.TYPE_ADDED_TO_UNION,
        description: `${b.name} was added to union type ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: c.TYPE_REMOVED_FROM_UNION,
        description: `${b.name} was removed from union type ${g.name}.`
      });
    return E;
  }
  function T(g, L) {
    const E = [], v = N(g.getValues(), L.getValues());
    for (const b of v.added)
      E.push({
        type: d.VALUE_ADDED_TO_ENUM,
        description: `${b.name} was added to enum type ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: c.VALUE_REMOVED_FROM_ENUM,
        description: `${b.name} was removed from enum type ${g.name}.`
      });
    return E;
  }
  function O(g, L) {
    const E = [], v = N(g.getInterfaces(), L.getInterfaces());
    for (const b of v.added)
      E.push({
        type: d.IMPLEMENTED_INTERFACE_ADDED,
        description: `${b.name} added to interfaces implemented by ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: c.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${g.name} no longer implements interface ${b.name}.`
      });
    return E;
  }
  function R(g, L) {
    const E = [], v = N(
      Object.values(g.getFields()),
      Object.values(L.getFields())
    );
    for (const b of v.removed)
      E.push({
        type: c.FIELD_REMOVED,
        description: `${g.name}.${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      E.push(...D(g, b, I)), _(
        b.type,
        I.type
      ) || E.push({
        type: c.FIELD_CHANGED_KIND,
        description: `${g.name}.${b.name} changed type from ${String(b.type)} to ${String(I.type)}.`
      });
    return E;
  }
  function D(g, L, E) {
    const v = [], b = N(L.args, E.args);
    for (const I of b.removed)
      v.push({
        type: c.ARG_REMOVED,
        description: `${g.name}.${L.name} arg ${I.name} was removed.`
      });
    for (const [I, S] of b.persisted)
      if (!w(
        I.type,
        S.type
      ))
        v.push({
          type: c.ARG_CHANGED_KIND,
          description: `${g.name}.${L.name} arg ${I.name} has changed type from ${String(I.type)} to ${String(S.type)}.`
        });
      else if (I.defaultValue !== void 0)
        if (S.defaultValue === void 0)
          v.push({
            type: d.ARG_DEFAULT_VALUE_CHANGE,
            description: `${g.name}.${L.name} arg ${I.name} defaultValue was removed.`
          });
        else {
          const k = V(I.defaultValue, I.type), U = V(S.defaultValue, S.type);
          k !== U && v.push({
            type: d.ARG_DEFAULT_VALUE_CHANGE,
            description: `${g.name}.${L.name} arg ${I.name} has changed defaultValue from ${k} to ${U}.`
          });
        }
    for (const I of b.added)
      (0, t.isRequiredArgument)(I) ? v.push({
        type: c.REQUIRED_ARG_ADDED,
        description: `A required arg ${I.name} on ${g.name}.${L.name} was added.`
      }) : v.push({
        type: d.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${I.name} on ${g.name}.${L.name} was added.`
      });
    return v;
  }
  function _(g, L) {
    return (0, t.isListType)(g) ? (
      // if they're both lists, make sure the underlying types are compatible
      (0, t.isListType)(L) && _(
        g.ofType,
        L.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(L) && _(g, L.ofType)
    ) : (0, t.isNonNullType)(g) ? (0, t.isNonNullType)(L) && _(g.ofType, L.ofType) : (
      // if they're both named types, see if their names are equivalent
      (0, t.isNamedType)(L) && g.name === L.name || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(L) && _(g, L.ofType)
    );
  }
  function w(g, L) {
    return (0, t.isListType)(g) ? (0, t.isListType)(L) && w(g.ofType, L.ofType) : (0, t.isNonNullType)(g) ? (
      // if they're both non-null, make sure the underlying types are
      // compatible
      (0, t.isNonNullType)(L) && w(
        g.ofType,
        L.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !(0, t.isNonNullType)(L) && w(g.ofType, L)
    ) : (0, t.isNamedType)(L) && g.name === L.name;
  }
  function M(g) {
    if ((0, t.isScalarType)(g))
      return "a Scalar type";
    if ((0, t.isObjectType)(g))
      return "an Object type";
    if ((0, t.isInterfaceType)(g))
      return "an Interface type";
    if ((0, t.isUnionType)(g))
      return "a Union type";
    if ((0, t.isEnumType)(g))
      return "an Enum type";
    if ((0, t.isInputObjectType)(g))
      return "an Input type";
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(g)
    );
  }
  function V(g, L) {
    const E = (0, s.astFromValue)(g, L);
    return E != null || (0, n.invariant)(!1), (0, i.print)((0, u.sortValueNode)(E));
  }
  function N(g, L) {
    const E = [], v = [], b = [], I = (0, a.keyMap)(g, ({ name: j }) => j), S = (0, a.keyMap)(L, ({ name: j }) => j);
    for (const j of g) {
      const k = S[j.name];
      k === void 0 ? v.push(j) : b.push([j, k]);
    }
    for (const j of L)
      I[j.name] === void 0 && E.push(j);
    return {
      added: E,
      persisted: b,
      removed: v
    };
  }
  return $e;
}
var Ws;
function Bc() {
  return Ws || (Ws = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return _.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return _.DangerousChangeType;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return l.TypeInfo;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return D.assertValidName;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return y.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return s.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return r.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return s.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return f.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return h.concatAST;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return R.doTypesOverlap;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return u.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return _.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return _.findDangerousChanges;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return n.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return a.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return i.getOperationRootType;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return t.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return R.isEqualType;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return R.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return D.isValidNameError;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return c.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return d.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return d.printSchema;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return d.printType;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return T.separateOperations;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return O.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return m.typeFromAST;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return o.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return p.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return l.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ lu(), a = /* @__PURE__ */ wc(), i = /* @__PURE__ */ kc(), t = /* @__PURE__ */ Vc(), r = /* @__PURE__ */ Cc(), s = /* @__PURE__ */ Gc(), u = /* @__PURE__ */ pu(), c = /* @__PURE__ */ Mc(), d = /* @__PURE__ */ $c(), m = /* @__PURE__ */ nn(), o = /* @__PURE__ */ Qr(), p = /* @__PURE__ */ Oo(), y = /* @__PURE__ */ Mr(), l = /* @__PURE__ */ gi(), f = /* @__PURE__ */ xo(), h = /* @__PURE__ */ Uc(), T = /* @__PURE__ */ Qc(), O = /* @__PURE__ */ qc(), R = /* @__PURE__ */ Gr(), D = /* @__PURE__ */ Kc(), _ = /* @__PURE__ */ xc();
  }(Wr)), Wr;
}
var Zs;
function Yc() {
  return Zs || (Zs = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return t.BREAK;
      }
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return c.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return c.DangerousChangeType;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return t.DirectiveLocation;
      }
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return s.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return s.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return s.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return i.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return u.GraphQLError;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return i.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return i.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return i.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return i.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return i.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return s.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return s.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return s.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return s.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return t.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return t.Location;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return s.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return s.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return s.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return s.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return s.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return s.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return s.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return s.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return s.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return t.OperationTypeNode;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return s.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return s.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return s.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return s.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return s.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return s.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return t.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return t.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return t.TokenKind;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return c.TypeInfo;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return i.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return s.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return s.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return s.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return s.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return s.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return i.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return i.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return i.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return i.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return i.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return i.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return i.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return i.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return i.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return i.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return i.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return i.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return i.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return i.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return i.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return i.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return i.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return i.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return i.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return i.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return i.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return i.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return i.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return i.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return c.assertValidName;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return i.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return i.assertWrappingType;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return c.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return c.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return c.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return c.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return c.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return c.concatAST;
      }
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return r.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return c.doTypesOverlap;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return r.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return r.executeSync;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return c.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return c.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return c.findDangerousChanges;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return u.formatError;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return r.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return r.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return t.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return c.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return t.getLocation;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return i.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return i.getNullableType;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return c.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return c.getOperationRootType;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return r.getVariableValues;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return t.getVisitFn;
      }
    }), Object.defineProperty(e, "graphql", {
      enumerable: !0,
      get: function() {
        return a.graphql;
      }
    }), Object.defineProperty(e, "graphqlSync", {
      enumerable: !0,
      get: function() {
        return a.graphqlSync;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return c.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return i.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return i.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return i.isCompositeType;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return t.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return i.isEnumType;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return c.isEqualType;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return i.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return i.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return i.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return i.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return i.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return i.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return i.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return i.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return i.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return i.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return i.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return i.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return i.isSchema;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return t.isSelectionNode;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return i.isType;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return c.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return i.isUnionType;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return c.isValidNameError;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return t.isValueNode;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return i.isWrappingType;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return c.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return u.locatedError;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return t.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return t.parseConstValue;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return t.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return t.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return t.print;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return u.printError;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return c.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return t.printLocation;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return c.printSchema;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return t.printSourceLocation;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return c.printType;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return s.recommendedRules;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return r.responsePathAsArray;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return c.separateOperations;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return s.specifiedRules;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return i.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return c.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return r.subscribe;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return u.syntaxError;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return c.typeFromAST;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return s.validate;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return i.validateSchema;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return c.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return c.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return n.version;
      }
    }), Object.defineProperty(e, "versionInfo", {
      enumerable: !0,
      get: function() {
        return n.versionInfo;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return t.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return t.visitInParallel;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return c.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ Tc(), a = /* @__PURE__ */ _c(), i = /* @__PURE__ */ Ic(), t = /* @__PURE__ */ Sc(), r = /* @__PURE__ */ Ac(), s = /* @__PURE__ */ Fc(), u = /* @__PURE__ */ vc(), c = /* @__PURE__ */ Bc();
  }(Yr)), Yr;
}
var Jc = /* @__PURE__ */ Yc();
const Zr = "$[Circular Reference]", ii = (e, n = /* @__PURE__ */ new Map(), a = []) => {
  if (e === Zr) return Zr;
  if (e === null || typeof e != "object") return e;
  const i = a.join(".");
  if (e.type === "object" && e.properties) {
    const r = Object.keys(e.properties).sort().join("-");
    if (n.has(r)) {
      const s = n.get(r);
      if (s.some((u) => i.startsWith(u)))
        return Zr;
      n.set(r, [...s, i]);
    } else
      n.set(r, [i]);
  }
  if (Array.isArray(e))
    return e.map(
      (r, s) => ii(r, n, [...a, `${s}`])
    );
  const t = {};
  for (const [r, s] of Object.entries(e))
    t[r] = ii(s, n, [...a, r]);
  return t;
}, pl = new Jc.GraphQLScalarType({
  ...Ci,
  name: "JSONSchema",
  description: "OpenAPI schema scalar type that handles circular references",
  serialize: (e) => Ci.serialize(ii(e))
});
export {
  Zc as $,
  ic as A,
  Yn as B,
  Zr as C,
  zn as D,
  fc as E,
  al as F,
  ci as G,
  tc as H,
  sl as I,
  il as J,
  Te as K,
  Xc as L,
  rc as M,
  ol as N,
  Di as O,
  nl as P,
  rl as Q,
  lo as R,
  $u as S,
  ie as T,
  Ri as U,
  Qu as V,
  Ku as W,
  Bu as X,
  qu as Y,
  po as Z,
  Wu as _,
  Hc as a,
  si as a0,
  lc as a1,
  pc as a2,
  mc as a3,
  vc as a4,
  Ci as a5,
  ul as a6,
  pl as a7,
  zc as b,
  tl as c,
  Sn as d,
  fo as e,
  Jn as f,
  jr as g,
  qe as h,
  Wc as i,
  Lr as j,
  ke as k,
  eo as l,
  He as m,
  ac as n,
  xe as o,
  Ou as p,
  ye as q,
  uc as r,
  Ue as s,
  Ke as t,
  cc as u,
  oi as v,
  el as w,
  Xn as x,
  yu as y,
  oc as z
};
//# sourceMappingURL=circular-ByJI6Mci.js.map
