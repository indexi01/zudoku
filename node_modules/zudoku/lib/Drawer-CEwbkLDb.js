import { j as X } from "./jsx-runtime-C5mzlN2N.js";
import * as mt from "react";
import r, { useMemo as ye, useLayoutEffect as be, useEffect as Se } from "react";
import * as Z from "@radix-ui/react-dialog";
import { c as ot } from "./cn-qaFjX9_3.js";
function De(t) {
  if (typeof document > "u") return;
  let n = document.head || document.getElementsByTagName("head")[0], e = document.createElement("style");
  e.type = "text/css", n.appendChild(e), e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
const qt = r.createContext({
  drawerRef: {
    current: null
  },
  overlayRef: {
    current: null
  },
  onPress: () => {
  },
  onRelease: () => {
  },
  onDrag: () => {
  },
  onNestedDrag: () => {
  },
  onNestedOpenChange: () => {
  },
  onNestedRelease: () => {
  },
  openProp: void 0,
  dismissible: !1,
  isOpen: !1,
  isDragging: !1,
  keyboardIsOpen: {
    current: !1
  },
  snapPointsOffset: null,
  snapPoints: null,
  handleOnly: !1,
  modal: !1,
  shouldFade: !1,
  activeSnapPoint: null,
  onOpenChange: () => {
  },
  setActiveSnapPoint: () => {
  },
  closeDrawer: () => {
  },
  direction: "bottom",
  shouldAnimate: {
    current: !0
  },
  shouldScaleBackground: !1,
  setBackgroundColorOnScale: !0,
  noBodyStyles: !1,
  container: null,
  autoFocus: !1
}), pt = () => {
  const t = r.useContext(qt);
  if (!t)
    throw new Error("useDrawerContext must be used within a Drawer.Root");
  return t;
};
De(`[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform,100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform,100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(
[data-state=closed]
){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,var(--initial-transform,100%),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform,100%),0)}}@keyframes slideFromTop{from{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}}@keyframes slideFromLeft{from{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}}@keyframes slideFromRight{from{transform:translate3d(var(--initial-transform,100%),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform,100%),0,0)}}`);
function Te() {
  const t = navigator.userAgent;
  return typeof window < "u" && (/Firefox/.test(t) && /Mobile/.test(t) || // Android Firefox
  /FxiOS/.test(t));
}
function Re() {
  return Nt(/^Mac/);
}
function Ee() {
  return Nt(/^iPhone/);
}
function Wt() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function xe() {
  return Nt(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  Re() && navigator.maxTouchPoints > 1;
}
function Xt() {
  return Ee() || xe();
}
function Nt(t) {
  return typeof window < "u" && window.navigator != null ? t.test(window.navigator.platform) : void 0;
}
const Oe = 24, Ce = typeof window < "u" ? be : Se;
function zt(...t) {
  return (...n) => {
    for (let e of t)
      typeof e == "function" && e(...n);
  };
}
const xt = typeof document < "u" && window.visualViewport;
function Vt(t) {
  let n = window.getComputedStyle(t);
  return /(auto|scroll)/.test(n.overflow + n.overflowX + n.overflowY);
}
function Kt(t) {
  for (Vt(t) && (t = t.parentElement); t && !Vt(t); )
    t = t.parentElement;
  return t || document.scrollingElement || document.documentElement;
}
const $e = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let vt = 0, Ot;
function Ae(t = {}) {
  let { isDisabled: n } = t;
  Ce(() => {
    if (!n)
      return vt++, vt === 1 && Xt() && (Ot = Me()), () => {
        vt--, vt === 0 && (Ot == null || Ot());
      };
  }, [
    n
  ]);
}
function Me() {
  let t, n = 0, e = (f) => {
    t = Kt(f.target), !(t === document.documentElement && t === document.body) && (n = f.changedTouches[0].pageY);
  }, a = (f) => {
    if (!t || t === document.documentElement || t === document.body) {
      f.preventDefault();
      return;
    }
    let m = f.changedTouches[0].pageY, B = t.scrollTop, k = t.scrollHeight - t.clientHeight;
    k !== 0 && ((B <= 0 && m > n || B >= k && m < n) && f.preventDefault(), n = m);
  }, i = (f) => {
    let m = f.target;
    At(m) && m !== document.activeElement && (f.preventDefault(), m.style.transform = "translateY(-2000px)", m.focus(), requestAnimationFrame(() => {
      m.style.transform = "";
    }));
  }, o = (f) => {
    let m = f.target;
    At(m) && (m.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      m.style.transform = "", xt && (xt.height < window.innerHeight ? requestAnimationFrame(() => {
        Yt(m);
      }) : xt.addEventListener("resize", () => Yt(m), {
        once: !0
      }));
    }));
  }, v = () => {
    window.scrollTo(0, 0);
  }, w = window.pageXOffset, D = window.pageYOffset, R = zt(Ne(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`));
  window.scrollTo(0, 0);
  let h = zt(dt(document, "touchstart", e, {
    passive: !1,
    capture: !0
  }), dt(document, "touchmove", a, {
    passive: !1,
    capture: !0
  }), dt(document, "touchend", i, {
    passive: !1,
    capture: !0
  }), dt(document, "focus", o, !0), dt(window, "scroll", v));
  return () => {
    R(), h(), window.scrollTo(w, D);
  };
}
function Ne(t, n, e) {
  let a = t.style[n];
  return t.style[n] = e, () => {
    t.style[n] = a;
  };
}
function dt(t, n, e, a) {
  return t.addEventListener(n, e, a), () => {
    t.removeEventListener(n, e, a);
  };
}
function Yt(t) {
  let n = document.scrollingElement || document.documentElement;
  for (; t && t !== n; ) {
    let e = Kt(t);
    if (e !== document.documentElement && e !== document.body && e !== t) {
      let a = e.getBoundingClientRect().top, i = t.getBoundingClientRect().top, o = t.getBoundingClientRect().bottom;
      const v = e.getBoundingClientRect().bottom + Oe;
      o > v && (e.scrollTop += i - a);
    }
    t = e.parentElement;
  }
}
function At(t) {
  return t instanceof HTMLInputElement && !$e.has(t.type) || t instanceof HTMLTextAreaElement || t instanceof HTMLElement && t.isContentEditable;
}
function Pe(t, n) {
  typeof t == "function" ? t(n) : t != null && (t.current = n);
}
function Ie(...t) {
  return (n) => t.forEach((e) => Pe(e, n));
}
function Gt(...t) {
  return mt.useCallback(Ie(...t), t);
}
const Jt = /* @__PURE__ */ new WeakMap();
function $(t, n, e = !1) {
  if (!t || !(t instanceof HTMLElement)) return;
  let a = {};
  Object.entries(n).forEach(([i, o]) => {
    if (i.startsWith("--")) {
      t.style.setProperty(i, o);
      return;
    }
    a[i] = t.style[i], t.style[i] = o;
  }), !e && Jt.set(t, a);
}
function _e(t, n) {
  if (!t || !(t instanceof HTMLElement)) return;
  let e = Jt.get(t);
  e && (t.style[n] = e[n]);
}
const C = (t) => {
  switch (t) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return t;
  }
};
function yt(t, n) {
  if (!t)
    return null;
  const e = window.getComputedStyle(t), a = (
    // @ts-ignore
    e.transform || e.webkitTransform || e.mozTransform
  );
  let i = a.match(/^matrix3d\((.+)\)$/);
  return i ? parseFloat(i[1].split(", ")[C(n) ? 13 : 12]) : (i = a.match(/^matrix\((.+)\)$/), i ? parseFloat(i[1].split(", ")[C(n) ? 5 : 4]) : null);
}
function He(t) {
  return 8 * (Math.log(t + 1) - 2);
}
function Ct(t, n) {
  if (!t) return () => {
  };
  const e = t.style.cssText;
  return Object.assign(t.style, n), () => {
    t.style.cssText = e;
  };
}
function ke(...t) {
  return (...n) => {
    for (const e of t)
      typeof e == "function" && e(...n);
  };
}
const x = {
  DURATION: 0.5,
  EASE: [
    0.32,
    0.72,
    0,
    1
  ]
}, Qt = 0.4, Le = 0.25, Be = 100, Zt = 8, bt = 16, Mt = 26, $t = "vaul-dragging";
function te(t) {
  const n = r.useRef(t);
  return r.useEffect(() => {
    n.current = t;
  }), r.useMemo(() => (...e) => n.current == null ? void 0 : n.current.call(n, ...e), []);
}
function Fe({ defaultProp: t, onChange: n }) {
  const e = r.useState(t), [a] = e, i = r.useRef(a), o = te(n);
  return r.useEffect(() => {
    i.current !== a && (o(a), i.current = a);
  }, [
    a,
    i,
    o
  ]), e;
}
function ee({ prop: t, defaultProp: n, onChange: e = () => {
} }) {
  const [a, i] = Fe({
    defaultProp: n,
    onChange: e
  }), o = t !== void 0, v = o ? t : a, w = te(e), D = r.useCallback((R) => {
    if (o) {
      const f = typeof R == "function" ? R(t) : R;
      f !== t && w(f);
    } else
      i(R);
  }, [
    o,
    t,
    i,
    w
  ]);
  return [
    v,
    D
  ];
}
function Ue({ activeSnapPointProp: t, setActiveSnapPointProp: n, snapPoints: e, drawerRef: a, overlayRef: i, fadeFromIndex: o, onSnapPointChange: v, direction: w = "bottom", container: D, snapToSequentialPoint: R }) {
  const [h, f] = ee({
    prop: t,
    defaultProp: e == null ? void 0 : e[0],
    onChange: n
  }), [m, B] = r.useState(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  r.useEffect(() => {
    function u() {
      B({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }
    return window.addEventListener("resize", u), () => window.removeEventListener("resize", u);
  }, []);
  const k = r.useMemo(() => h === (e == null ? void 0 : e[e.length - 1]) || null, [
    e,
    h
  ]), E = r.useMemo(() => {
    var u;
    return (u = e == null ? void 0 : e.findIndex((b) => b === h)) != null ? u : null;
  }, [
    e,
    h
  ]), F = e && e.length > 0 && (o || o === 0) && !Number.isNaN(o) && e[o] === h || !e, p = r.useMemo(() => {
    const u = D ? {
      width: D.getBoundingClientRect().width,
      height: D.getBoundingClientRect().height
    } : typeof window < "u" ? {
      width: window.innerWidth,
      height: window.innerHeight
    } : {
      width: 0,
      height: 0
    };
    var b;
    return (b = e == null ? void 0 : e.map((y) => {
      const I = typeof y == "string";
      let N = 0;
      if (I && (N = parseInt(y, 10)), C(w)) {
        const l = I ? N : m ? y * u.height : 0;
        return m ? w === "bottom" ? u.height - l : -u.height + l : l;
      }
      const j = I ? N : m ? y * u.width : 0;
      return m ? w === "right" ? u.width - j : -u.width + j : j;
    })) != null ? b : [];
  }, [
    e,
    m,
    D
  ]), M = r.useMemo(() => E !== null ? p == null ? void 0 : p[E] : null, [
    p,
    E
  ]), A = r.useCallback((u) => {
    var b;
    const y = (b = p == null ? void 0 : p.findIndex((I) => I === u)) != null ? b : null;
    v(y), $(a.current, {
      transition: `transform ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      transform: C(w) ? `translate3d(0, ${u}px, 0)` : `translate3d(${u}px, 0, 0)`
    }), p && y !== p.length - 1 && o !== void 0 && y !== o && y < o ? $(i.current, {
      transition: `opacity ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      opacity: "0"
    }) : $(i.current, {
      transition: `opacity ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      opacity: "1"
    }), f(e == null ? void 0 : e[Math.max(y, 0)]);
  }, [
    a.current,
    e,
    p,
    o,
    i,
    f
  ]);
  r.useEffect(() => {
    if (h || t) {
      var u;
      const b = (u = e == null ? void 0 : e.findIndex((y) => y === t || y === h)) != null ? u : -1;
      p && b !== -1 && typeof p[b] == "number" && A(p[b]);
    }
  }, [
    h,
    t,
    e,
    p,
    A
  ]);
  function c({ draggedDistance: u, closeDrawer: b, velocity: y, dismissible: I }) {
    if (o === void 0) return;
    const N = w === "bottom" || w === "right" ? (M ?? 0) - u : (M ?? 0) + u, j = E === o - 1, l = E === 0, U = u > 0;
    if (j && $(i.current, {
      transition: `opacity ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`
    }), !R && y > 2 && !U) {
      I ? b() : A(p[0]);
      return;
    }
    if (!R && y > 2 && U && p && e) {
      A(p[e.length - 1]);
      return;
    }
    const _ = p == null ? void 0 : p.reduce((P, K) => typeof P != "number" || typeof K != "number" ? P : Math.abs(K - N) < Math.abs(P - N) ? K : P), W = C(w) ? window.innerHeight : window.innerWidth;
    if (y > Qt && Math.abs(u) < W * 0.4) {
      const P = U ? 1 : -1;
      if (P > 0 && k && e) {
        A(p[e.length - 1]);
        return;
      }
      if (l && P < 0 && I && b(), E === null) return;
      A(p[E + P]);
      return;
    }
    A(_);
  }
  function Y({ draggedDistance: u }) {
    if (M === null) return;
    const b = w === "bottom" || w === "right" ? M - u : M + u;
    (w === "bottom" || w === "right") && b < p[p.length - 1] || (w === "top" || w === "left") && b > p[p.length - 1] || $(a.current, {
      transform: C(w) ? `translate3d(0, ${b}px, 0)` : `translate3d(${b}px, 0, 0)`
    });
  }
  function tt(u, b) {
    if (!e || typeof E != "number" || !p || o === void 0) return null;
    const y = E === o - 1;
    if (E >= o && b)
      return 0;
    if (y && !b) return 1;
    if (!F && !y) return null;
    const N = y ? E + 1 : E - 1, j = y ? p[N] - p[N - 1] : p[N + 1] - p[N], l = u / Math.abs(j);
    return y ? 1 - l : l;
  }
  return {
    isLastSnapPoint: k,
    activeSnapPoint: h,
    shouldFade: F,
    getPercentageDragged: tt,
    setActiveSnapPoint: f,
    activeSnapPointIndex: E,
    onRelease: c,
    onDrag: Y,
    snapPointsOffset: p
  };
}
const je = () => () => {
};
function We() {
  const { direction: t, isOpen: n, shouldScaleBackground: e, setBackgroundColorOnScale: a, noBodyStyles: i } = pt(), o = r.useRef(null), v = ye(() => document.body.style.backgroundColor, []);
  function w() {
    return (window.innerWidth - Mt) / window.innerWidth;
  }
  r.useEffect(() => {
    if (n && e) {
      o.current && clearTimeout(o.current);
      const D = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!D) return;
      ke(a && !i ? Ct(document.body, {
        background: "black"
      }) : je, Ct(D, {
        transformOrigin: C(t) ? "top" : "left",
        transitionProperty: "transform, border-radius",
        transitionDuration: `${x.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${x.EASE.join(",")})`
      }));
      const R = Ct(D, {
        borderRadius: `${Zt}px`,
        overflow: "hidden",
        ...C(t) ? {
          transform: `scale(${w()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${w()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      return () => {
        R(), o.current = window.setTimeout(() => {
          v ? document.body.style.background = v : document.body.style.removeProperty("background");
        }, x.DURATION * 1e3);
      };
    }
  }, [
    n,
    e,
    v
  ]);
}
let ft = null;
function ze({ isOpen: t, modal: n, nested: e, hasBeenOpened: a, preventScrollRestoration: i, noBodyStyles: o }) {
  const [v, w] = r.useState(() => typeof window < "u" ? window.location.href : ""), D = r.useRef(0), R = r.useCallback(() => {
    if (Wt() && ft === null && t && !o) {
      ft = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height,
        right: "unset"
      };
      const { scrollX: f, innerHeight: m } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-D.current}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), window.setTimeout(() => window.requestAnimationFrame(() => {
        const B = m - window.innerHeight;
        B && D.current >= m && (document.body.style.top = `${-(D.current + B)}px`);
      }), 300);
    }
  }, [
    t
  ]), h = r.useCallback(() => {
    if (Wt() && ft !== null && !o) {
      const f = -parseInt(document.body.style.top, 10), m = -parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, ft), window.requestAnimationFrame(() => {
        if (i && v !== window.location.href) {
          w(window.location.href);
          return;
        }
        window.scrollTo(m, f);
      }), ft = null;
    }
  }, [
    v
  ]);
  return r.useEffect(() => {
    function f() {
      D.current = window.scrollY;
    }
    return f(), window.addEventListener("scroll", f), () => {
      window.removeEventListener("scroll", f);
    };
  }, []), r.useEffect(() => {
    if (n)
      return () => {
        typeof document > "u" || document.querySelector("[data-vaul-drawer]") || h();
      };
  }, [
    n,
    h
  ]), r.useEffect(() => {
    e || !a || (t ? (!window.matchMedia("(display-mode: standalone)").matches && R(), n || window.setTimeout(() => {
      h();
    }, 500)) : h());
  }, [
    t,
    a,
    v,
    n,
    e,
    R,
    h
  ]), {
    restorePositionSetting: h
  };
}
function Ve({ open: t, onOpenChange: n, children: e, onDrag: a, onRelease: i, snapPoints: o, shouldScaleBackground: v = !1, setBackgroundColorOnScale: w = !0, closeThreshold: D = Le, scrollLockTimeout: R = Be, dismissible: h = !0, handleOnly: f = !1, fadeFromIndex: m = o && o.length - 1, activeSnapPoint: B, setActiveSnapPoint: k, fixed: E, modal: F = !0, onClose: p, nested: M, noBodyStyles: A = !1, direction: c = "bottom", defaultOpen: Y = !1, disablePreventScroll: tt = !0, snapToSequentialPoint: u = !1, preventScrollRestoration: b = !1, repositionInputs: y = !0, onAnimationEnd: I, container: N, autoFocus: j = !1 }) {
  var l, U;
  const [_ = !1, W] = ee({
    defaultProp: Y,
    prop: t,
    onChange: (s) => {
      n == null || n(s), !s && !M && de(), setTimeout(() => {
        I == null || I(s);
      }, x.DURATION * 1e3), s && !F && typeof window < "u" && window.requestAnimationFrame(() => {
        document.body.style.pointerEvents = "auto";
      }), s || (document.body.style.pointerEvents = "auto");
    }
  }), [P, K] = r.useState(!1), [G, it] = r.useState(!1), [oe, Pt] = r.useState(!1), nt = r.useRef(null), wt = r.useRef(null), St = r.useRef(null), Dt = r.useRef(null), st = r.useRef(null), lt = r.useRef(!1), Tt = r.useRef(null), Rt = r.useRef(0), rt = r.useRef(!1), It = r.useRef(!Y), _t = r.useRef(0), d = r.useRef(null), Ht = r.useRef(((l = d.current) == null ? void 0 : l.getBoundingClientRect().height) || 0), kt = r.useRef(((U = d.current) == null ? void 0 : U.getBoundingClientRect().width) || 0), Et = r.useRef(0), ie = r.useCallback((s) => {
    o && s === ut.length - 1 && (wt.current = /* @__PURE__ */ new Date());
  }, []), { activeSnapPoint: se, activeSnapPointIndex: at, setActiveSnapPoint: Lt, onRelease: le, snapPointsOffset: ut, onDrag: ue, shouldFade: Bt, getPercentageDragged: ce } = Ue({
    snapPoints: o,
    activeSnapPointProp: B,
    setActiveSnapPointProp: k,
    drawerRef: d,
    fadeFromIndex: m,
    overlayRef: nt,
    onSnapPointChange: ie,
    direction: c,
    container: N,
    snapToSequentialPoint: u
  });
  Ae({
    isDisabled: !_ || G || !F || oe || !P || !y || !tt
  });
  const { restorePositionSetting: de } = ze({
    isOpen: _,
    modal: F,
    nested: M ?? !1,
    hasBeenOpened: P,
    preventScrollRestoration: b,
    noBodyStyles: A
  });
  function ht() {
    return (window.innerWidth - Mt) / window.innerWidth;
  }
  function fe(s) {
    var S, T;
    !h && !o || d.current && !d.current.contains(s.target) || (Ht.current = ((S = d.current) == null ? void 0 : S.getBoundingClientRect().height) || 0, kt.current = ((T = d.current) == null ? void 0 : T.getBoundingClientRect().width) || 0, it(!0), St.current = /* @__PURE__ */ new Date(), Xt() && window.addEventListener("touchend", () => lt.current = !1, {
      once: !0
    }), s.target.setPointerCapture(s.pointerId), Rt.current = C(c) ? s.pageY : s.pageX);
  }
  function Ft(s, S) {
    var T;
    let g = s;
    const O = (T = window.getSelection()) == null ? void 0 : T.toString(), L = d.current ? yt(d.current, c) : null, H = /* @__PURE__ */ new Date();
    if (g.tagName === "SELECT" || g.hasAttribute("data-vaul-no-drag") || g.closest("[data-vaul-no-drag]"))
      return !1;
    if (c === "right" || c === "left")
      return !0;
    if (wt.current && H.getTime() - wt.current.getTime() < 500)
      return !1;
    if (L !== null && (c === "bottom" ? L > 0 : L < 0))
      return !0;
    if (O && O.length > 0)
      return !1;
    if (st.current && H.getTime() - st.current.getTime() < R && L === 0 || S)
      return st.current = H, !1;
    for (; g; ) {
      if (g.scrollHeight > g.clientHeight) {
        if (g.scrollTop !== 0)
          return st.current = /* @__PURE__ */ new Date(), !1;
        if (g.getAttribute("role") === "dialog")
          return !0;
      }
      g = g.parentNode;
    }
    return !0;
  }
  function me(s) {
    if (d.current && G) {
      const S = c === "bottom" || c === "right" ? 1 : -1, T = (Rt.current - (C(c) ? s.pageY : s.pageX)) * S, g = T > 0, O = o && !h && !g;
      if (O && at === 0) return;
      const L = Math.abs(T), H = document.querySelector("[data-vaul-drawer-wrapper]"), J = c === "bottom" || c === "top" ? Ht.current : kt.current;
      let z = L / J;
      const et = ce(L, g);
      if (et !== null && (z = et), O && z >= 1 || !lt.current && !Ft(s.target, g)) return;
      if (d.current.classList.add($t), lt.current = !0, $(d.current, {
        transition: "none"
      }), $(nt.current, {
        transition: "none"
      }), o && ue({
        draggedDistance: T
      }), g && !o) {
        const q = He(T), gt = Math.min(q * -1, 0) * S;
        $(d.current, {
          transform: C(c) ? `translate3d(0, ${gt}px, 0)` : `translate3d(${gt}px, 0, 0)`
        });
        return;
      }
      const Q = 1 - z;
      if ((Bt || m && at === m - 1) && (a == null || a(s, z), $(nt.current, {
        opacity: `${Q}`,
        transition: "none"
      }, !0)), H && nt.current && v) {
        const q = Math.min(ht() + z * (1 - ht()), 1), gt = 8 - z * 8, jt = Math.max(0, 14 - z * 14);
        $(H, {
          borderRadius: `${gt}px`,
          transform: C(c) ? `scale(${q}) translate3d(0, ${jt}px, 0)` : `scale(${q}) translate3d(${jt}px, 0, 0)`,
          transition: "none"
        }, !0);
      }
      if (!o) {
        const q = L * S;
        $(d.current, {
          transform: C(c) ? `translate3d(0, ${q}px, 0)` : `translate3d(${q}px, 0, 0)`
        });
      }
    }
  }
  r.useEffect(() => {
    window.requestAnimationFrame(() => {
      It.current = !0;
    });
  }, []), r.useEffect(() => {
    var s;
    function S() {
      if (!d.current || !y) return;
      const T = document.activeElement;
      if (At(T) || rt.current) {
        var g;
        const O = ((g = window.visualViewport) == null ? void 0 : g.height) || 0, L = window.innerHeight;
        let H = L - O;
        const J = d.current.getBoundingClientRect().height || 0, z = J > L * 0.8;
        Et.current || (Et.current = J);
        const et = d.current.getBoundingClientRect().top;
        if (Math.abs(_t.current - H) > 60 && (rt.current = !rt.current), o && o.length > 0 && ut && at) {
          const Q = ut[at] || 0;
          H += Q;
        }
        if (_t.current = H, J > O || rt.current) {
          const Q = d.current.getBoundingClientRect().height;
          let q = Q;
          Q > O && (q = O - (z ? et : Mt)), E ? d.current.style.height = `${Q - Math.max(H, 0)}px` : d.current.style.height = `${Math.max(q, O - et)}px`;
        } else Te() || (d.current.style.height = `${Et.current}px`);
        o && o.length > 0 && !rt.current ? d.current.style.bottom = "0px" : d.current.style.bottom = `${Math.max(H, 0)}px`;
      }
    }
    return (s = window.visualViewport) == null || s.addEventListener("resize", S), () => {
      var T;
      return (T = window.visualViewport) == null ? void 0 : T.removeEventListener("resize", S);
    };
  }, [
    at,
    o,
    ut
  ]);
  function ct(s) {
    pe(), p == null || p(), s || W(!1), setTimeout(() => {
      o && Lt(o[0]);
    }, x.DURATION * 1e3);
  }
  function Ut() {
    if (!d.current) return;
    const s = document.querySelector("[data-vaul-drawer-wrapper]"), S = yt(d.current, c);
    $(d.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`
    }), $(nt.current, {
      transition: `opacity ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      opacity: "1"
    }), v && S && S > 0 && _ && $(s, {
      borderRadius: `${Zt}px`,
      overflow: "hidden",
      ...C(c) ? {
        transform: `scale(${ht()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
        transformOrigin: "top"
      } : {
        transform: `scale(${ht()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
        transformOrigin: "left"
      },
      transitionProperty: "transform, border-radius",
      transitionDuration: `${x.DURATION}s`,
      transitionTimingFunction: `cubic-bezier(${x.EASE.join(",")})`
    }, !0);
  }
  function pe() {
    !G || !d.current || (d.current.classList.remove($t), lt.current = !1, it(!1), Dt.current = /* @__PURE__ */ new Date());
  }
  function we(s) {
    if (!G || !d.current) return;
    d.current.classList.remove($t), lt.current = !1, it(!1), Dt.current = /* @__PURE__ */ new Date();
    const S = yt(d.current, c);
    if (!s || !Ft(s.target, !1) || !S || Number.isNaN(S) || St.current === null) return;
    const T = Dt.current.getTime() - St.current.getTime(), g = Rt.current - (C(c) ? s.pageY : s.pageX), O = Math.abs(g) / T;
    if (O > 0.05 && (Pt(!0), setTimeout(() => {
      Pt(!1);
    }, 200)), o) {
      le({
        draggedDistance: g * (c === "bottom" || c === "right" ? 1 : -1),
        closeDrawer: ct,
        velocity: O,
        dismissible: h
      }), i == null || i(s, !0);
      return;
    }
    if (c === "bottom" || c === "right" ? g > 0 : g < 0) {
      Ut(), i == null || i(s, !0);
      return;
    }
    if (O > Qt) {
      ct(), i == null || i(s, !1);
      return;
    }
    var L;
    const H = Math.min((L = d.current.getBoundingClientRect().height) != null ? L : 0, window.innerHeight);
    var J;
    const z = Math.min((J = d.current.getBoundingClientRect().width) != null ? J : 0, window.innerWidth), et = c === "left" || c === "right";
    if (Math.abs(S) >= (et ? z : H) * D) {
      ct(), i == null || i(s, !1);
      return;
    }
    i == null || i(s, !0), Ut();
  }
  r.useEffect(() => (_ && ($(document.documentElement, {
    scrollBehavior: "auto"
  }), wt.current = /* @__PURE__ */ new Date()), () => {
    _e(document.documentElement, "scrollBehavior");
  }), [
    _
  ]);
  function he(s) {
    const S = s ? (window.innerWidth - bt) / window.innerWidth : 1, T = s ? -16 : 0;
    Tt.current && window.clearTimeout(Tt.current), $(d.current, {
      transition: `transform ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      transform: C(c) ? `scale(${S}) translate3d(0, ${T}px, 0)` : `scale(${S}) translate3d(${T}px, 0, 0)`
    }), !s && d.current && (Tt.current = setTimeout(() => {
      const g = yt(d.current, c);
      $(d.current, {
        transition: "none",
        transform: C(c) ? `translate3d(0, ${g}px, 0)` : `translate3d(${g}px, 0, 0)`
      });
    }, 500));
  }
  function ge(s, S) {
    if (S < 0) return;
    const T = (window.innerWidth - bt) / window.innerWidth, g = T + S * (1 - T), O = -16 + S * bt;
    $(d.current, {
      transform: C(c) ? `scale(${g}) translate3d(0, ${O}px, 0)` : `scale(${g}) translate3d(${O}px, 0, 0)`,
      transition: "none"
    });
  }
  function ve(s, S) {
    const T = C(c) ? window.innerHeight : window.innerWidth, g = S ? (T - bt) / T : 1, O = S ? -16 : 0;
    S && $(d.current, {
      transition: `transform ${x.DURATION}s cubic-bezier(${x.EASE.join(",")})`,
      transform: C(c) ? `scale(${g}) translate3d(0, ${O}px, 0)` : `scale(${g}) translate3d(${O}px, 0, 0)`
    });
  }
  return r.useEffect(() => {
    F || window.requestAnimationFrame(() => {
      document.body.style.pointerEvents = "auto";
    });
  }, [
    F
  ]), /* @__PURE__ */ r.createElement(Z.Root, {
    defaultOpen: Y,
    onOpenChange: (s) => {
      !h && !s || (s ? K(!0) : ct(!0), W(s));
    },
    open: _
  }, /* @__PURE__ */ r.createElement(qt.Provider, {
    value: {
      activeSnapPoint: se,
      snapPoints: o,
      setActiveSnapPoint: Lt,
      drawerRef: d,
      overlayRef: nt,
      onOpenChange: n,
      onPress: fe,
      onRelease: we,
      onDrag: me,
      dismissible: h,
      shouldAnimate: It,
      handleOnly: f,
      isOpen: _,
      isDragging: G,
      shouldFade: Bt,
      closeDrawer: ct,
      onNestedDrag: ge,
      onNestedOpenChange: he,
      onNestedRelease: ve,
      keyboardIsOpen: rt,
      modal: F,
      snapPointsOffset: ut,
      activeSnapPointIndex: at,
      direction: c,
      shouldScaleBackground: v,
      setBackgroundColorOnScale: w,
      noBodyStyles: A,
      container: N,
      autoFocus: j
    }
  }, e));
}
const ne = /* @__PURE__ */ r.forwardRef(function({ ...t }, n) {
  const { overlayRef: e, snapPoints: a, onRelease: i, shouldFade: o, isOpen: v, modal: w, shouldAnimate: D } = pt(), R = Gt(n, e), h = a && a.length > 0;
  if (!w)
    return null;
  const f = r.useCallback((m) => i(m), [
    i
  ]);
  return /* @__PURE__ */ r.createElement(Z.Overlay, {
    onMouseUp: f,
    ref: R,
    "data-vaul-overlay": "",
    "data-vaul-snap-points": v && h ? "true" : "false",
    "data-vaul-snap-points-overlay": v && o ? "true" : "false",
    "data-vaul-animate": D != null && D.current ? "true" : "false",
    ...t
  });
});
ne.displayName = "Drawer.Overlay";
const re = /* @__PURE__ */ r.forwardRef(function({ onPointerDownOutside: t, style: n, onOpenAutoFocus: e, ...a }, i) {
  const { drawerRef: o, onPress: v, onRelease: w, onDrag: D, keyboardIsOpen: R, snapPointsOffset: h, activeSnapPointIndex: f, modal: m, isOpen: B, direction: k, snapPoints: E, container: F, handleOnly: p, shouldAnimate: M, autoFocus: A } = pt(), [c, Y] = r.useState(!1), tt = Gt(i, o), u = r.useRef(null), b = r.useRef(null), y = r.useRef(!1), I = E && E.length > 0;
  We();
  const N = (l, U, _ = 0) => {
    if (y.current) return !0;
    const W = Math.abs(l.y), P = Math.abs(l.x), K = P > W, G = [
      "bottom",
      "right"
    ].includes(U) ? 1 : -1;
    if (U === "left" || U === "right") {
      if (!(l.x * G < 0) && P >= 0 && P <= _)
        return K;
    } else if (!(l.y * G < 0) && W >= 0 && W <= _)
      return !K;
    return y.current = !0, !0;
  };
  r.useEffect(() => {
    I && window.requestAnimationFrame(() => {
      Y(!0);
    });
  }, []);
  function j(l) {
    u.current = null, y.current = !1, w(l);
  }
  return /* @__PURE__ */ r.createElement(Z.Content, {
    "data-vaul-drawer-direction": k,
    "data-vaul-drawer": "",
    "data-vaul-delayed-snap-points": c ? "true" : "false",
    "data-vaul-snap-points": B && I ? "true" : "false",
    "data-vaul-custom-container": F ? "true" : "false",
    "data-vaul-animate": M != null && M.current ? "true" : "false",
    ...a,
    ref: tt,
    style: h && h.length > 0 ? {
      "--snap-point-height": `${h[f ?? 0]}px`,
      ...n
    } : n,
    onPointerDown: (l) => {
      p || (a.onPointerDown == null || a.onPointerDown.call(a, l), u.current = {
        x: l.pageX,
        y: l.pageY
      }, v(l));
    },
    onOpenAutoFocus: (l) => {
      e == null || e(l), A || l.preventDefault();
    },
    onPointerDownOutside: (l) => {
      if (t == null || t(l), !m || l.defaultPrevented) {
        l.preventDefault();
        return;
      }
      R.current && (R.current = !1);
    },
    onFocusOutside: (l) => {
      if (!m) {
        l.preventDefault();
        return;
      }
    },
    onPointerMove: (l) => {
      if (b.current = l, p || (a.onPointerMove == null || a.onPointerMove.call(a, l), !u.current)) return;
      const U = l.pageY - u.current.y, _ = l.pageX - u.current.x, W = l.pointerType === "touch" ? 10 : 2;
      N({
        x: _,
        y: U
      }, k, W) ? D(l) : (Math.abs(_) > W || Math.abs(U) > W) && (u.current = null);
    },
    onPointerUp: (l) => {
      a.onPointerUp == null || a.onPointerUp.call(a, l), u.current = null, y.current = !1, w(l);
    },
    onPointerOut: (l) => {
      a.onPointerOut == null || a.onPointerOut.call(a, l), j(b.current);
    },
    onContextMenu: (l) => {
      a.onContextMenu == null || a.onContextMenu.call(a, l), b.current && j(b.current);
    }
  });
});
re.displayName = "Drawer.Content";
const Ye = 250, qe = 120, Xe = /* @__PURE__ */ r.forwardRef(function({ preventCycle: t = !1, children: n, ...e }, a) {
  const { closeDrawer: i, isDragging: o, snapPoints: v, activeSnapPoint: w, setActiveSnapPoint: D, dismissible: R, handleOnly: h, isOpen: f, onPress: m, onDrag: B } = pt(), k = r.useRef(null), E = r.useRef(!1);
  function F() {
    if (E.current) {
      A();
      return;
    }
    window.setTimeout(() => {
      p();
    }, qe);
  }
  function p() {
    if (o || t || E.current) {
      A();
      return;
    }
    if (A(), !v || v.length === 0) {
      R || i();
      return;
    }
    if (w === v[v.length - 1] && R) {
      i();
      return;
    }
    const Y = v.findIndex((u) => u === w);
    if (Y === -1) return;
    const tt = v[Y + 1];
    D(tt);
  }
  function M() {
    k.current = window.setTimeout(() => {
      E.current = !0;
    }, Ye);
  }
  function A() {
    k.current && window.clearTimeout(k.current), E.current = !1;
  }
  return /* @__PURE__ */ r.createElement("div", {
    onClick: F,
    onPointerCancel: A,
    onPointerDown: (c) => {
      h && m(c), M();
    },
    onPointerMove: (c) => {
      h && B(c);
    },
    // onPointerUp is already handled by the content component
    ref: a,
    "data-vaul-drawer-visible": f ? "true" : "false",
    "data-vaul-handle": "",
    "aria-hidden": "true",
    ...e
  }, /* @__PURE__ */ r.createElement("span", {
    "data-vaul-handle-hitarea": "",
    "aria-hidden": "true"
  }, n));
});
Xe.displayName = "Drawer.Handle";
function Ke(t) {
  const n = pt(), { container: e = n.container, ...a } = t;
  return /* @__PURE__ */ r.createElement(Z.Portal, {
    container: e,
    ...a
  });
}
const V = {
  Root: Ve,
  Content: re,
  Overlay: ne,
  Trigger: Z.Trigger,
  Portal: Ke,
  Close: Z.Close,
  Title: Z.Title,
  Description: Z.Description
}, Ge = ({
  shouldScaleBackground: t = !0,
  ...n
}) => /* @__PURE__ */ X.jsx(
  V.Root,
  {
    shouldScaleBackground: t,
    ...n
  }
);
Ge.displayName = "Drawer";
const sn = V.Trigger, Je = V.Portal, ln = V.Close, ae = mt.forwardRef(({ className: t, ...n }, e) => /* @__PURE__ */ X.jsx(
  V.Overlay,
  {
    ref: e,
    className: ot("fixed inset-0 z-50 bg-black/80", t),
    ...n
  }
));
ae.displayName = V.Overlay.displayName;
const Qe = mt.forwardRef(
  ({ className: t, children: n, hideBar: e = !0, ...a }, i) => /* @__PURE__ */ X.jsxs(Je, { children: [
    /* @__PURE__ */ X.jsx(ae, {}),
    /* @__PURE__ */ X.jsxs(
      V.Content,
      {
        ref: i,
        className: ot(
          "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
          t
        ),
        ...a,
        children: [
          !e && /* @__PURE__ */ X.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          n
        ]
      }
    )
  ] })
);
Qe.displayName = "DrawerContent";
const Ze = ({
  className: t,
  ...n
}) => /* @__PURE__ */ X.jsx(
  "div",
  {
    className: ot("grid gap-1.5 p-4 text-center sm:text-left", t),
    ...n
  }
);
Ze.displayName = "DrawerHeader";
const tn = ({
  className: t,
  ...n
}) => /* @__PURE__ */ X.jsx(
  "div",
  {
    className: ot("mt-auto flex flex-col gap-2 p-4", t),
    ...n
  }
);
tn.displayName = "DrawerFooter";
const en = mt.forwardRef(({ className: t, ...n }, e) => /* @__PURE__ */ X.jsx(
  V.Title,
  {
    ref: e,
    className: ot(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...n
  }
));
en.displayName = V.Title.displayName;
const nn = mt.forwardRef(({ className: t, ...n }, e) => /* @__PURE__ */ X.jsx(
  V.Description,
  {
    ref: e,
    className: ot("text-sm text-muted-foreground", t),
    ...n
  }
));
nn.displayName = V.Description.displayName;
export {
  Ge as D,
  sn as a,
  Qe as b,
  en as c,
  V as d,
  ln as e,
  nn as f,
  tn as g,
  Ze as h,
  ae as i,
  Je as j
};
//# sourceMappingURL=Drawer-CEwbkLDb.js.map
