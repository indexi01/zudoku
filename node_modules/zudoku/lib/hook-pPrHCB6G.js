var $e = (t) => {
  throw TypeError(t);
};
var be = (t, e, s) => e.has(t) || $e("Cannot " + s);
var n = (t, e, s) => (be(t, e, "read from private field"), s ? s.call(t) : e.get(t)), b = (t, e, s) => e.has(t) ? $e("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, s), f = (t, e, s, r) => (be(t, e, "write to private field"), r ? r.call(t, s) : e.set(t, s), s), w = (t, e, s) => (be(t, e, "access private method"), s);
import * as j from "react";
import Ge, { createContext as Et, useContext as Ct } from "react";
import { j as Ot } from "./jsx-runtime-C5mzlN2N.js";
import { u as me, m as ze } from "./chunk-KNED5TY2-BUPjb3LQ.js";
var Qe = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, J = typeof window > "u" || "Deno" in globalThis;
function Se() {
}
function gs(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function we(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function ot(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function pe(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function k(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Ss(t, e) {
  const {
    type: s = "all",
    exact: r,
    fetchStatus: i,
    predicate: a,
    queryKey: o,
    stale: u
  } = t;
  if (o) {
    if (r) {
      if (e.queryHash !== Ft(o, e.options))
        return !1;
    } else if (!Ne(e.queryKey, o))
      return !1;
  }
  if (s !== "all") {
    const l = e.isActive();
    if (s === "active" && !l || s === "inactive" && l)
      return !1;
  }
  return !(typeof u == "boolean" && e.isStale() !== u || i && i !== e.state.fetchStatus || a && !a(e));
}
function ws(t, e) {
  const { exact: s, status: r, predicate: i, mutationKey: a } = t;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (s) {
      if (Re(e.options.mutationKey) !== Re(a))
        return !1;
    } else if (!Ne(e.options.mutationKey, a))
      return !1;
  }
  return !(r && e.state.status !== r || i && !i(e));
}
function Ft(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Re)(t);
}
function Re(t) {
  return JSON.stringify(
    t,
    (e, s) => Oe(s) ? Object.keys(s).sort().reduce((r, i) => (r[i] = s[i], r), {}) : s
  );
}
function Ne(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((s) => Ne(t[s], e[s])) : !1;
}
function Ee(t, e) {
  if (t === e)
    return t;
  const s = Ve(t) && Ve(e);
  if (s || Oe(t) && Oe(e)) {
    const r = s ? t : Object.keys(t), i = r.length, a = s ? e : Object.keys(e), o = a.length, u = s ? [] : {};
    let l = 0;
    for (let y = 0; y < o; y++) {
      const g = s ? y : a[y];
      (!s && r.includes(g) || s) && t[g] === void 0 && e[g] === void 0 ? (u[g] = void 0, l++) : (u[g] = Ee(t[g], e[g]), u[g] === t[g] && t[g] !== void 0 && l++);
    }
    return i === o && l === i ? t : u;
  }
  return e;
}
function Ce(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const s in t)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
function Ve(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Oe(t) {
  if (!Je(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const s = e.prototype;
  return !(!Je(s) || !s.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Je(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function It(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function Fe(t, e, s) {
  if (typeof s.structuralSharing == "function")
    return s.structuralSharing(t, e);
  if (s.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Ee(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s.queryHash}]: ${r}`
        ), r;
      }
    return Ee(t, e);
  }
  return e;
}
function Rs(t) {
  return t;
}
function Es(t, e, s = 0) {
  const r = [...t, e];
  return s && r.length > s ? r.slice(1) : r;
}
function Cs(t, e, s = 0) {
  const r = [e, ...t];
  return s && r.length > s ? r.slice(0, -1) : r;
}
var ve = Symbol();
function Pt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === ve && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === ve ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
var H, Q, Y, st, Tt = (st = class extends Qe {
  constructor() {
    super();
    b(this, H);
    b(this, Q);
    b(this, Y);
    f(this, Y, (e) => {
      if (!J && window.addEventListener) {
        const s = () => e();
        return window.addEventListener("visibilitychange", s, !1), () => {
          window.removeEventListener("visibilitychange", s);
        };
      }
    });
  }
  onSubscribe() {
    n(this, Q) || this.setEventListener(n(this, Y));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = n(this, Q)) == null || e.call(this), f(this, Q, void 0));
  }
  setEventListener(e) {
    var s;
    f(this, Y, e), (s = n(this, Q)) == null || s.call(this), f(this, Q, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    n(this, H) !== e && (f(this, H, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((s) => {
      s(e);
    });
  }
  isFocused() {
    var e;
    return typeof n(this, H) == "boolean" ? n(this, H) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, H = new WeakMap(), Q = new WeakMap(), Y = new WeakMap(), st), ut = new Tt(), X, N, ee, rt, Dt = (rt = class extends Qe {
  constructor() {
    super();
    b(this, X, !0);
    b(this, N);
    b(this, ee);
    f(this, ee, (e) => {
      if (!J && window.addEventListener) {
        const s = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", s, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", s), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    n(this, N) || this.setEventListener(n(this, ee));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = n(this, N)) == null || e.call(this), f(this, N, void 0));
  }
  setEventListener(e) {
    var s;
    f(this, ee, e), (s = n(this, N)) == null || s.call(this), f(this, N, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    n(this, X) !== e && (f(this, X, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return n(this, X);
  }
}, X = new WeakMap(), N = new WeakMap(), ee = new WeakMap(), rt), ct = new Dt();
function Ie() {
  let t, e;
  const s = new Promise((i, a) => {
    t = i, e = a;
  });
  s.status = "pending", s.catch(() => {
  });
  function r(i) {
    Object.assign(s, i), delete s.resolve, delete s.reject;
  }
  return s.resolve = (i) => {
    r({
      status: "fulfilled",
      value: i
    }), t(i);
  }, s.reject = (i) => {
    r({
      status: "rejected",
      reason: i
    }), e(i);
  }, s;
}
function jt(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function ht(t) {
  return (t ?? "online") === "online" ? ct.isOnline() : !0;
}
var lt = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function ge(t) {
  return t instanceof lt;
}
function At(t) {
  let e = !1, s = 0, r = !1, i;
  const a = Ie(), o = (h) => {
    var v;
    r || (p(new lt(h)), (v = t.abort) == null || v.call(t));
  }, u = () => {
    e = !0;
  }, l = () => {
    e = !1;
  }, y = () => ut.isFocused() && (t.networkMode === "always" || ct.isOnline()) && t.canRun(), g = () => ht(t.networkMode) && t.canRun(), c = (h) => {
    var v;
    r || (r = !0, (v = t.onSuccess) == null || v.call(t, h), i == null || i(), a.resolve(h));
  }, p = (h) => {
    var v;
    r || (r = !0, (v = t.onError) == null || v.call(t, h), i == null || i(), a.reject(h));
  }, d = () => new Promise((h) => {
    var v;
    i = (C) => {
      (r || y()) && h(C);
    }, (v = t.onPause) == null || v.call(t);
  }).then(() => {
    var h;
    i = void 0, r || (h = t.onContinue) == null || h.call(t);
  }), E = () => {
    if (r)
      return;
    let h;
    const v = s === 0 ? t.initialPromise : void 0;
    try {
      h = v ?? t.fn();
    } catch (C) {
      h = Promise.reject(C);
    }
    Promise.resolve(h).then(c).catch((C) => {
      var oe;
      if (r)
        return;
      const R = t.retry ?? (J ? 0 : 3), O = t.retryDelay ?? jt, q = typeof O == "function" ? O(s, C) : O, Z = R === !0 || typeof R == "number" && s < R || typeof R == "function" && R(s, C);
      if (e || !Z) {
        p(C);
        return;
      }
      s++, (oe = t.onFail) == null || oe.call(t, s, C), It(q).then(() => y() ? void 0 : d()).then(() => {
        e ? p(C) : E();
      });
    });
  };
  return {
    promise: a,
    cancel: o,
    continue: () => (i == null || i(), a),
    cancelRetry: u,
    continueRetry: l,
    canStart: g,
    start: () => (g() ? E() : d().then(E), a)
  };
}
var kt = (t) => setTimeout(t, 0);
function xt() {
  let t = [], e = 0, s = (u) => {
    u();
  }, r = (u) => {
    u();
  }, i = kt;
  const a = (u) => {
    e ? t.push(u) : i(() => {
      s(u);
    });
  }, o = () => {
    const u = t;
    t = [], u.length && i(() => {
      r(() => {
        u.forEach((l) => {
          s(l);
        });
      });
    });
  };
  return {
    batch: (u) => {
      let l;
      e++;
      try {
        l = u();
      } finally {
        e--, e || o();
      }
      return l;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (u) => (...l) => {
      a(() => {
        u(...l);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (u) => {
      s = u;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (u) => {
      r = u;
    },
    setScheduler: (u) => {
      i = u;
    }
  };
}
var Le = xt(), K, nt, qt = (nt = class {
  constructor() {
    b(this, K);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), we(this.gcTime) && f(this, K, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (J ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    n(this, K) && (clearTimeout(n(this, K)), f(this, K, void 0));
  }
}, K = new WeakMap(), nt), te, se, D, B, F, he, $, A, U, it, Os = (it = class extends qt {
  constructor(e) {
    super();
    b(this, A);
    b(this, te);
    b(this, se);
    b(this, D);
    b(this, B);
    b(this, F);
    b(this, he);
    b(this, $);
    f(this, $, !1), f(this, he, e.defaultOptions), this.setOptions(e.options), this.observers = [], f(this, B, e.client), f(this, D, n(this, B).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, f(this, te, Ut(this.options)), this.state = e.state ?? n(this, te), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = n(this, F)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...n(this, he), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && n(this, D).remove(this);
  }
  setData(e, s) {
    const r = Fe(this.state.data, e, this.options);
    return w(this, A, U).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: s == null ? void 0 : s.updatedAt,
      manual: s == null ? void 0 : s.manual
    }), r;
  }
  setState(e, s) {
    w(this, A, U).call(this, { type: "setState", state: e, setStateOptions: s });
  }
  cancel(e) {
    var r, i;
    const s = (r = n(this, F)) == null ? void 0 : r.promise;
    return (i = n(this, F)) == null || i.cancel(e), s ? s.then(Se).catch(Se) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(n(this, te));
  }
  isActive() {
    return this.observers.some(
      (e) => k(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ve || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(e = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !ot(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var s;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (s = n(this, F)) == null || s.continue();
  }
  onOnline() {
    var s;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (s = n(this, F)) == null || s.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), n(this, D).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((s) => s !== e), this.observers.length || (n(this, F) && (n(this, $) ? n(this, F).cancel({ revert: !0 }) : n(this, F).cancelRetry()), this.scheduleGc()), n(this, D).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || w(this, A, U).call(this, { type: "invalidate" });
  }
  fetch(e, s) {
    var l, y, g;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (s != null && s.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (n(this, F))
        return n(this, F).continueRetry(), n(this, F).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const c = this.observers.find((p) => p.options.queryFn);
      c && this.setOptions(c.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), i = (c) => {
      Object.defineProperty(c, "signal", {
        enumerable: !0,
        get: () => (f(this, $, !0), r.signal)
      });
    }, a = () => {
      const c = Pt(this.options, s), p = {
        client: n(this, B),
        queryKey: this.queryKey,
        meta: this.meta
      };
      return i(p), f(this, $, !1), this.options.persister ? this.options.persister(
        c,
        p,
        this
      ) : c(p);
    }, o = {
      fetchOptions: s,
      options: this.options,
      queryKey: this.queryKey,
      client: n(this, B),
      state: this.state,
      fetchFn: a
    };
    i(o), (l = this.options.behavior) == null || l.onFetch(
      o,
      this
    ), f(this, se, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((y = o.fetchOptions) == null ? void 0 : y.meta)) && w(this, A, U).call(this, { type: "fetch", meta: (g = o.fetchOptions) == null ? void 0 : g.meta });
    const u = (c) => {
      var p, d, E, h;
      ge(c) && c.silent || w(this, A, U).call(this, {
        type: "error",
        error: c
      }), ge(c) || ((d = (p = n(this, D).config).onError) == null || d.call(
        p,
        c,
        this
      ), (h = (E = n(this, D).config).onSettled) == null || h.call(
        E,
        this.state.data,
        c,
        this
      )), this.scheduleGc();
    };
    return f(this, F, At({
      initialPromise: s == null ? void 0 : s.initialPromise,
      fn: o.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (c) => {
        var p, d, E, h;
        if (c === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), u(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(c);
        } catch (v) {
          u(v);
          return;
        }
        (d = (p = n(this, D).config).onSuccess) == null || d.call(p, c, this), (h = (E = n(this, D).config).onSettled) == null || h.call(
          E,
          c,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: u,
      onFail: (c, p) => {
        w(this, A, U).call(this, { type: "failed", failureCount: c, error: p });
      },
      onPause: () => {
        w(this, A, U).call(this, { type: "pause" });
      },
      onContinue: () => {
        w(this, A, U).call(this, { type: "continue" });
      },
      retry: o.options.retry,
      retryDelay: o.options.retryDelay,
      networkMode: o.options.networkMode,
      canRun: () => !0
    })), n(this, F).start();
  }
}, te = new WeakMap(), se = new WeakMap(), D = new WeakMap(), B = new WeakMap(), F = new WeakMap(), he = new WeakMap(), $ = new WeakMap(), A = new WeakSet(), U = function(e) {
  const s = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...dt(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const i = e.error;
        return ge(i) && i.revert && n(this, se) ? { ...n(this, se), fetchStatus: "idle" } : {
          ...r,
          error: i,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: i,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = s(this.state), Le.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), n(this, D).notify({ query: this, type: "updated", action: e });
  });
}, it);
function dt(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: ht(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Ut(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, s = e !== void 0, r = s ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: s ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: s ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var P, m, le, I, G, re, L, M, de, ne, ie, z, V, _, ae, S, ue, Pe, Te, De, je, Ae, ke, xe, yt, at, ft = (at = class extends Qe {
  constructor(e, s) {
    super();
    b(this, S);
    b(this, P);
    b(this, m);
    b(this, le);
    b(this, I);
    b(this, G);
    b(this, re);
    b(this, L);
    b(this, M);
    b(this, de);
    b(this, ne);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    b(this, ie);
    b(this, z);
    b(this, V);
    b(this, _);
    b(this, ae, /* @__PURE__ */ new Set());
    this.options = s, f(this, P, e), f(this, M, null), f(this, L, Ie()), this.options.experimental_prefetchInRender || n(this, L).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(s);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (n(this, m).addObserver(this), Ze(n(this, m), this.options) ? w(this, S, ue).call(this) : this.updateResult(), w(this, S, je).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return qe(
      n(this, m),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return qe(
      n(this, m),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), w(this, S, Ae).call(this), w(this, S, ke).call(this), n(this, m).removeObserver(this);
  }
  setOptions(e) {
    const s = this.options, r = n(this, m);
    if (this.options = n(this, P).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof k(this.options.enabled, n(this, m)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    w(this, S, xe).call(this), n(this, m).setOptions(this.options), s._defaulted && !Ce(this.options, s) && n(this, P).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: n(this, m),
      observer: this
    });
    const i = this.hasListeners();
    i && We(
      n(this, m),
      r,
      this.options,
      s
    ) && w(this, S, ue).call(this), this.updateResult(), i && (n(this, m) !== r || k(this.options.enabled, n(this, m)) !== k(s.enabled, n(this, m)) || pe(this.options.staleTime, n(this, m)) !== pe(s.staleTime, n(this, m))) && w(this, S, Pe).call(this);
    const a = w(this, S, Te).call(this);
    i && (n(this, m) !== r || k(this.options.enabled, n(this, m)) !== k(s.enabled, n(this, m)) || a !== n(this, _)) && w(this, S, De).call(this, a);
  }
  getOptimisticResult(e) {
    const s = n(this, P).getQueryCache().build(n(this, P), e), r = this.createResult(s, e);
    return Nt(this, r) && (f(this, I, r), f(this, re, this.options), f(this, G, n(this, m).state)), r;
  }
  getCurrentResult() {
    return n(this, I);
  }
  trackResult(e, s) {
    const r = {};
    return Object.keys(e).forEach((i) => {
      Object.defineProperty(r, i, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(i), s == null || s(i), e[i])
      });
    }), r;
  }
  trackProp(e) {
    n(this, ae).add(e);
  }
  getCurrentQuery() {
    return n(this, m);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const s = n(this, P).defaultQueryOptions(e), r = n(this, P).getQueryCache().build(n(this, P), s);
    return r.fetch().then(() => this.createResult(r, s));
  }
  fetch(e) {
    return w(this, S, ue).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), n(this, I)));
  }
  createResult(e, s) {
    var Be;
    const r = n(this, m), i = this.options, a = n(this, I), o = n(this, G), u = n(this, re), y = e !== r ? e.state : n(this, le), { state: g } = e;
    let c = { ...g }, p = !1, d;
    if (s._optimisticResults) {
      const T = this.hasListeners(), fe = !T && Ze(e, s), W = T && We(e, r, s, i);
      (fe || W) && (c = {
        ...c,
        ...dt(g.data, e.options)
      }), s._optimisticResults === "isRestoring" && (c.fetchStatus = "idle");
    }
    let { error: E, errorUpdatedAt: h, status: v } = c;
    d = c.data;
    let C = !1;
    if (s.placeholderData !== void 0 && d === void 0 && v === "pending") {
      let T;
      a != null && a.isPlaceholderData && s.placeholderData === (u == null ? void 0 : u.placeholderData) ? (T = a.data, C = !0) : T = typeof s.placeholderData == "function" ? s.placeholderData(
        (Be = n(this, ie)) == null ? void 0 : Be.state.data,
        n(this, ie)
      ) : s.placeholderData, T !== void 0 && (v = "success", d = Fe(
        a == null ? void 0 : a.data,
        T,
        s
      ), p = !0);
    }
    if (s.select && d !== void 0 && !C)
      if (a && d === (o == null ? void 0 : o.data) && s.select === n(this, de))
        d = n(this, ne);
      else
        try {
          f(this, de, s.select), d = s.select(d), d = Fe(a == null ? void 0 : a.data, d, s), f(this, ne, d), f(this, M, null);
        } catch (T) {
          f(this, M, T);
        }
    n(this, M) && (E = n(this, M), d = n(this, ne), h = Date.now(), v = "error");
    const R = c.fetchStatus === "fetching", O = v === "pending", q = v === "error", Z = O && R, oe = d !== void 0, x = {
      status: v,
      fetchStatus: c.fetchStatus,
      isPending: O,
      isSuccess: v === "success",
      isError: q,
      isInitialLoading: Z,
      isLoading: Z,
      data: d,
      dataUpdatedAt: c.dataUpdatedAt,
      error: E,
      errorUpdatedAt: h,
      failureCount: c.fetchFailureCount,
      failureReason: c.fetchFailureReason,
      errorUpdateCount: c.errorUpdateCount,
      isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
      isFetchedAfterMount: c.dataUpdateCount > y.dataUpdateCount || c.errorUpdateCount > y.errorUpdateCount,
      isFetching: R,
      isRefetching: R && !O,
      isLoadingError: q && !oe,
      isPaused: c.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: q && oe,
      isStale: Me(e, s),
      refetch: this.refetch,
      promise: n(this, L)
    };
    if (this.options.experimental_prefetchInRender) {
      const T = (ye) => {
        x.status === "error" ? ye.reject(x.error) : x.data !== void 0 && ye.resolve(x.data);
      }, fe = () => {
        const ye = f(this, L, x.promise = Ie());
        T(ye);
      }, W = n(this, L);
      switch (W.status) {
        case "pending":
          e.queryHash === r.queryHash && T(W);
          break;
        case "fulfilled":
          (x.status === "error" || x.data !== W.value) && fe();
          break;
        case "rejected":
          (x.status !== "error" || x.error !== W.reason) && fe();
          break;
      }
    }
    return x;
  }
  updateResult() {
    const e = n(this, I), s = this.createResult(n(this, m), this.options);
    if (f(this, G, n(this, m).state), f(this, re, this.options), n(this, G).data !== void 0 && f(this, ie, n(this, m)), Ce(s, e))
      return;
    f(this, I, s);
    const r = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: i } = this.options, a = typeof i == "function" ? i() : i;
      if (a === "all" || !a && !n(this, ae).size)
        return !0;
      const o = new Set(
        a ?? n(this, ae)
      );
      return this.options.throwOnError && o.add("error"), Object.keys(n(this, I)).some((u) => {
        const l = u;
        return n(this, I)[l] !== e[l] && o.has(l);
      });
    };
    w(this, S, yt).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && w(this, S, je).call(this);
  }
}, P = new WeakMap(), m = new WeakMap(), le = new WeakMap(), I = new WeakMap(), G = new WeakMap(), re = new WeakMap(), L = new WeakMap(), M = new WeakMap(), de = new WeakMap(), ne = new WeakMap(), ie = new WeakMap(), z = new WeakMap(), V = new WeakMap(), _ = new WeakMap(), ae = new WeakMap(), S = new WeakSet(), ue = function(e) {
  w(this, S, xe).call(this);
  let s = n(this, m).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (s = s.catch(Se)), s;
}, Pe = function() {
  w(this, S, Ae).call(this);
  const e = pe(
    this.options.staleTime,
    n(this, m)
  );
  if (J || n(this, I).isStale || !we(e))
    return;
  const r = ot(n(this, I).dataUpdatedAt, e) + 1;
  f(this, z, setTimeout(() => {
    n(this, I).isStale || this.updateResult();
  }, r));
}, Te = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(n(this, m)) : this.options.refetchInterval) ?? !1;
}, De = function(e) {
  w(this, S, ke).call(this), f(this, _, e), !(J || k(this.options.enabled, n(this, m)) === !1 || !we(n(this, _)) || n(this, _) === 0) && f(this, V, setInterval(() => {
    (this.options.refetchIntervalInBackground || ut.isFocused()) && w(this, S, ue).call(this);
  }, n(this, _)));
}, je = function() {
  w(this, S, Pe).call(this), w(this, S, De).call(this, w(this, S, Te).call(this));
}, Ae = function() {
  n(this, z) && (clearTimeout(n(this, z)), f(this, z, void 0));
}, ke = function() {
  n(this, V) && (clearInterval(n(this, V)), f(this, V, void 0));
}, xe = function() {
  const e = n(this, P).getQueryCache().build(n(this, P), this.options);
  if (e === n(this, m))
    return;
  const s = n(this, m);
  f(this, m, e), f(this, le, e.state), this.hasListeners() && (s == null || s.removeObserver(this), e.addObserver(this));
}, yt = function(e) {
  Le.batch(() => {
    e.listeners && this.listeners.forEach((s) => {
      s(n(this, I));
    }), n(this, P).getQueryCache().notify({
      query: n(this, m),
      type: "observerResultsUpdated"
    });
  });
}, at);
function Qt(t, e) {
  return k(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function Ze(t, e) {
  return Qt(t, e) || t.state.data !== void 0 && qe(t, e, e.refetchOnMount);
}
function qe(t, e, s) {
  if (k(e.enabled, t) !== !1) {
    const r = typeof s == "function" ? s(t) : s;
    return r === "always" || r !== !1 && Me(t, e);
  }
  return !1;
}
function We(t, e, s, r) {
  return (t !== e || k(r.enabled, t) === !1) && (!s.suspense || t.state.status !== "error") && Me(t, s);
}
function Me(t, e) {
  return k(e.enabled, t) !== !1 && t.isStaleByTime(pe(e.staleTime, t));
}
function Nt(t, e) {
  return !Ce(t.getCurrentResult(), e);
}
var pt = j.createContext(
  void 0
), vt = (t) => {
  const e = j.useContext(pt);
  if (t)
    return t;
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, Fs = ({
  client: t,
  children: e
}) => (j.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ Ot.jsx(pt.Provider, { value: t, children: e })), mt = j.createContext(!1), Lt = () => j.useContext(mt);
mt.Provider;
function Mt() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var _t = j.createContext(Mt()), Ht = () => j.useContext(_t);
function Kt(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
function Ye() {
}
var Bt = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, $t = (t) => {
  j.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Gt = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: s,
  query: r,
  suspense: i
}) => t.isError && !e.isReset() && !t.isFetching && r && (i && t.data === void 0 || Kt(s, [t.error, r])), zt = (t, e) => e.state.data === void 0, Vt = (t) => {
  const e = t.staleTime;
  t.suspense && (t.staleTime = typeof e == "function" ? (...s) => Math.max(e(...s), 1e3) : Math.max(e ?? 1e3, 1e3), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)));
}, Jt = (t, e) => t.isLoading && t.isFetching && !e, Zt = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, Xe = (t, e, s) => e.fetchOptimistic(t).catch(() => {
  s.clearReset();
});
function bt(t, e, s) {
  var c, p, d, E, h;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = vt(s), i = Lt(), a = Ht(), o = r.defaultQueryOptions(t);
  (p = (c = r.getDefaultOptions().queries) == null ? void 0 : c._experimental_beforeQuery) == null || p.call(
    c,
    o
  ), process.env.NODE_ENV !== "production" && (o.queryFn || console.error(
    `[${o.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), o._optimisticResults = i ? "isRestoring" : "optimistic", Vt(o), Bt(o, a), $t(a);
  const u = !r.getQueryCache().get(o.queryHash), [l] = j.useState(
    () => new e(
      r,
      o
    )
  ), y = l.getOptimisticResult(o), g = !i && t.subscribed !== !1;
  if (j.useSyncExternalStore(
    j.useCallback(
      (v) => {
        const C = g ? l.subscribe(Le.batchCalls(v)) : Ye;
        return l.updateResult(), C;
      },
      [l, g]
    ),
    () => l.getCurrentResult(),
    () => l.getCurrentResult()
  ), j.useEffect(() => {
    l.setOptions(o);
  }, [o, l]), Zt(o, y))
    throw Xe(o, l, a);
  if (Gt({
    result: y,
    errorResetBoundary: a,
    throwOnError: o.throwOnError,
    query: r.getQueryCache().get(o.queryHash),
    suspense: o.suspense
  }))
    throw y.error;
  if ((E = (d = r.getDefaultOptions().queries) == null ? void 0 : d._experimental_afterQuery) == null || E.call(
    d,
    o,
    y
  ), o.experimental_prefetchInRender && !J && Jt(y, i)) {
    const v = u ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Xe(o, l, a)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (h = r.getQueryCache().get(o.queryHash)) == null ? void 0 : h.promise
    );
    v == null || v.catch(Ye).finally(() => {
      l.updateResult();
    });
  }
  return o.notifyOnChangeProps ? y : l.trackResult(y);
}
function Wt(t, e) {
  return bt(t, ft, e);
}
function Yt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === ve && console.error("skipToken is not allowed for useSuspenseQuery"), bt(
    {
      ...t,
      enabled: !0,
      suspense: !0,
      throwOnError: zt,
      placeholderData: void 0
    },
    ft,
    e
  );
}
const Xt = /^(\w+:\/\/[^/?]+)?([^?]*)(\?.*)?$/, es = (t) => t.filter(
  (e) => e != null && e !== !1 && (typeof e == "string" || typeof e == "number")
).map((e) => `${e}`).filter((e) => e), ts = (t) => {
  const e = t.join("/"), [, s = "", r = ""] = e.match(Xt) ?? [];
  return {
    prefix: s,
    pathname: r.split("/").filter((i) => i !== "")
  };
}, ss = (t) => {
  const { prefix: e, pathname: s } = t;
  let r = e;
  return s.length > 0 ? (r ? r += "/" : r = "/", r += s.join("/")) : r || (r = "/"), r;
}, et = (...t) => {
  const e = es(t), s = ts(e);
  return ss(s);
}, gt = Object.freeze({
  API_IDENTITIES: ["api-identities"]
}), Is = () => {
  const t = vt();
  return {
    invalidateCache: async (e) => {
      await t.invalidateQueries({ queryKey: gt[e] });
    }
  };
}, rs = "no-dehydrate", ce = (...t) => {
  const e = t.filter((s) => !!s).map((s) => s.replace(/(^\/+|\/+$)/g, "")).join("/").replace(/(^\/+|\/+$)/g, "");
  return e ? `/${e}` : "/";
}, _e = (t, e) => {
  for (const s of t) {
    const r = He(s, e);
    if (r !== void 0) return r;
  }
}, He = (t, e, s = []) => {
  const r = e(t, s);
  if (r !== void 0) return r;
  if (t.type === "category")
    for (const i of t.items) {
      const a = He(i, e, [
        ...s,
        t
      ]);
      if (a !== void 0) return a;
    }
}, Ps = () => {
  const t = me(), s = St().sidebar;
  return _e(s, (r) => {
    if (r.type === "doc" && ce(r.id) === t.pathname)
      return r;
  });
}, Ts = (t) => {
  const e = me();
  return He(t, (s) => {
    if (s.type === "category" && s.link && ce(s.link.id) === e.pathname || s.type === "doc" && ce(s.id) === e.pathname)
      return !0;
  });
}, Ds = () => {
  const t = me().pathname, s = St().sidebar;
  let r, i, a = !1;
  return _e(s, (o) => {
    const u = o.type === "doc" ? ce(o.id) : o.type === "category" && o.link ? ce(o.link.id) : void 0;
    if (u) {
      if (a)
        return i = { label: o.label, id: u }, !0;
      t === u ? a = !0 : r = { label: o.label, id: u };
    }
  }), { prev: r, next: i };
}, ns = Et(
  void 0
), Ke = () => {
  const t = Ct(ns);
  if (!t)
    throw new Error("useZudoku must be used within a ZudokuProvider.");
  return t;
}, js = () => {
  const { getApiIdentities: t } = Ke();
  return Wt({
    queryFn: t,
    queryKey: gt.API_IDENTITIES
  });
}, St = () => {
  var c;
  const { getPluginSidebar: t, sidebars: e, topNavigation: s, options: r } = Ke(), i = me(), a = fs(), o = (c = r.protectedRoutes) == null ? void 0 : c.some(
    (p) => ze(p, i.pathname)
  );
  let u = Object.entries(e).find(([, p]) => _e(p, (d) => {
    if ((d.type === "doc" ? et(d.id) : d.type === "category" && d.link ? et(d.link.id) : void 0) === i.pathname)
      return d;
  }));
  const l = s.find((p) => p.id === (u == null ? void 0 : u[0])) ?? s.find((p) => ze(p.id, i.pathname));
  l && !u && l.id in e && (u = ["", e[l.id]]);
  const { data: y } = Yt({
    queryFn: () => t(i.pathname),
    // We just want to suspend here and don't store in SSR dehydrated state
    queryKey: ["plugin-sidebar", rs, i.pathname]
  });
  return {
    sidebar: a.isAuthEnabled && !a.isAuthenticated && o ? [] : [...u ? u[1] : [], ...y],
    topNavItem: l
  };
}, tt = (t) => {
  let e;
  const s = /* @__PURE__ */ new Set(), r = (y, g) => {
    const c = typeof y == "function" ? y(e) : y;
    if (!Object.is(c, e)) {
      const p = e;
      e = g ?? (typeof c != "object" || c === null) ? c : Object.assign({}, e, c), s.forEach((d) => d(e, p));
    }
  }, i = () => e, u = { setState: r, getState: i, getInitialState: () => l, subscribe: (y) => (s.add(y), () => s.delete(y)) }, l = e = t(r, i, u);
  return u;
}, is = (t) => t ? tt(t) : tt, as = (t) => t;
function os(t, e = as) {
  const s = Ge.useSyncExternalStore(
    t.subscribe,
    () => e(t.getState()),
    () => e(t.getInitialState())
  );
  return Ge.useDebugValue(s), s;
}
const us = (t) => {
  const e = is(t), s = (r) => os(e, r);
  return Object.assign(s, e), s;
}, cs = (t) => us;
function wt(t, e) {
  let s;
  try {
    s = t();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var a;
      const o = (l) => l === null ? null : JSON.parse(l, void 0), u = (a = s.getItem(i)) != null ? a : null;
      return u instanceof Promise ? u.then(o) : o(u);
    },
    setItem: (i, a) => s.setItem(
      i,
      JSON.stringify(a, void 0)
    ),
    removeItem: (i) => s.removeItem(i)
  };
}
const Ue = (t) => (e) => {
  try {
    const s = t(e);
    return s instanceof Promise ? s : {
      then(r) {
        return Ue(r)(s);
      },
      catch(r) {
        return this;
      }
    };
  } catch (s) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Ue(r)(s);
      }
    };
  }
}, hs = (t, e) => (s, r, i) => {
  let a = {
    storage: wt(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, v) => ({
      ...v,
      ...h
    }),
    ...e
  }, o = !1;
  const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let y = a.storage;
  if (!y)
    return t(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), s(...h);
      },
      r,
      i
    );
  const g = () => {
    const h = a.partialize({ ...r() });
    return y.setItem(a.name, {
      state: h,
      version: a.version
    });
  }, c = i.setState;
  i.setState = (h, v) => {
    c(h, v), g();
  };
  const p = t(
    (...h) => {
      s(...h), g();
    },
    r,
    i
  );
  i.getInitialState = () => p;
  let d;
  const E = () => {
    var h, v;
    if (!y) return;
    o = !1, u.forEach((R) => {
      var O;
      return R((O = r()) != null ? O : p);
    });
    const C = ((v = a.onRehydrateStorage) == null ? void 0 : v.call(a, (h = r()) != null ? h : p)) || void 0;
    return Ue(y.getItem.bind(y))(a.name).then((R) => {
      if (R)
        if (typeof R.version == "number" && R.version !== a.version) {
          if (a.migrate) {
            const O = a.migrate(
              R.state,
              R.version
            );
            return O instanceof Promise ? O.then((q) => [!0, q]) : [!0, O];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, R.state];
      return [!1, void 0];
    }).then((R) => {
      var O;
      const [q, Z] = R;
      if (d = a.merge(
        Z,
        (O = r()) != null ? O : p
      ), s(d, !0), q)
        return g();
    }).then(() => {
      C == null || C(d, void 0), d = r(), o = !0, l.forEach((R) => R(d));
    }).catch((R) => {
      C == null || C(void 0, R);
    });
  };
  return i.persist = {
    setOptions: (h) => {
      a = {
        ...a,
        ...h
      }, h.storage && (y = h.storage);
    },
    clearStorage: () => {
      y == null || y.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => E(),
    hasHydrated: () => o,
    onHydrate: (h) => (u.add(h), () => {
      u.delete(h);
    }),
    onFinishHydration: (h) => (l.add(h), () => {
      l.delete(h);
    })
  }, a.skipHydration || E(), d || p;
}, ls = hs, ds = (t) => {
  const e = (s) => {
    s.key === t.persist.getOptions().name && s.newValue && t.persist.rehydrate();
  };
  return window.addEventListener("storage", e), () => {
    window.removeEventListener("storage", e);
  };
}, Rt = cs()(
  ls(
    (t) => ({
      isAuthenticated: !1,
      isPending: !0,
      profile: null,
      providerData: null
    }),
    {
      merge: (t, e) => ({
        ...e,
        isPending: !1,
        ...typeof t == "object" ? t : {}
      }),
      name: "auth-state",
      storage: wt(() => localStorage)
    }
  )
);
typeof window < "u" && ds(Rt);
const fs = () => {
  const { authentication: t } = Ke(), e = Rt(), s = typeof t < "u";
  return {
    isAuthEnabled: s,
    ...e,
    login: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signIn({
        redirectTo: window.location.href
      });
    },
    logout: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signOut(), window.location.href = "/";
    },
    signup: async () => {
      if (!s)
        throw new Error("Authentication is not enabled.");
      await t.signUp({
        redirectTo: window.location.href
      });
    }
  };
};
export {
  Cs as A,
  Es as B,
  ut as C,
  ct as D,
  pe as E,
  gs as F,
  Ne as G,
  ve as H,
  Fs as I,
  St as J,
  _e as K,
  Is as L,
  gt as M,
  Ts as N,
  Os as Q,
  qt as R,
  Qe as S,
  ns as Z,
  Ps as a,
  Ds as b,
  At as c,
  Yt as d,
  Ke as e,
  et as f,
  vt as g,
  Re as h,
  Ye as i,
  ce as j,
  Kt as k,
  fs as l,
  Wt as m,
  Le as n,
  Rs as o,
  cs as p,
  ls as q,
  wt as r,
  Ce as s,
  js as t,
  Rt as u,
  Ft as v,
  Ss as w,
  ws as x,
  Se as y,
  Pt as z
};
//# sourceMappingURL=hook-pPrHCB6G.js.map
