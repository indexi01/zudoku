var Le = Object.defineProperty;
var xe = (t, e, n) => e in t ? Le(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var b = (t, e, n) => xe(t, typeof e != "symbol" ? e + "" : e, n);
import { j as B } from "./jsx-runtime-C5mzlN2N.js";
import { g as Ce } from "./_commonjsHelpers-B4e78b8K.js";
import { C as Ie } from "./ClientOnly-E7hGysn1.js";
import { d as je, f as ie, u as x } from "./hook-pPrHCB6G.js";
import { A as Je } from "./AuthenticationPlugin-CJOFRBk3.js";
import { N as Oe } from "./chunk-KNED5TY2-BUPjb3LQ.js";
import { Z as ze } from "./invariant-Caa8-XvF.js";
var D = { exports: {} }, De = D.exports, ae;
function Ne() {
  return ae || (ae = 1, function(t) {
    (function(e, n) {
      t.exports ? t.exports = n() : e.log = n();
    })(De, function() {
      var e = function() {
      }, n = "undefined", o = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), a = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], r = {}, i = null;
      function c(l, m) {
        var u = l[m];
        if (typeof u.bind == "function")
          return u.bind(l);
        try {
          return Function.prototype.bind.call(u, l);
        } catch {
          return function() {
            return Function.prototype.apply.apply(u, [l, arguments]);
          };
        }
      }
      function p() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function w(l) {
        return l === "debug" && (l = "log"), typeof console === n ? !1 : l === "trace" && o ? p : console[l] !== void 0 ? c(console, l) : console.log !== void 0 ? c(console, "log") : e;
      }
      function f() {
        for (var l = this.getLevel(), m = 0; m < a.length; m++) {
          var u = a[m];
          this[u] = m < l ? e : this.methodFactory(u, l, this.name);
        }
        if (this.log = this.debug, typeof console === n && l < this.levels.SILENT)
          return "No console available for logging";
      }
      function v(l) {
        return function() {
          typeof console !== n && (f.call(this), this[l].apply(this, arguments));
        };
      }
      function _(l, m, u) {
        return w(l) || v.apply(this, arguments);
      }
      function h(l, m) {
        var u = this, J, $, U, S = "loglevel";
        typeof l == "string" ? S += ":" + l : typeof l == "symbol" && (S = void 0);
        function Re(d) {
          var y = (a[d] || "silent").toUpperCase();
          if (!(typeof window === n || !S)) {
            try {
              window.localStorage[S] = y;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(S) + "=" + y + ";";
            } catch {
            }
          }
        }
        function ne() {
          var d;
          if (!(typeof window === n || !S)) {
            try {
              d = window.localStorage[S];
            } catch {
            }
            if (typeof d === n)
              try {
                var y = window.document.cookie, O = encodeURIComponent(S), oe = y.indexOf(O + "=");
                oe !== -1 && (d = /^([^;]+)/.exec(
                  y.slice(oe + O.length + 1)
                )[1]);
              } catch {
              }
            return u.levels[d] === void 0 && (d = void 0), d;
          }
        }
        function Pe() {
          if (!(typeof window === n || !S)) {
            try {
              window.localStorage.removeItem(S);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(S) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function L(d) {
          var y = d;
          if (typeof y == "string" && u.levels[y.toUpperCase()] !== void 0 && (y = u.levels[y.toUpperCase()]), typeof y == "number" && y >= 0 && y <= u.levels.SILENT)
            return y;
          throw new TypeError("log.setLevel() called with invalid level: " + d);
        }
        u.name = l, u.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, u.methodFactory = m || _, u.getLevel = function() {
          return U ?? $ ?? J;
        }, u.setLevel = function(d, y) {
          return U = L(d), y !== !1 && Re(U), f.call(u);
        }, u.setDefaultLevel = function(d) {
          $ = L(d), ne() || u.setLevel(d, !1);
        }, u.resetLevel = function() {
          U = null, Pe(), f.call(u);
        }, u.enableAll = function(d) {
          u.setLevel(u.levels.TRACE, d);
        }, u.disableAll = function(d) {
          u.setLevel(u.levels.SILENT, d);
        }, u.rebuild = function() {
          if (i !== u && (J = L(i.getLevel())), f.call(u), i === u)
            for (var d in r)
              r[d].rebuild();
        }, J = L(
          i ? i.getLevel() : "WARN"
        );
        var re = ne();
        re != null && (U = L(re)), f.call(u);
      }
      i = new h(), i.getLogger = function(m) {
        if (typeof m != "symbol" && typeof m != "string" || m === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var u = r[m];
        return u || (u = r[m] = new h(
          m,
          i.methodFactory
        )), u;
      };
      var P = typeof window !== n ? window.log : void 0;
      return i.noConflict = function() {
        return typeof window !== n && window.log === i && (window.log = P), i;
      }, i.getLoggers = function() {
        return r;
      }, i.default = i, i;
    });
  }(D)), D.exports;
}
var We = Ne();
const se = /* @__PURE__ */ Ce(We);
let V;
var z, we;
(typeof navigator > "u" || !((we = (z = navigator.userAgent) == null ? void 0 : z.startsWith) != null && we.call(z, "Mozilla/5.0 "))) && (V = "oauth4webapi/v2.17.0");
function Y(t, e) {
  if (t == null)
    return !1;
  try {
    return t instanceof e || Object.getPrototypeOf(t)[Symbol.toStringTag] === e.prototype[Symbol.toStringTag];
  } catch {
    return !1;
  }
}
const W = Symbol(), Ke = Symbol(), Z = Symbol(), He = Symbol(), $e = Symbol(), Fe = Symbol(), Me = new TextEncoder(), qe = new TextDecoder();
function E(t) {
  return typeof t == "string" ? Me.encode(t) : qe.decode(t);
}
const ce = 32768;
function Be(t) {
  t instanceof ArrayBuffer && (t = new Uint8Array(t));
  const e = [];
  for (let n = 0; n < t.byteLength; n += ce)
    e.push(String.fromCharCode.apply(null, t.subarray(n, n + ce)));
  return btoa(e.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function Ve(t) {
  try {
    const e = atob(t.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")), n = new Uint8Array(e.length);
    for (let o = 0; o < e.length; o++)
      n[o] = e.charCodeAt(o);
    return n;
  } catch (e) {
    throw new s("The input to be decoded is not correctly encoded.", { cause: e });
  }
}
function k(t) {
  return typeof t == "string" ? Ve(t) : Be(t);
}
class Ge {
  constructor(e) {
    this.cache = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this.maxSize = e;
  }
  get(e) {
    let n = this.cache.get(e);
    if (n)
      return n;
    if (n = this._cache.get(e))
      return this.update(e, n), n;
  }
  has(e) {
    return this.cache.has(e) || this._cache.has(e);
  }
  set(e, n) {
    return this.cache.has(e) ? this.cache.set(e, n) : this.update(e, n), this;
  }
  delete(e) {
    return this.cache.has(e) ? this.cache.delete(e) : this._cache.has(e) ? this._cache.delete(e) : !1;
  }
  update(e, n) {
    this.cache.set(e, n), this.cache.size >= this.maxSize && (this._cache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
}
class T extends Error {
  constructor(e) {
    var n;
    super(e ?? "operation not supported"), this.name = this.constructor.name, (n = Error.captureStackTrace) == null || n.call(Error, this, this.constructor);
  }
}
class Ye extends Error {
  constructor(e, n) {
    var o;
    super(e, n), this.name = this.constructor.name, (o = Error.captureStackTrace) == null || o.call(Error, this, this.constructor);
  }
}
const s = Ye, ge = new Ge(100);
function me(t) {
  return t instanceof CryptoKey;
}
function Ze(t) {
  return me(t) && t.type === "private";
}
function Qe(t) {
  return me(t) && t.type === "public";
}
function Q(t) {
  try {
    const e = t.headers.get("dpop-nonce");
    e && ge.set(new URL(t.url).origin, e);
  } catch {
  }
  return t;
}
function C(t) {
  return !(t === null || typeof t != "object" || Array.isArray(t));
}
function K(t) {
  Y(t, Headers) && (t = Object.fromEntries(t.entries()));
  const e = new Headers(t);
  if (V && !e.has("user-agent") && e.set("user-agent", V), e.has("authorization"))
    throw new TypeError('"options.headers" must not include the "authorization" header name');
  if (e.has("dpop"))
    throw new TypeError('"options.headers" must not include the "dpop" header name');
  return e;
}
function Xe(t) {
  if (typeof t == "function" && (t = t()), !(t instanceof AbortSignal))
    throw new TypeError('"options.signal" must return or be an instance of AbortSignal');
  return t;
}
async function et(t, e) {
  if (!(t instanceof URL))
    throw new TypeError('"issuerIdentifier" must be an instance of URL');
  if (t.protocol !== "https:" && t.protocol !== "http:")
    throw new TypeError('"issuer.protocol" must be "https:" or "http:"');
  const n = new URL(t.href);
  switch (e == null ? void 0 : e.algorithm) {
    case void 0:
    case "oidc":
      n.pathname = `${n.pathname}/.well-known/openid-configuration`.replace("//", "/");
      break;
    case "oauth2":
      n.pathname === "/" ? n.pathname = ".well-known/oauth-authorization-server" : n.pathname = `.well-known/oauth-authorization-server/${n.pathname}`.replace("//", "/");
      break;
    default:
      throw new TypeError('"options.algorithm" must be "oidc" (default), or "oauth2"');
  }
  const o = K(e == null ? void 0 : e.headers);
  return o.set("accept", "application/json"), ((e == null ? void 0 : e[Z]) || fetch)(n.href, {
    headers: Object.fromEntries(o.entries()),
    method: "GET",
    redirect: "manual",
    signal: null
  }).then(Q);
}
function g(t) {
  return typeof t == "string" && t.length !== 0;
}
async function tt(t, e) {
  if (!(t instanceof URL))
    throw new TypeError('"expectedIssuer" must be an instance of URL');
  if (!Y(e, Response))
    throw new TypeError('"response" must be an instance of Response');
  if (e.status !== 200)
    throw new s('"response" is not a conform Authorization Server Metadata response');
  te(e);
  let n;
  try {
    n = await e.json();
  } catch (o) {
    throw new s('failed to parse "response" body as JSON', { cause: o });
  }
  if (!C(n))
    throw new s('"response" body must be a top level object');
  if (!g(n.issuer))
    throw new s('"response" body "issuer" property must be a non-empty string');
  if (new URL(n.issuer).href !== t.href)
    throw new s('"response" body "issuer" does not match "expectedIssuer"');
  return n;
}
function X() {
  return k(crypto.getRandomValues(new Uint8Array(32)));
}
function nt() {
  return X();
}
function rt() {
  return X();
}
async function ot(t) {
  if (!g(t))
    throw new TypeError('"codeVerifier" must be a non-empty string');
  return k(await crypto.subtle.digest("SHA-256", E(t)));
}
function ue(t) {
  return encodeURIComponent(t).replace(/%20/g, "+");
}
function it(t, e) {
  const n = ue(t), o = ue(e);
  return `Basic ${btoa(`${n}:${o}`)}`;
}
function at(t) {
  switch (t.algorithm.hash.name) {
    case "SHA-256":
      return "PS256";
    case "SHA-384":
      return "PS384";
    case "SHA-512":
      return "PS512";
    default:
      throw new T("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
function st(t) {
  switch (t.algorithm.hash.name) {
    case "SHA-256":
      return "RS256";
    case "SHA-384":
      return "RS384";
    case "SHA-512":
      return "RS512";
    default:
      throw new T("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
function ct(t) {
  switch (t.algorithm.namedCurve) {
    case "P-256":
      return "ES256";
    case "P-384":
      return "ES384";
    case "P-521":
      return "ES512";
    default:
      throw new T("unsupported EcKeyAlgorithm namedCurve");
  }
}
function ut(t) {
  switch (t.algorithm.name) {
    case "RSA-PSS":
      return at(t);
    case "RSASSA-PKCS1-v1_5":
      return st(t);
    case "ECDSA":
      return ct(t);
    case "Ed25519":
    case "Ed448":
      return "EdDSA";
    default:
      throw new T("unsupported CryptoKey algorithm name");
  }
}
function H(t) {
  const e = t == null ? void 0 : t[W];
  return typeof e == "number" && Number.isFinite(e) ? e : 0;
}
function ye(t) {
  const e = t == null ? void 0 : t[Ke];
  return typeof e == "number" && Number.isFinite(e) && Math.sign(e) !== -1 ? e : 30;
}
function ee() {
  return Math.floor(Date.now() / 1e3);
}
function I(t) {
  if (typeof t != "object" || t === null)
    throw new TypeError('"as" must be an object');
  if (!g(t.issuer))
    throw new TypeError('"as.issuer" property must be a non-empty string');
  return !0;
}
function j(t) {
  if (typeof t != "object" || t === null)
    throw new TypeError('"client" must be an object');
  if (!g(t.client_id))
    throw new TypeError('"client.client_id" property must be a non-empty string');
  return !0;
}
function le(t) {
  if (!g(t))
    throw new TypeError('"client.client_secret" property must be a non-empty string');
  return t;
}
function de(t, e) {
  if (e !== void 0)
    throw new TypeError(`"client.client_secret" property must not be provided when ${t} client authentication method is used.`);
}
async function lt(t, e, n, o, a) {
  switch (n.delete("client_secret"), n.delete("client_assertion_type"), n.delete("client_assertion"), e.token_endpoint_auth_method) {
    case void 0:
    case "client_secret_basic": {
      o.set("authorization", it(e.client_id, le(e.client_secret)));
      break;
    }
    case "client_secret_post": {
      n.set("client_id", e.client_id), n.set("client_secret", le(e.client_secret));
      break;
    }
    case "private_key_jwt":
      throw de("private_key_jwt", e.client_secret), new TypeError('"options.clientPrivateKey" must be provided when "client.token_endpoint_auth_method" is "private_key_jwt"');
    case "tls_client_auth":
    case "self_signed_tls_client_auth":
    case "none": {
      de(e.token_endpoint_auth_method, e.client_secret), e.token_endpoint_auth_method, n.set("client_id", e.client_id);
      break;
    }
    default:
      throw new T("unsupported client token_endpoint_auth_method");
  }
}
async function dt(t, e, n) {
  if (!n.usages.includes("sign"))
    throw new TypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"');
  const o = `${k(E(JSON.stringify(t)))}.${k(E(JSON.stringify(e)))}`, a = k(await crypto.subtle.sign(ke(n), n, E(o)));
  return `${o}.${a}`;
}
async function ht(t, e, n, o, a, r) {
  var _;
  const { privateKey: i, publicKey: c, nonce: p = ge.get(n.origin) } = e;
  if (!Ze(i))
    throw new TypeError('"DPoP.privateKey" must be a private CryptoKey');
  if (!Qe(c))
    throw new TypeError('"DPoP.publicKey" must be a public CryptoKey');
  if (p !== void 0 && !g(p))
    throw new TypeError('"DPoP.nonce" must be a non-empty string or undefined');
  if (!c.extractable)
    throw new TypeError('"DPoP.publicKey.extractable" must be true');
  const w = ee() + a, f = {
    alg: ut(i),
    typ: "dpop+jwt",
    jwk: await pt(c)
  }, v = {
    iat: w,
    jti: X(),
    htm: o,
    nonce: p,
    htu: `${n.origin}${n.pathname}`,
    ath: r ? k(await crypto.subtle.digest("SHA-256", E(r))) : void 0
  };
  (_ = e[He]) == null || _.call(e, f, v), t.set("dpop", await dt(f, v, i));
}
let N;
async function ft(t) {
  const { kty: e, e: n, n: o, x: a, y: r, crv: i } = await crypto.subtle.exportKey("jwk", t), c = { kty: e, e: n, n: o, x: a, y: r, crv: i };
  return N.set(t, c), c;
}
async function pt(t) {
  return N || (N = /* @__PURE__ */ new WeakMap()), N.get(t) || ft(t);
}
function he(t, e, n) {
  if (typeof t != "string")
    throw n ? new TypeError(`"as.mtls_endpoint_aliases.${e}" must be a string`) : new TypeError(`"as.${e}" must be a string`);
  return new URL(t);
}
function be(t, e, n = !1) {
  return n && t.mtls_endpoint_aliases && e in t.mtls_endpoint_aliases ? he(t.mtls_endpoint_aliases[e], e, n) : he(t[e], e, n);
}
function _e(t, e) {
  return !!(t.use_mtls_endpoint_aliases || e != null && e[Fe]);
}
function G(t) {
  const e = t;
  return typeof e != "object" || Array.isArray(e) || e === null ? !1 : e.error !== void 0;
}
async function wt(t, e, n, o, a, r) {
  if (!g(t))
    throw new TypeError('"accessToken" must be a non-empty string');
  if (!(n instanceof URL))
    throw new TypeError('"url" must be an instance of URL');
  return o = K(o), (r == null ? void 0 : r.DPoP) === void 0 ? o.set("authorization", `Bearer ${t}`) : (await ht(o, r.DPoP, n, e.toUpperCase(), H({ [W]: r == null ? void 0 : r[W] }), t), o.set("authorization", `DPoP ${t}`)), ((r == null ? void 0 : r[Z]) || fetch)(n.href, {
    body: a,
    headers: Object.fromEntries(o.entries()),
    method: e,
    redirect: "manual",
    signal: r != null && r.signal ? Xe(r.signal) : null
  }).then(Q);
}
async function gt(t, e, n, o) {
  I(t), j(e);
  const a = be(t, "userinfo_endpoint", _e(e, o)), r = K(o == null ? void 0 : o.headers);
  return e.userinfo_signed_response_alg ? r.set("accept", "application/jwt") : (r.set("accept", "application/json"), r.append("accept", "application/jwt")), wt(n, "GET", a, r, null, {
    ...o,
    [W]: H(e)
  });
}
async function mt(t, e, n, o, a, r, i) {
  return await lt(t, e, a, r), r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), ((i == null ? void 0 : i[Z]) || fetch)(o.href, {
    body: a,
    headers: Object.fromEntries(r.entries()),
    method: n,
    redirect: "manual",
    signal: null
  }).then(Q);
}
async function ve(t, e, n, o, a) {
  const r = be(t, "token_endpoint", _e(e, a));
  o.set("grant_type", n);
  const i = K(a == null ? void 0 : a.headers);
  return i.set("accept", "application/json"), mt(t, e, "POST", r, o, i, a);
}
async function yt(t, e, n, o) {
  if (I(t), j(e), !g(n))
    throw new TypeError('"refreshToken" must be a non-empty string');
  const a = new URLSearchParams(o == null ? void 0 : o.additionalParameters);
  return a.set("refresh_token", n), ve(t, e, "refresh_token", a, o);
}
const Se = /* @__PURE__ */ new WeakMap();
function bt(t) {
  if (!t.id_token)
    return;
  const e = Se.get(t);
  if (!e)
    throw new TypeError('"ref" was already garbage collected or did not resolve from the proper sources');
  return e[0];
}
async function Te(t, e, n, o = !1, a = !1) {
  if (I(t), j(e), !Y(n, Response))
    throw new TypeError('"response" must be an instance of Response');
  if (n.status !== 200) {
    let i;
    if (i = await Ut(n))
      return i;
    throw new s('"response" is not a conform Token Endpoint response');
  }
  te(n);
  let r;
  try {
    r = await n.json();
  } catch (i) {
    throw new s('failed to parse "response" body as JSON', { cause: i });
  }
  if (!C(r))
    throw new s('"response" body must be a top level object');
  if (!g(r.access_token))
    throw new s('"response" body "access_token" property must be a non-empty string');
  if (!g(r.token_type))
    throw new s('"response" body "token_type" property must be a non-empty string');
  if (r.token_type = r.token_type.toLowerCase(), r.token_type !== "dpop" && r.token_type !== "bearer")
    throw new T("unsupported `token_type` value");
  if (r.expires_in !== void 0 && (typeof r.expires_in != "number" || r.expires_in <= 0))
    throw new s('"response" body "expires_in" property must be a positive number');
  if (!a && r.refresh_token !== void 0 && !g(r.refresh_token))
    throw new s('"response" body "refresh_token" property must be a non-empty string');
  if (r.scope !== void 0 && typeof r.scope != "string")
    throw new s('"response" body "scope" property must be a string');
  if (!o) {
    if (r.id_token !== void 0 && !g(r.id_token))
      throw new s('"response" body "id_token" property must be a non-empty string');
    if (r.id_token) {
      const { claims: i, jwt: c } = await Ct(r.id_token, It.bind(void 0, e.id_token_signed_response_alg, t.id_token_signing_alg_values_supported), Ee, H(e), ye(e), e[$e]).then(Et.bind(void 0, ["aud", "exp", "iat", "iss", "sub"])).then(St.bind(void 0, t.issuer)).then(vt.bind(void 0, e.client_id));
      if (Array.isArray(i.aud) && i.aud.length !== 1) {
        if (i.azp === void 0)
          throw new s('ID Token "aud" (audience) claim includes additional untrusted audiences');
        if (i.azp !== e.client_id)
          throw new s('unexpected ID Token "azp" (authorized party) claim value');
      }
      if (i.auth_time !== void 0 && (!Number.isFinite(i.auth_time) || Math.sign(i.auth_time) !== 1))
        throw new s('ID Token "auth_time" (authentication time) must be a positive number');
      Se.set(r, [i, c]);
    }
  }
  return r;
}
async function _t(t, e, n) {
  return Te(t, e, n);
}
function vt(t, e) {
  if (Array.isArray(e.claims.aud)) {
    if (!e.claims.aud.includes(t))
      throw new s('unexpected JWT "aud" (audience) claim value');
  } else if (e.claims.aud !== t)
    throw new s('unexpected JWT "aud" (audience) claim value');
  return e;
}
function St(t, e) {
  if (e.claims.iss !== t)
    throw new s('unexpected JWT "iss" (issuer) claim value');
  return e;
}
const Ae = /* @__PURE__ */ new WeakSet();
function Tt(t) {
  return Ae.add(t), t;
}
async function At(t, e, n, o, a, r) {
  if (I(t), j(e), !Ae.has(n))
    throw new TypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()');
  if (!g(o))
    throw new TypeError('"redirectUri" must be a non-empty string');
  if (!g(a))
    throw new TypeError('"codeVerifier" must be a non-empty string');
  const i = A(n, "code");
  if (!i)
    throw new s('no authorization code in "callbackParameters"');
  const c = new URLSearchParams(r == null ? void 0 : r.additionalParameters);
  return c.set("redirect_uri", o), c.set("code_verifier", a), c.set("code", i), ve(t, e, "authorization_code", c, r);
}
const kt = {
  aud: "audience",
  c_hash: "code hash",
  client_id: "client id",
  exp: "expiration time",
  iat: "issued at",
  iss: "issuer",
  jti: "jwt id",
  nonce: "nonce",
  s_hash: "state hash",
  sub: "subject",
  ath: "access token hash",
  htm: "http method",
  htu: "http uri",
  cnf: "confirmation"
};
function Et(t, e) {
  for (const n of t)
    if (e.claims[n] === void 0)
      throw new s(`JWT "${n}" (${kt[n]}) claim missing`);
  return e;
}
const Rt = Symbol(), F = Symbol();
async function Pt(t, e, n, o, a) {
  const r = await Te(t, e, n);
  if (G(r))
    return r;
  if (!g(r.id_token))
    throw new s('"response" body "id_token" property must be a non-empty string');
  a ?? (a = e.default_max_age ?? F);
  const i = bt(r);
  if ((e.require_auth_time || a !== F) && i.auth_time === void 0)
    throw new s('ID Token "auth_time" (authentication time) claim missing');
  if (a !== F) {
    if (typeof a != "number" || a < 0)
      throw new TypeError('"maxAge" must be a non-negative number');
    const c = ee() + H(e), p = ye(e);
    if (i.auth_time + a < c - p)
      throw new s("too much time has elapsed since the last End-User authentication");
  }
  switch (o) {
    case void 0:
    case Rt:
      if (i.nonce !== void 0)
        throw new s('unexpected ID Token "nonce" claim value');
      break;
    default:
      if (!g(o))
        throw new TypeError('"expectedNonce" must be a non-empty string');
      if (i.nonce === void 0)
        throw new s('ID Token "nonce" claim missing');
      if (i.nonce !== o)
        throw new s('unexpected ID Token "nonce" claim value');
  }
  return r;
}
function te(t) {
  if (t.bodyUsed)
    throw new TypeError('"response" body has been used already');
}
async function Ut(t) {
  if (t.status > 399 && t.status < 500) {
    te(t);
    try {
      const e = await t.json();
      if (C(e) && typeof e.error == "string" && e.error.length)
        return e.error_description !== void 0 && typeof e.error_description != "string" && delete e.error_description, e.error_uri !== void 0 && typeof e.error_uri != "string" && delete e.error_uri, e.algs !== void 0 && typeof e.algs != "string" && delete e.algs, e.scope !== void 0 && typeof e.scope != "string" && delete e.scope, e;
    } catch {
    }
  }
}
function fe(t) {
  if (typeof t.modulusLength != "number" || t.modulusLength < 2048)
    throw new s(`${t.name} modulusLength must be at least 2048 bits`);
}
function Lt(t) {
  switch (t) {
    case "P-256":
      return "SHA-256";
    case "P-384":
      return "SHA-384";
    case "P-521":
      return "SHA-512";
    default:
      throw new T();
  }
}
function ke(t) {
  switch (t.algorithm.name) {
    case "ECDSA":
      return {
        name: t.algorithm.name,
        hash: Lt(t.algorithm.namedCurve)
      };
    case "RSA-PSS":
      switch (fe(t.algorithm), t.algorithm.hash.name) {
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
          return {
            name: t.algorithm.name,
            saltLength: parseInt(t.algorithm.hash.name.slice(-3), 10) >> 3
          };
        default:
          throw new T();
      }
    case "RSASSA-PKCS1-v1_5":
      return fe(t.algorithm), t.algorithm.name;
    case "Ed448":
    case "Ed25519":
      return t.algorithm.name;
  }
  throw new T();
}
const Ee = Symbol();
async function xt(t, e, n, o) {
  const a = `${t}.${e}`;
  if (!await crypto.subtle.verify(ke(n), n, o, E(a)))
    throw new s("JWT signature verification failed");
}
async function Ct(t, e, n, o, a, r) {
  let { 0: i, 1: c, 2: p, length: w } = t.split(".");
  if (w === 5)
    if (r !== void 0)
      t = await r(t), { 0: i, 1: c, 2: p, length: w } = t.split(".");
    else
      throw new T("JWE structure JWTs are not supported");
  if (w !== 3)
    throw new s("Invalid JWT");
  let f;
  try {
    f = JSON.parse(E(k(i)));
  } catch (l) {
    throw new s("failed to parse JWT Header body as base64url encoded JSON", { cause: l });
  }
  if (!C(f))
    throw new s("JWT Header must be a top level object");
  if (e(f), f.crit !== void 0)
    throw new s('unexpected JWT "crit" header parameter');
  const v = k(p);
  let _;
  n !== Ee && (_ = await n(f), await xt(i, c, _, v));
  let h;
  try {
    h = JSON.parse(E(k(c)));
  } catch (l) {
    throw new s("failed to parse JWT Payload body as base64url encoded JSON", { cause: l });
  }
  if (!C(h))
    throw new s("JWT Payload must be a top level object");
  const P = ee() + o;
  if (h.exp !== void 0) {
    if (typeof h.exp != "number")
      throw new s('unexpected JWT "exp" (expiration time) claim type');
    if (h.exp <= P - a)
      throw new s('unexpected JWT "exp" (expiration time) claim value, timestamp is <= now()');
  }
  if (h.iat !== void 0 && typeof h.iat != "number")
    throw new s('unexpected JWT "iat" (issued at) claim type');
  if (h.iss !== void 0 && typeof h.iss != "string")
    throw new s('unexpected JWT "iss" (issuer) claim type');
  if (h.nbf !== void 0) {
    if (typeof h.nbf != "number")
      throw new s('unexpected JWT "nbf" (not before) claim type');
    if (h.nbf > P + a)
      throw new s('unexpected JWT "nbf" (not before) claim value, timestamp is > now()');
  }
  if (h.aud !== void 0 && typeof h.aud != "string" && !Array.isArray(h.aud))
    throw new s('unexpected JWT "aud" (audience) claim type');
  return { header: f, claims: h, signature: v, key: _, jwt: t };
}
function It(t, e, n) {
  if (t !== void 0) {
    if (n.alg !== t)
      throw new s('unexpected JWT "alg" header parameter');
    return;
  }
  if (Array.isArray(e)) {
    if (!e.includes(n.alg))
      throw new s('unexpected JWT "alg" header parameter');
    return;
  }
  if (n.alg !== "RS256")
    throw new s('unexpected JWT "alg" header parameter');
}
function A(t, e) {
  const { 0: n, length: o } = t.getAll(e);
  if (o > 1)
    throw new s(`"${e}" parameter must be provided only once`);
  return n;
}
const jt = Symbol(), Jt = Symbol();
function Ot(t, e, n, o) {
  if (I(t), j(e), n instanceof URL && (n = n.searchParams), !(n instanceof URLSearchParams))
    throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');
  if (A(n, "response"))
    throw new s('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');
  const a = A(n, "iss"), r = A(n, "state");
  if (!a && t.authorization_response_iss_parameter_supported)
    throw new s('response parameter "iss" (issuer) missing');
  if (a && a !== t.issuer)
    throw new s('unexpected "iss" (issuer) response parameter value');
  switch (o) {
    case void 0:
    case Jt:
      if (r !== void 0)
        throw new s('unexpected "state" response parameter encountered');
      break;
    case jt:
      break;
    default:
      if (!g(o))
        throw new s('"expectedState" must be a non-empty string');
      if (r === void 0)
        throw new s('response parameter "state" missing');
      if (r !== o)
        throw new s('unexpected "state" response parameter value');
  }
  const i = A(n, "error");
  if (i)
    return {
      error: i,
      error_description: A(n, "error_description"),
      error_uri: A(n, "error_uri")
    };
  const c = A(n, "id_token"), p = A(n, "token");
  if (c !== void 0 || p !== void 0)
    throw new T("implicit and hybrid flows are not supported");
  return Tt(new URLSearchParams(n));
}
function zt({
  handleCallback: t
}) {
  const e = je({
    retry: !1,
    queryKey: ["oauth-callback"],
    queryFn: async () => {
      try {
        return await t();
      } catch (n) {
        throw new ze("Could not validate user", {
          cause: n,
          title: "Authentication Error",
          developerHint: "Check the configuration of your authorization provider and ensure all settings such as the callback URL are configured correctly."
        });
      }
    }
  });
  return /* @__PURE__ */ B.jsx(Oe, { to: e.data });
}
class R extends Error {
}
class pe extends R {
  constructor(e, n, o) {
    super(e, o), this.error = n;
  }
}
const M = "code-verifier", q = "oauth-state";
class Dt extends Je {
  constructor(e, n) {
    super(), this.callbackUrlPath = e, this.handleCallback = n;
  }
  getRoutes() {
    return [
      ...super.getRoutes(),
      {
        path: this.callbackUrlPath,
        element: /* @__PURE__ */ B.jsx(Ie, { children: /* @__PURE__ */ B.jsx(zt, { handleCallback: this.handleCallback }) })
      }
    ];
  }
}
class Nt {
  constructor({
    issuer: e,
    audience: n,
    clientId: o,
    redirectToAfterSignUp: a,
    redirectToAfterSignIn: r,
    redirectToAfterSignOut: i,
    basePath: c,
    scopes: p
  }) {
    b(this, "client");
    b(this, "issuer");
    b(this, "authorizationServer");
    b(this, "callbackUrlPath");
    b(this, "logoutRedirectUrlPath");
    b(this, "onAuthorizationUrl");
    b(this, "redirectToAfterSignUp");
    b(this, "redirectToAfterSignIn");
    b(this, "redirectToAfterSignOut");
    b(this, "audience");
    b(this, "scopes");
    b(this, "signRequest", async (e) => {
      const n = await this.getAccessToken();
      return e.headers.set("Authorization", `Bearer ${n}`), e;
    });
    b(this, "signOut", async () => {
      x.setState({
        isAuthenticated: !1,
        isPending: !1,
        profile: void 0,
        providerData: void 0
      });
      const e = await this.getAuthServer(), n = new URL(
        window.location.origin + this.redirectToAfterSignOut
      );
      n.pathname = this.logoutRedirectUrlPath;
      let o;
      e.end_session_endpoint ? (o = new URL(e.end_session_endpoint), o.searchParams.set(
        "post_logout_redirect_uri",
        n.toString()
      )) : o = n;
    });
    b(this, "handleCallback", async () => {
      const e = new URL(window.location.href), n = e.searchParams.get("state"), o = sessionStorage.getItem(q);
      if (sessionStorage.removeItem(q), n !== o)
        throw new R("Invalid state parameter");
      const a = sessionStorage.getItem(M);
      if (sessionStorage.removeItem(M), !a)
        throw new R("No code verifier found in state.");
      const r = await this.getAuthServer(), i = Ot(
        r,
        this.client,
        e.searchParams,
        n ?? void 0
      );
      if (G(i))
        throw se.error("Error validating OAuth response", i), new pe(
          "Error validating OAuth response",
          i
        );
      const c = new URL(e);
      c.pathname = this.callbackUrlPath, c.search = "";
      const p = await At(
        r,
        this.client,
        i,
        c.toString(),
        a
      ), w = await Pt(
        r,
        this.client,
        p
      );
      this.setTokensFromResponse(w);
      const f = await this.getAccessToken(), _ = await (await gt(
        r,
        this.client,
        f
      )).json(), h = {
        sub: _.sub,
        email: _.email,
        name: _.name,
        emailVerified: _.email_verified ?? !1,
        pictureUrl: _.picture
      };
      x.setState({
        isAuthenticated: !0,
        isPending: !1,
        profile: h
      });
      const P = sessionStorage.getItem("redirect-to") ?? "/";
      return sessionStorage.removeItem("redirect-to"), P;
    });
    this.client = {
      client_id: o,
      token_endpoint_auth_method: "none"
    }, this.audience = n, this.issuer = e, this.callbackUrlPath = ie(c, "/oauth/callback"), this.scopes = p ?? ["openid", "profile", "email"];
    const w = ie(c, "/");
    this.logoutRedirectUrlPath = w, this.redirectToAfterSignUp = a ?? w, this.redirectToAfterSignIn = r ?? w, this.redirectToAfterSignOut = i ?? w;
  }
  async getAuthServer() {
    if (!this.authorizationServer) {
      const e = new URL(this.issuer), n = await et(e);
      this.authorizationServer = await tt(
        e,
        n
      );
    }
    return this.authorizationServer;
  }
  /**
   * Sets the tokens from various OAuth responses
   * @param response
   */
  setTokensFromResponse(e) {
    if (G(e))
      throw se.error("Bad Token Response", e), new pe("Bad Token Response", e);
    if (!e.expires_in)
      throw new R("No expires_in in response");
    const n = {
      accessToken: e.access_token,
      refreshToken: e.refresh_token,
      idToken: e.id_token,
      expiresOn: new Date(Date.now() + e.expires_in * 1e3),
      tokenType: e.token_type
    };
    x.setState({
      providerData: n
    });
  }
  async signUp({ redirectTo: e } = {}) {
    return this.authorize({
      redirectTo: e ?? this.redirectToAfterSignUp,
      isSignUp: !0
    });
  }
  async signIn({ redirectTo: e } = {}) {
    return this.authorize({
      redirectTo: e ?? this.redirectToAfterSignIn
    });
  }
  async authorize({
    redirectTo: e,
    isSignUp: n = !1
  }) {
    var v;
    const o = "S256", a = await this.getAuthServer();
    if (!a.authorization_endpoint)
      throw new R("No authorization endpoint");
    const r = nt(), i = await ot(r);
    sessionStorage.setItem(M, r);
    const c = new URL(
      a.authorization_endpoint
    ), p = e.startsWith(window.location.origin) ? e.slice(window.location.origin.length) : e;
    sessionStorage.setItem("redirect-to", p);
    const w = new URL(window.location.origin);
    w.pathname = this.callbackUrlPath, w.search = "", c.searchParams.set("client_id", this.client.client_id), c.searchParams.set("redirect_uri", w.toString()), c.searchParams.set("response_type", "code"), c.searchParams.set("scope", this.scopes.join(" ")), c.searchParams.set("code_challenge", i), c.searchParams.set(
      "code_challenge_method",
      o
    ), this.audience && c.searchParams.set("audience", this.audience), (v = this.onAuthorizationUrl) == null || v.call(this, c, {
      isSignIn: !n,
      isSignUp: n
    });
    const f = rt();
    sessionStorage.setItem(q, f), c.searchParams.set("state", f), location.href = c.href;
  }
  async getAccessToken() {
    const e = await this.getAuthServer(), { providerData: n } = x.getState();
    if (!n)
      throw new R("User is not authenticated");
    const o = n;
    if (new Date(o.expiresOn) < /* @__PURE__ */ new Date()) {
      if (!o.refreshToken)
        return x.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        }), "";
      const a = await yt(
        e,
        this.client,
        o.refreshToken
      ), r = await _t(
        e,
        this.client,
        a
      );
      if (!r.access_token)
        throw new R("No access token in response");
      return this.setTokensFromResponse(r), r.access_token.toString();
    } else
      return o.accessToken;
  }
  getAuthenticationPlugin() {
    return new Dt(this.callbackUrlPath, this.handleCallback);
  }
}
const Vt = (t) => new Nt(t);
export {
  Nt as OpenIDAuthenticationProvider,
  Vt as default
};
//# sourceMappingURL=zudoku.auth-openid.js.map
