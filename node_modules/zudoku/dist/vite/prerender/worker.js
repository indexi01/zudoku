import path from "node:path";
import Piscina from "piscina";
import { matchPath } from "react-router";
import { joinUrl } from "../../lib/util/joinUrl.js";
import { FileWritingResponse } from "./FileWritingResponse.js";
import { InMemoryResponse } from "./InMemoryResponse.js";
const { template, distDir, serverConfigPath, entryServerPath, writeRedirects } = Piscina.workerData;
const server = await import(entryServerPath);
const config = await import(serverConfigPath).then((m) => m.default);
const routes = server.getRoutesByConfig(config);
const { basePath } = config;
const renderPage = async ({ urlPath }) => {
    const filename = urlPath === "/" ? "/index.html" : `${urlPath}.html`;
    const pathname = joinUrl(basePath, urlPath);
    const url = joinUrl("http://localhost", pathname);
    const outputPath = path.join(distDir, filename);
    const request = new Request(url);
    const fileResponse = new FileWritingResponse({
        fileName: outputPath,
        writeRedirects,
    });
    const sharedOpts = { template, request, routes, basePath };
    const isProtectedRoute = config.protectedRoutes?.some((route) => matchPath(route, urlPath));
    let html;
    // For protected routes, we need a second render pass with protection bypassed
    // so we can build a full search index
    if (isProtectedRoute) {
        const bypassResponse = new InMemoryResponse();
        await Promise.all([
            server.render({ ...sharedOpts, response: fileResponse }),
            server.render({
                ...sharedOpts,
                response: bypassResponse,
                bypassProtection: true,
            }),
            fileResponse.isSent(),
            bypassResponse.isSent(),
        ]);
        html = bypassResponse.buffer;
    }
    else {
        await server.render({ ...sharedOpts, response: fileResponse });
        await fileResponse.isSent();
        html = fileResponse.buffer;
    }
    if (fileResponse.statusCode >= 500) {
        throw new Error(`SSR failed with status ${fileResponse.statusCode} for path: ${urlPath}`);
    }
    const redirect = fileResponse.redirectedTo
        ? { from: pathname, to: fileResponse.redirectedTo }
        : undefined;
    return {
        outputPath,
        redirect,
        html,
    };
};
export default renderPage;
//# sourceMappingURL=worker.js.map