import os from "node:os";
import path from "node:path";
import { pathToFileURL } from "node:url";
import { createIndex } from "pagefind";
import colors from "picocolors";
import PiscinaImport from "piscina";
import { logger } from "../../cli/common/logger.js";
import invariant from "../../lib/util/invariant.js";
import { isTTY, throttle, writeLine } from "../reporter.js";
import { generateSitemap } from "../sitemap.js";
const Piscina = PiscinaImport;
const routesToPaths = (routes) => {
    const paths = [];
    const addPaths = (routes) => {
        for (const route of routes) {
            // skip catch-all routes
            if (route.path?.includes("*") || route.path?.includes(":")) {
                continue;
            }
            if (route.path) {
                paths.push(route.path.startsWith("/") ? route.path : `/${route.path}`);
            }
            if (route.children) {
                addPaths(route.children);
            }
        }
    };
    addPaths(routes);
    return paths;
};
export const prerender = async ({ html, dir, basePath = "", serverConfigFilename, writeRedirects = true, }) => {
    const distDir = path.join(dir, "dist", basePath);
    const serverConfigPath = pathToFileURL(path.join(distDir, "server", serverConfigFilename)).href;
    const entryServerPath = pathToFileURL(path.join(distDir, "server/entry.server.js")).href;
    const config = await import(serverConfigPath).then((m) => m.default);
    const module = await import(entryServerPath);
    const getRoutes = module.getRoutesByConfig;
    const routes = getRoutes(config);
    const paths = routesToPaths(routes);
    const start = performance.now();
    const LOG_INTERVAL_MS = 30_000; // Log every 30 seconds
    let lastLogTime = start;
    const writeProgress = throttle((count, total, urlPath) => {
        writeLine(`prerendering (${count}/${total}) ${colors.dim(urlPath)}`);
    });
    if (!isTTY()) {
        logger.info(colors.dim(`prerendering ${paths.length} routes...`));
    }
    let completedCount = 0;
    let pagefindIndex;
    if (config.search?.type === "pagefind") {
        const { index, errors } = await createIndex();
        invariant(index, `Failed to create pagefind index: ${JSON.stringify(errors)}`);
        pagefindIndex = index;
    }
    const pool = new Piscina({
        filename: new URL("./worker.js", import.meta.url).href,
        idleTimeout: 5_000,
        maxThreads: Math.floor(os.cpus().length * 0.8),
        workerData: {
            template: html,
            distDir,
            serverConfigPath,
            entryServerPath,
            writeRedirects,
        },
    });
    const workerResults = await Promise.all(paths.map(async (urlPath) => {
        const result = await pool.run({ urlPath });
        await pagefindIndex?.addHTMLFile({
            url: urlPath,
            content: result.html,
        });
        completedCount++;
        if (isTTY()) {
            writeProgress(completedCount, paths.length, urlPath);
        }
        else {
            const now = performance.now();
            if (now - lastLogTime >= LOG_INTERVAL_MS) {
                logger.info(colors.blue(`prerendered ${completedCount}/${paths.length} routes`));
                lastLogTime = now;
            }
        }
        return result;
    }));
    const pagefindWriteResult = await pagefindIndex?.writeFiles({
        outputPath: path.join(distDir, "pagefind"),
    });
    const seconds = ((performance.now() - start) / 1000).toFixed(1);
    const message = `✓ finished prerendering ${paths.length} routes in ${seconds} seconds`;
    if (isTTY()) {
        writeLine(colors.blue(message + "\n"));
    }
    else {
        logger.info(colors.blue(message));
    }
    if (pagefindWriteResult?.outputPath) {
        logger.info(colors.blue(`✓ pagefind index built: ${pagefindWriteResult.outputPath}`));
    }
    await generateSitemap({
        basePath: config.basePath,
        outputUrls: paths,
        config: config.sitemap,
        baseOutputDir: distDir,
    });
    return workerResults;
};
//# sourceMappingURL=prerender.js.map