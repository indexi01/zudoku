import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { XIcon } from "lucide-react";
import { useCallback, useEffect, useRef } from "react";
import { Controller, useFieldArray, useFormContext, } from "react-hook-form";
import { Card } from "zudoku/ui/Card.js";
import { Checkbox } from "zudoku/ui/Checkbox.js";
import { Autocomplete } from "../../../components/Autocomplete.js";
import { Button } from "../../../ui/Button.js";
import { Input } from "../../../ui/Input.js";
import ParamsGrid, { ParamsGridItem } from "./ParamsGrid.js";
const headerOptions = Object.freeze([
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Authorization",
    "Cache-Control",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Type",
    "Cookie",
    "Date",
    "ETag",
    "Expires",
    "Host",
    "If-Modified-Since",
    "Location",
    "Origin",
    "Pragma",
    "Referer",
    "Set-Cookie",
    "User-Agent",
    "X-Requested-With",
]);
export const Headers = ({ control, headers: schemaHeaders, }) => {
    const { fields, append, remove } = useFieldArray({
        control,
        name: "headers",
    });
    const { setValue, watch } = useFormContext();
    const valueRefs = useRef([]);
    const nameRefs = useRef([]);
    const watchedHeaders = watch("headers");
    const addNewHeader = useCallback(() => {
        append({ name: "", value: "", active: false });
    }, [append]);
    useEffect(() => {
        if (watchedHeaders.length === 0) {
            addNewHeader();
        }
    }, [watchedHeaders, addNewHeader]);
    const handleHeaderEnter = (index) => {
        valueRefs.current[index]?.focus();
    };
    const handleValueEnter = (index) => {
        addNewHeader();
        requestAnimationFrame(() => nameRefs.current[index + 1]?.focus());
    };
    const missingHeaders = schemaHeaders
        .filter((h) => !watchedHeaders.some((f) => f.name === h.name))
        .map(({ name }) => name);
    return (_jsxs("div", { className: "flex flex-col gap-2", children: [_jsx(Card, { className: "overflow-hidden", children: _jsx(ParamsGrid, { children: fields.map((field, i) => {
                        const currentHeader = schemaHeaders.find((h) => h.name === watch(`headers.${i}.name`));
                        return (_jsxs(ParamsGridItem, { children: [_jsxs("div", { className: "flex items-center gap-2 ", children: [_jsx(Controller, { control: control, name: `headers.${i}.active`, render: ({ field }) => (_jsx(Checkbox, { id: `headers.${i}.active`, checked: field.value, onCheckedChange: (checked) => {
                                                    field.onChange(checked);
                                                } })) }), _jsx(Controller, { control: control, name: `headers.${i}.name`, render: ({ field }) => (_jsx(Autocomplete, { ...field, placeholder: "Name", className: "border-0 shadow-none bg-transparent text-xs font-mono", options: [...missingHeaders, ...headerOptions], onEnterPress: () => handleHeaderEnter(i), onChange: (e) => {
                                                    field.onChange(e);
                                                    setValue(`headers.${i}.active`, true);
                                                }, ref: (el) => {
                                                    nameRefs.current[i] = el;
                                                } })) })] }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsx(Controller, { control: control, name: `headers.${i}.value`, render: ({ field }) => {
                                                const hasEnum = currentHeader?.enum && currentHeader.enum.length > 0;
                                                if (!hasEnum) {
                                                    return (_jsx(Input, { placeholder: "Value", className: "w-full border-0 shadow-none text-xs font-mono focus-visible:ring-0", ...field, ref: (el) => {
                                                            valueRefs.current[i] = el;
                                                        }, onKeyDown: (e) => {
                                                            if (e.key === "Enter" &&
                                                                e.currentTarget.value.trim()) {
                                                                handleValueEnter(i);
                                                            }
                                                        }, autoComplete: "off" }));
                                                }
                                                return (_jsx(Autocomplete, { shouldFilter: false, value: field.value, options: currentHeader.enum ?? [], onChange: (e) => {
                                                        field.onChange(e);
                                                        setValue(`headers.${i}.active`, true);
                                                    }, className: "font-mono text-xs border-0" }));
                                            } }), _jsx(Button, { size: "icon", variant: "ghost", className: "text-muted-foreground opacity-0 group-hover:opacity-100 rounded-full w-8 h-7", onClick: () => remove(i), type: "button", children: _jsx(XIcon, { size: 16 }) })] })] }, field.id));
                    }) }) }), _jsx("div", { className: "text-end", children: _jsx(Button, { className: "", onClick: addNewHeader, type: "button", variant: "secondary", children: "Add header" }) })] }));
};
//# sourceMappingURL=Headers.js.map