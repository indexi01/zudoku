import { traverse } from "./traverse.js";
export const removeParameters = ({ names, in: locations, shouldRemove } = {}) => ({ schema }) => traverse(schema, (spec) => {
    // Helper function to filter parameters
    const filterParameters = (parameters) => parameters.filter((p) => {
        if (names?.includes(p.name))
            return false;
        if (locations?.includes(p.in))
            return false;
        if (shouldRemove?.({ parameter: p }))
            return false;
        return true;
    });
    // Handle components.parameters
    if (spec.components?.parameters) {
        spec = {
            ...spec,
            components: {
                ...spec.components,
                parameters: Object.fromEntries(Object.entries(spec.components.parameters).filter(([_, param]) => {
                    const p = param;
                    if (p.$ref)
                        return true; // Skip references
                    return (!names?.includes(p.name) &&
                        !locations?.includes(p.in) &&
                        !shouldRemove?.({ parameter: p }));
                })),
            },
        };
    }
    // Handle paths
    if (spec.paths) {
        const updatedPaths = {};
        for (const [path, pathItem] of Object.entries(spec.paths)) {
            if (typeof pathItem !== "object" || pathItem === null) {
                updatedPaths[path] = pathItem;
                continue;
            }
            let updatedPathItem = { ...pathItem };
            // Handle path-level parameters
            if ("parameters" in updatedPathItem &&
                Array.isArray(updatedPathItem.parameters)) {
                updatedPathItem.parameters = filterParameters(updatedPathItem.parameters);
            }
            // Handle operation-level parameters
            for (const method of Object.keys(updatedPathItem)) {
                const pathItemWithMethods = updatedPathItem;
                if (method === "parameters" ||
                    typeof pathItemWithMethods[method] !== "object") {
                    continue;
                }
                const operation = pathItemWithMethods[method];
                if (Array.isArray(operation.parameters)) {
                    pathItemWithMethods[method] = {
                        ...operation,
                        parameters: filterParameters(operation.parameters),
                    };
                    updatedPathItem = pathItemWithMethods;
                }
            }
            updatedPaths[path] = updatedPathItem;
        }
        spec = { ...spec, paths: updatedPaths };
    }
    return spec;
});
//# sourceMappingURL=removeParameters.js.map