import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState, } from "react";
const ViewportAnchorContext = createContext(undefined);
export const useViewportAnchor = () => {
    const context = useContext(ViewportAnchorContext);
    if (!context) {
        throw new Error("useViewportAnchor must be used within a CurrentAnchorProvider");
    }
    return context;
};
export const useRegisterAnchorElement = () => {
    const elementRef = useRef(null);
    const { observe, unobserve } = useViewportAnchor();
    useEffect(() => {
        const element = elementRef.current;
        if (!element)
            return;
        observe(element);
        return () => unobserve(element);
    }, [observe, unobserve]);
    const setRef = useCallback((el) => {
        if (!el)
            return;
        elementRef.current = el;
    }, []);
    return { ref: setRef };
};
export const ViewportAnchorProvider = ({ children }) => {
    const [activeAnchor, setActiveAnchor] = useState("");
    const observerRef = useRef(null);
    const registeredElements = useRef(new Set());
    const pendingElements = useRef(new Set());
    useEffect(() => {
        observerRef.current = new IntersectionObserver((entries) => {
            for (const entry of entries) {
                if (entry.isIntersecting && entry.target.id) {
                    setActiveAnchor(entry.target.id);
                }
            }
        }, {
            rootMargin: "0px 0px -80% 0px",
            threshold: 0.75,
        });
        // Process any elements that tried to register before observer was ready
        pendingElements.current.forEach((element) => {
            registeredElements.current.add(element);
            observerRef.current?.observe(element);
        });
        pendingElements.current.clear();
        return () => observerRef.current?.disconnect();
    }, []);
    useEffect(() => {
        const elements = registeredElements.current;
        const handleScroll = () => {
            const hasReachedTop = window.scrollY === 0;
            const hasReachedBottom = window.innerHeight + window.scrollY >= document.body.scrollHeight;
            if (hasReachedTop) {
                setActiveAnchor("");
            }
            else if (hasReachedBottom) {
                const lastItem = Array.from(elements).pop();
                const lastId = lastItem?.id ?? "";
                setActiveAnchor(lastId);
            }
        };
        document.addEventListener("scroll", handleScroll);
        return () => {
            elements.clear();
            document.removeEventListener("scroll", handleScroll);
        };
    }, []);
    const observeFns = useMemo(() => {
        return {
            observe: (element) => {
                if (!element)
                    return;
                if (!observerRef.current) {
                    pendingElements.current.add(element);
                    return;
                }
                registeredElements.current.add(element);
                observerRef.current.observe(element);
            },
            unobserve: (element) => {
                if (!element)
                    return;
                pendingElements.current.delete(element);
                registeredElements.current.delete(element);
                observerRef.current?.unobserve(element);
            },
        };
    }, []);
    const value = useMemo(() => ({ activeAnchor, setActiveAnchor, ...observeFns }), [activeAnchor, setActiveAnchor, observeFns]);
    return (_jsx(ViewportAnchorContext, { value: value, children: children }));
};
//# sourceMappingURL=ViewportAnchorContext.js.map