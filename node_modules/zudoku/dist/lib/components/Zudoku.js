import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { MDXProvider } from "@mdx-js/react";
import { useQueryClient } from "@tanstack/react-query";
import { Helmet } from "@zudoku/react-helmet-async";
import { ThemeProvider } from "next-themes";
import { memo, useContext, useEffect, useMemo, useState, } from "react";
import { ErrorBoundary } from "react-error-boundary";
import { Outlet, useLocation, useNavigation } from "react-router";
import { hasHead, isMdxProviderPlugin } from "../core/plugins.js";
import { ZudokuContext, } from "../core/ZudokuContext.js";
import { TopLevelError } from "../errors/TopLevelError.js";
import { StaggeredRenderContext } from "../plugins/openapi/StaggeredRender.js";
import { MdxComponents } from "../util/MdxComponents.js";
import "../util/requestIdleCallbackPolyfill.js";
import { ComponentsProvider, DEFAULT_COMPONENTS, } from "./context/ComponentsContext.js";
import { RouterEventsEmitter } from "./context/RouterEventsEmitter.js";
import { ViewportAnchorProvider } from "./context/ViewportAnchorContext.js";
import { ZudokuProvider } from "./context/ZudokuProvider.js";
import { SlotletProvider } from "./SlotletProvider.js";
let zudokuContext;
const ZudokoInner = memo(({ children, ...props }) => {
    const components = useMemo(() => ({ ...DEFAULT_COMPONENTS, ...props.overrides }), [props.overrides]);
    const location = useLocation();
    const mdxComponents = useMemo(() => {
        const componentsFromPlugins = (props.plugins ?? [])
            .filter(isMdxProviderPlugin)
            .flatMap((plugin) => plugin.getMdxComponents ? [plugin.getMdxComponents()] : []);
        return {
            ...componentsFromPlugins.reduce((acc, curr) => ({ ...acc, ...curr }), {}),
            ...MdxComponents,
            ...props.mdx?.components,
        };
    }, [props.mdx?.components, props.plugins]);
    const { stagger } = useContext(StaggeredRenderContext);
    const [didNavigate, setDidNavigate] = useState(false);
    const staggeredValue = useMemo(() => (didNavigate ? { stagger: true } : { stagger }), [stagger, didNavigate]);
    const navigation = useNavigation();
    const queryClient = useQueryClient();
    useEffect(() => {
        if (didNavigate) {
            return;
        }
        setDidNavigate(true);
    }, [didNavigate, navigation.location]);
    if (!zudokuContext) {
        zudokuContext = new ZudokuContext(props, queryClient);
    }
    const heads = props.plugins
        ?.flatMap((plugin) => hasHead(plugin) ? (plugin.getHead?.({ location }) ?? []) : [])
        // eslint-disable-next-line react/no-array-index-key
        .map((entry, i) => _jsx(Helmet, { children: entry }, i));
    return (_jsxs(_Fragment, { children: [heads, _jsx(StaggeredRenderContext.Provider, { value: staggeredValue, children: _jsxs(ZudokuProvider, { context: zudokuContext, children: [_jsx(RouterEventsEmitter, {}), _jsx(MDXProvider, { components: mdxComponents, children: _jsx(ThemeProvider, { attribute: "class", disableTransitionOnChange: true, children: _jsx(ComponentsProvider, { value: components, children: _jsx(SlotletProvider, { slotlets: props.slotlets, children: _jsx(ViewportAnchorProvider, { children: children ?? _jsx(Outlet, {}) }) }) }) }) })] }) })] }));
});
ZudokoInner.displayName = "ZudokoInner";
const Zudoku = (props) => {
    return (_jsx(ErrorBoundary, { FallbackComponent: TopLevelError, children: _jsx(ZudokoInner, { ...props }) }));
};
Zudoku.displayName = "Zudoku";
export { Zudoku };
//# sourceMappingURL=Zudoku.js.map