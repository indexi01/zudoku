import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as Collapsible from "@radix-ui/react-collapsible";
import { deepEqual } from "fast-equals";
import { ChevronRightIcon } from "lucide-react";
import { memo, useEffect, useState } from "react";
import { NavLink, useMatch } from "react-router";
import { Button } from "zudoku/ui/Button.js";
import { cn } from "../../util/cn.js";
import { joinPath } from "../../util/joinPath.js";
import { navigationListItem, SidebarItem } from "./SidebarItem.js";
import { useIsCategoryOpen } from "./utils.js";
const SidebarCategoryInner = ({ category, onRequestClose, }) => {
    const isCategoryOpen = useIsCategoryOpen(category);
    const [hasInteracted, setHasInteracted] = useState(false);
    const isCollapsible = category.collapsible ?? true;
    const isCollapsed = category.collapsed ?? true;
    const isDefaultOpen = Boolean(!isCollapsible || !isCollapsed || isCategoryOpen);
    const [open, setOpen] = useState(isDefaultOpen);
    const isActive = useMatch(category.link?.id ?? "");
    useEffect(() => {
        // this is triggered when an item from the sidebar is clicked
        // and the sidebar, enclosing this item, is not opened
        if (isCategoryOpen) {
            setOpen(true);
        }
    }, [isCategoryOpen]);
    const ToggleButton = isCollapsible && (_jsx(Button, { onClick: (e) => {
            e.preventDefault();
            setOpen((prev) => !prev);
            setHasInteracted(true);
        }, variant: "ghost", size: "icon", className: "size-6 hover:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l-5))] hover:dark:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l+5))]", children: _jsx(ChevronRightIcon, { size: 16, className: cn(hasInteracted && "transition", "shrink-0 group-data-[state=open]:rotate-90") }) }));
    const icon = category.icon && (_jsx(category.icon, { size: 16, className: cn("align-[-0.125em] ", isActive && "text-primary") }));
    const styles = navigationListItem({
        className: [
            "group text-start font-medium",
            isCollapsible || typeof category.link !== "undefined"
                ? "cursor-pointer"
                : "cursor-default hover:bg-transparent",
        ],
    });
    return (_jsxs(Collapsible.Root, { className: "flex flex-col", defaultOpen: isDefaultOpen, open: open, onOpenChange: () => setOpen(true), children: [_jsx(Collapsible.Trigger, { className: "group", asChild: true, disabled: !isCollapsible, children: category.link?.type === "doc" ? (_jsxs(NavLink, { to: joinPath(category.link.id), className: styles, onClick: () => {
                        setHasInteracted(true);
                        // if it is the current path and closed then open it because there's no path change to trigger the open
                        if (isActive && !open) {
                            setOpen(true);
                        }
                    }, children: [icon, _jsxs("div", { className: "flex items-center gap-2 justify-between w-full text-foreground/80 group-aria-[current='page']:text-primary", children: [_jsx("div", { className: "truncate", children: category.label }), ToggleButton] })] })) : (_jsxs("div", { onClick: () => setHasInteracted(true), className: styles, children: [icon, _jsxs("div", { className: "flex items-center justify-between w-full", children: [_jsx("div", { className: "flex gap-2 truncate w-full", children: category.label }), ToggleButton] })] })) }), _jsx(Collapsible.Content, { className: cn(
                // CollapsibleContent class is used to animate and it should only be applied when the user has triggered the toggle
                hasInteracted && "CollapsibleContent", category.items.length === 0 && "hidden", "ms-6 my-1"), children: _jsx("ul", { className: "relative after:absolute after:-left-[--padding-nav-item] after:translate-x-[1.5px] after:top-0 after:bottom-0 after:w-px after:bg-border", children: category.items.map((item) => (_jsx(SidebarItem, { onRequestClose: onRequestClose, item: item }, ("id" in item ? item.id : "") +
                        ("href" in item ? item.href : "") +
                        item.label))) }) })] }));
};
export const SidebarCategory = memo(SidebarCategoryInner, deepEqual);
SidebarCategory.displayName = "SidebarCategory";
//# sourceMappingURL=SidebarCategory.js.map