import { glob } from "glob";
import matter from "gray-matter";
import fs from "node:fs/promises";
const extractTitleFromContent = (content) => content.match(/^\s*#\s(.*)$/m)?.at(1);
const isSidebarItem = (item) => item !== undefined;
export class SidebarManager {
    sidebars;
    switchQueue = [];
    constructor(rootDir, sidebarConfig) {
        this.sidebars = Object.entries(sidebarConfig ?? {}).map(([parent, items]) => new SidebarClass(this, rootDir, parent, items));
    }
    async resolveSidebars() {
        await Promise.all(this.sidebars.map((sidebar) => sidebar.resolve()));
        // switch all collected items
        for (const { from, to, item } of this.switchQueue) {
            const fromSidebar = this.sidebars.find((s) => s.parent === from);
            const toSidebar = this.sidebars.find((s) => s.parent === to);
            if (!fromSidebar || !toSidebar) {
                throw new Error(`Sidebar ${from} or ${to} not found`);
            }
            fromSidebar.resolvedItems = fromSidebar.resolvedItems.filter((resolvedItem) => resolvedItem !== item);
            toSidebar.resolvedItems.push(item);
        }
        return Object.fromEntries(this.sidebars.map((sidebar) => [sidebar.parent, sidebar.resolvedItems]));
    }
    switchSidebar(from, to, item) {
        this.switchQueue.push({ from, to, item });
    }
}
export class SidebarClass {
    manager;
    rootDir;
    parent;
    items;
    resolvedItems = [];
    constructor(manager, rootDir, parent, items) {
        this.manager = manager;
        this.rootDir = rootDir;
        this.parent = parent;
        this.items = items;
    }
    async resolve() {
        const resolvedSidebar = (await Promise.all(this.items.map((item) => this.resolveItem(item)))).filter(isSidebarItem);
        this.resolvedItems = resolvedSidebar;
    }
    async resolveDoc(id, categoryLabel) {
        const foundMatches = await glob(`/**/${id}.{md,mdx}`, {
            ignore: ["**/node_modules/**", "**/.git/**", "**/dist/**"],
            root: this.rootDir,
        });
        if (foundMatches.length === 0) {
            throw new Error(`File not found for document '${id}'. Check your sidebar configuration.`);
        }
        const file = await fs.readFile(foundMatches.at(0));
        const { data, content } = matter(file);
        const label = data.sidebar_label ??
            data.title ??
            extractTitleFromContent(content) ??
            id;
        const icon = data.sidebar_icon;
        const doc = {
            type: "doc",
            id,
            label,
            icon,
            categoryLabel,
        };
        if (data.sidebar && data.sidebar !== this.parent) {
            this.manager.switchSidebar(this.parent, data.sidebar, doc);
            return undefined;
        }
        return doc;
    }
    async resolveLink(id) {
        const doc = await this.resolveDoc(id);
        return doc
            ? { type: "doc", id: id, label: doc.label, icon: doc.icon }
            : undefined;
    }
    async resolveItemCategoryLinkDoc(item) {
        if (typeof item === "string") {
            return this.resolveLink(item);
        }
        const doc = await this.resolveDoc(item.id);
        return doc ? { ...item, label: doc.label, icon: doc.icon } : undefined;
    }
    async resolveSidebarItemDoc(item, categoryLabel) {
        if (typeof item === "string") {
            return this.resolveDoc(item, categoryLabel);
        }
        const doc = await this.resolveDoc(item.id, categoryLabel);
        return doc ? { ...doc, ...item } : undefined;
    }
    async resolveItem(item, categoryLabel) {
        if (typeof item === "string") {
            return this.resolveDoc(item, categoryLabel);
        }
        switch (item.type) {
            case "doc":
                return this.resolveSidebarItemDoc(item, categoryLabel);
            case "link":
                return item;
            case "category": {
                const categoryItem = item;
                const items = (await Promise.all(categoryItem.items.map((subItem) => this.resolveItem(subItem, categoryItem.label)))).filter((item) => item !== undefined);
                const resolvedLink = categoryItem.link
                    ? await this.resolveItemCategoryLinkDoc(categoryItem.link)
                    : undefined;
                return {
                    ...categoryItem,
                    items,
                    link: resolvedLink,
                };
            }
        }
    }
}
//# sourceMappingURL=SidebarSchema.js.map