{"version":3,"sources":["../src/helpers/code-builder.ts"],"names":[],"mappings":";AAAA,IAAM,gCAAgC;AACtC,IAAM,oBAAoB;AAkBnB,IAAM,cAAN,MAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,EAavB,YAAY,EAAE,QAAQ,KAAK,IAAwB,CAAC,GAAG;AAZvD,0BAAkC,CAAC;AAEnC,gBAAiB,CAAC;AAElB,gCAA+B;AAE/B,oBAAW;AAcX;AAAA;AAAA;AAAA,sBAAa,CAAC,MAAc,mBAAmB,MAAM;AACnD,YAAM,SAAS,KAAK,qBAAqB,OAAO,gBAAgB;AAChE,aAAO,GAAG,MAAM,GAAG,IAAI;AAAA,IACzB;AAKA;AAAA;AAAA;AAAA,mBAAU,CAAC,MAAc,qBAA8B;AACrD,YAAM,UAAU,KAAK,WAAW,MAAM,gBAAgB;AACtD,WAAK,KAAK,QAAQ,OAAO;AAAA,IAC3B;AAKA;AAAA;AAAA;AAAA,gBAAO,CAAC,MAAc,qBAA8B;AAClD,YAAM,UAAU,KAAK,WAAW,MAAM,gBAAgB;AACtD,WAAK,KAAK,KAAK,OAAO;AAAA,IACxB;AAKA;AAAA;AAAA;AAAA,iBAAQ,MAAM;AACZ,WAAK,KAAK,KAAK,EAAE;AAAA,IACnB;AAKA;AAAA;AAAA;AAAA,gBAAO,MAAM;AACX,YAAM,iBAAiB,KAAK,KAAK,KAAK,KAAK,QAAQ;AACnD,YAAM,iBAAiB,KAAK,eAAe,OAAO,CAAC,aAAa,aAAa,SAAS,WAAW,GAAG,cAAc;AAClH,aAAO;AAAA,IACT;AAMA;AAAA;AAAA;AAAA;AAAA,4BAAmB,CAAC,kBAAiC;AACnD,WAAK,iBAAiB,CAAC,GAAG,KAAK,gBAAgB,aAAa;AAAA,IAC9D;AAlDE,SAAK,uBAAuB,UAAU;AACtC,SAAK,WAAW,QAAQ;AAAA,EAC1B;AAiDF","sourcesContent":["const DEFAULT_INDENTATION_CHARACTER = '';\nconst DEFAULT_LINE_JOIN = '\\n';\n\nexport type PostProcessor = (unreplacedCode: string) => string;\n\nexport interface CodeBuilderOptions {\n  /**\n   * Desired indentation character for aggregated lines of code\n   * @default ''\n   */\n  indent?: string;\n\n  /**\n   * Desired character to join each line of code\n   * @default \\n\n   */\n  join?: string;\n}\n\nexport class CodeBuilder {\n  postProcessors: PostProcessor[] = [];\n\n  code: string[] = [];\n\n  indentationCharacter: string = DEFAULT_INDENTATION_CHARACTER;\n\n  lineJoin = DEFAULT_LINE_JOIN;\n\n  /**\n   * Helper object to format and aggragate lines of code.\n   * Lines are aggregated in a `code` array, and need to be joined to obtain a proper code snippet.\n   */\n  constructor({ indent, join }: CodeBuilderOptions = {}) {\n    this.indentationCharacter = indent || DEFAULT_INDENTATION_CHARACTER;\n    this.lineJoin = join ?? DEFAULT_LINE_JOIN;\n  }\n\n  /**\n   * Add given indentation level to given line of code\n   */\n  indentLine = (line: string, indentationLevel = 0) => {\n    const indent = this.indentationCharacter.repeat(indentationLevel);\n    return `${indent}${line}`;\n  };\n\n  /**\n   * Add the line at the beginning of the current lines\n   */\n  unshift = (line: string, indentationLevel?: number) => {\n    const newLine = this.indentLine(line, indentationLevel);\n    this.code.unshift(newLine);\n  };\n\n  /**\n   * Add the line at the end of the current lines\n   */\n  push = (line: string, indentationLevel?: number) => {\n    const newLine = this.indentLine(line, indentationLevel);\n    this.code.push(newLine);\n  };\n\n  /**\n   * Add an empty line at the end of current lines\n   */\n  blank = () => {\n    this.code.push('');\n  };\n\n  /**\n   * Concatenate all current lines using the given lineJoin, then apply any replacers that may have been added\n   */\n  join = () => {\n    const unreplacedCode = this.code.join(this.lineJoin);\n    const replacedOutput = this.postProcessors.reduce((accumulator, replacer) => replacer(accumulator), unreplacedCode);\n    return replacedOutput;\n  };\n\n  /**\n   * Often when writing modules you may wish to add a literal tag or bit of metadata that you wish to transform after other processing as a final step.\n   * To do so, you can provide a PostProcessor function and it will be run automatically for you when you call `join()` later on.\n   */\n  addPostProcessor = (postProcessor: PostProcessor) => {\n    this.postProcessors = [...this.postProcessors, postProcessor];\n  };\n}\n"]}