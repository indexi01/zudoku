import {
  r
} from "./chunk-FKBLCK2M.js";
import {
  f
} from "./chunk-JGATS2Z3.js";
import {
  Content3 as Content,
  Root3 as Root,
  Trigger3 as Trigger,
  Ts,
  _t,
  ce,
  et as et2,
  j,
  l,
  l2,
  p2 as p,
  y
} from "./chunk-6HIU6SLM.js";
import {
  Bt,
  N,
  dn,
  et,
  on
} from "./chunk-DCQBGROG.js";
import {
  ChevronRight,
  ExternalLink,
  Slot,
  We
} from "./chunk-VSGZQHBI.js";
import {
  ae
} from "./chunk-T7IJB7TU.js";
import {
  require_react
} from "./chunk-TJE776R7.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/zudoku/lib/CategoryHeading-D06WK_Wo.js
var e = ({
  children: t2,
  className: r2
}) => ae.jsx("div", { className: y("text-sm font-semibold text-primary mb-2", r2), children: t2 });

// node_modules/zudoku/lib/Markdown-C5h6bxbE.js
var import_react = __toESM(require_react(), 1);

// node_modules/zudoku/lib/ui/Stepper.js
var t = ({ children: e2 }) => ae.jsx("div", { className: "stepper", children: e2 });

// node_modules/zudoku/lib/Markdown-C5h6bxbE.js
var Yi = -1;
var On = 0;
var An = 1;
var _n = 2;
var Lr = 3;
var Rr = 4;
var Dr = 5;
var Pr = 6;
var qi = 7;
var ji = 8;
var du = typeof self == "object" ? self : globalThis;
var bo = (e2, t2) => {
  const n = (u, a) => (e2.set(a, u), u), r2 = (u) => {
    if (e2.has(u))
      return e2.get(u);
    const [a, i] = t2[u];
    switch (a) {
      case On:
      case Yi:
        return n(i, u);
      case An: {
        const o = n([], u);
        for (const l3 of i)
          o.push(r2(l3));
        return o;
      }
      case _n: {
        const o = n({}, u);
        for (const [l3, c] of i)
          o[r2(l3)] = r2(c);
        return o;
      }
      case Lr:
        return n(new Date(i), u);
      case Rr: {
        const { source: o, flags: l3 } = i;
        return n(new RegExp(o, l3), u);
      }
      case Dr: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l3, c] of i)
          o.set(r2(l3), r2(c));
        return o;
      }
      case Pr: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l3 of i)
          o.add(r2(l3));
        return o;
      }
      case qi: {
        const { name: o, message: l3 } = i;
        return n(new du[o](l3), u);
      }
      case ji:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
    }
    return n(new du[a](i), u);
  };
  return r2;
};
var mu = (e2) => bo(/* @__PURE__ */ new Map(), e2)(0);
var ct = "";
var { toString: Ao } = {};
var { keys: _o } = Object;
var Rt = (e2) => {
  const t2 = typeof e2;
  if (t2 !== "object" || !e2)
    return [On, t2];
  const n = Ao.call(e2).slice(8, -1);
  switch (n) {
    case "Array":
      return [An, ct];
    case "Object":
      return [_n, ct];
    case "Date":
      return [Lr, ct];
    case "RegExp":
      return [Rr, ct];
    case "Map":
      return [Dr, ct];
    case "Set":
      return [Pr, ct];
  }
  return n.includes("Array") ? [An, n] : n.includes("Error") ? [qi, n] : [_n, n];
};
var on2 = ([e2, t2]) => e2 === On && (t2 === "function" || t2 === "symbol");
var Co = (e2, t2, n, r2) => {
  const u = (i, o) => {
    const l3 = r2.push(i) - 1;
    return n.set(o, l3), l3;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l3] = Rt(i);
    switch (o) {
      case On: {
        let h = i;
        switch (l3) {
          case "bigint":
            o = ji, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e2)
              throw new TypeError("unable to serialize " + l3);
            h = null;
            break;
          case "undefined":
            return u([Yi], i);
        }
        return u([o, h], i);
      }
      case An: {
        if (l3)
          return u([l3, [...i]], i);
        const h = [], f2 = u([o, h], i);
        for (const p2 of i)
          h.push(a(p2));
        return f2;
      }
      case _n: {
        if (l3)
          switch (l3) {
            case "BigInt":
              return u([l3, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l3, i.valueOf()], i);
          }
        if (t2 && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f2 = u([o, h], i);
        for (const p2 of _o(i))
          (e2 || !on2(Rt(i[p2]))) && h.push([a(p2), a(i[p2])]);
        return f2;
      }
      case Lr:
        return u([o, i.toISOString()], i);
      case Rr: {
        const { source: h, flags: f2 } = i;
        return u([o, { source: h, flags: f2 }], i);
      }
      case Dr: {
        const h = [], f2 = u([o, h], i);
        for (const [p2, d] of i)
          (e2 || !(on2(Rt(p2)) || on2(Rt(d)))) && h.push([a(p2), a(d)]);
        return f2;
      }
      case Pr: {
        const h = [], f2 = u([o, h], i);
        for (const p2 of i)
          (e2 || !on2(Rt(p2))) && h.push(a(p2));
        return f2;
      }
    }
    const { message: c } = i;
    return u([o, { name: l3, message: c }], i);
  };
  return a;
};
var pu = (e2, { json: t2, lossy: n } = {}) => {
  const r2 = [];
  return Co(!(t2 || n), !!t2, /* @__PURE__ */ new Map(), r2)(e2), r2;
};
var Eu = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e2, t2) => t2 && ("json" in t2 || "lossy" in t2) ? mu(pu(e2, t2)) : structuredClone(e2)
) : (e2, t2) => mu(pu(e2, t2));
var Zt = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t2, n, r2) {
    this.property = t2, this.normal = n, r2 && (this.space = r2);
  }
};
Zt.prototype.property = {};
Zt.prototype.normal = {};
Zt.prototype.space = null;
function Vi(e2, t2) {
  const n = {}, r2 = {};
  let u = -1;
  for (; ++u < e2.length; )
    Object.assign(n, e2[u].property), Object.assign(r2, e2[u].normal);
  return new Zt(n, r2, t2);
}
function $t(e2) {
  return e2.toLowerCase();
}
var ke = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t2, n) {
    this.property = t2, this.attribute = n;
  }
};
ke.prototype.space = null;
ke.prototype.boolean = false;
ke.prototype.booleanish = false;
ke.prototype.overloadedBoolean = false;
ke.prototype.number = false;
ke.prototype.commaSeparated = false;
ke.prototype.spaceSeparated = false;
ke.prototype.commaOrSpaceSeparated = false;
ke.prototype.mustUseProperty = false;
ke.prototype.defined = false;
var So = 0;
var W = ut();
var se = ut();
var Wi = ut();
var P = ut();
var re = ut();
var Et = ut();
var Ce = ut();
function ut() {
  return 2 ** ++So;
}
var fr = Object.freeze(Object.defineProperty({
  __proto__: null,
  boolean: W,
  booleanish: se,
  commaOrSpaceSeparated: Ce,
  commaSeparated: Et,
  number: P,
  overloadedBoolean: Wi,
  spaceSeparated: re
}, Symbol.toStringTag, { value: "Module" }));
var qn = Object.keys(fr);
var wr = class extends ke {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t2, n, r2, u) {
    let a = -1;
    if (super(t2, n), gu(this, "space", u), typeof r2 == "number")
      for (; ++a < qn.length; ) {
        const i = qn[a];
        gu(this, qn[a], (r2 & fr[i]) === fr[i]);
      }
  }
};
wr.prototype.defined = true;
function gu(e2, t2, n) {
  n && (e2[t2] = n);
}
var xo = {}.hasOwnProperty;
function Ct(e2) {
  const t2 = {}, n = {};
  let r2;
  for (r2 in e2.properties)
    if (xo.call(e2.properties, r2)) {
      const u = e2.properties[r2], a = new wr(
        r2,
        e2.transform(e2.attributes || {}, r2),
        u,
        e2.space
      );
      e2.mustUseProperty && e2.mustUseProperty.includes(r2) && (a.mustUseProperty = true), t2[r2] = a, n[$t(r2)] = r2, n[$t(a.attribute)] = r2;
    }
  return new Zt(t2, n, e2.space);
}
var Gi = Ct({
  space: "xlink",
  transform(e2, t2) {
    return "xlink:" + t2.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
var Qi = Ct({
  space: "xml",
  transform(e2, t2) {
    return "xml:" + t2.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function $i(e2, t2) {
  return t2 in e2 ? e2[t2] : t2;
}
function Xi(e2, t2) {
  return $i(e2, t2.toLowerCase());
}
var Ki = Ct({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Xi,
  properties: { xmlns: null, xmlnsXLink: null }
});
var Ji = Ct({
  transform(e2, t2) {
    return t2 === "role" ? t2 : "aria-" + t2.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: se,
    ariaAutoComplete: null,
    ariaBusy: se,
    ariaChecked: se,
    ariaColCount: P,
    ariaColIndex: P,
    ariaColSpan: P,
    ariaControls: re,
    ariaCurrent: null,
    ariaDescribedBy: re,
    ariaDetails: null,
    ariaDisabled: se,
    ariaDropEffect: re,
    ariaErrorMessage: null,
    ariaExpanded: se,
    ariaFlowTo: re,
    ariaGrabbed: se,
    ariaHasPopup: null,
    ariaHidden: se,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: re,
    ariaLevel: P,
    ariaLive: null,
    ariaModal: se,
    ariaMultiLine: se,
    ariaMultiSelectable: se,
    ariaOrientation: null,
    ariaOwns: re,
    ariaPlaceholder: null,
    ariaPosInSet: P,
    ariaPressed: se,
    ariaReadOnly: se,
    ariaRelevant: null,
    ariaRequired: se,
    ariaRoleDescription: re,
    ariaRowCount: P,
    ariaRowIndex: P,
    ariaRowSpan: P,
    ariaSelected: se,
    ariaSetSize: P,
    ariaSort: null,
    ariaValueMax: P,
    ariaValueMin: P,
    ariaValueNow: P,
    ariaValueText: null,
    role: null
  }
});
var Io = Ct({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Xi,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Et,
    acceptCharset: re,
    accessKey: re,
    action: null,
    allow: null,
    allowFullScreen: W,
    allowPaymentRequest: W,
    allowUserMedia: W,
    alt: null,
    as: null,
    async: W,
    autoCapitalize: null,
    autoComplete: re,
    autoFocus: W,
    autoPlay: W,
    blocking: re,
    capture: null,
    charSet: null,
    checked: W,
    cite: null,
    className: re,
    cols: P,
    colSpan: null,
    content: null,
    contentEditable: se,
    controls: W,
    controlsList: re,
    coords: P | Et,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: W,
    defer: W,
    dir: null,
    dirName: null,
    disabled: W,
    download: Wi,
    draggable: se,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: W,
    formTarget: null,
    headers: re,
    height: P,
    hidden: W,
    high: P,
    href: null,
    hrefLang: null,
    htmlFor: re,
    httpEquiv: re,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: W,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: W,
    itemId: null,
    itemProp: re,
    itemRef: re,
    itemScope: W,
    itemType: re,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: W,
    low: P,
    manifest: null,
    max: null,
    maxLength: P,
    media: null,
    method: null,
    min: null,
    minLength: P,
    multiple: W,
    muted: W,
    name: null,
    nonce: null,
    noModule: W,
    noValidate: W,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: W,
    optimum: P,
    pattern: null,
    ping: re,
    placeholder: null,
    playsInline: W,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: W,
    referrerPolicy: null,
    rel: re,
    required: W,
    reversed: W,
    rows: P,
    rowSpan: P,
    sandbox: re,
    scope: null,
    scoped: W,
    seamless: W,
    selected: W,
    shadowRootClonable: W,
    shadowRootDelegatesFocus: W,
    shadowRootMode: null,
    shape: null,
    size: P,
    sizes: null,
    slot: null,
    span: P,
    spellCheck: se,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: P,
    step: null,
    style: null,
    tabIndex: P,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: W,
    useMap: null,
    value: se,
    width: P,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: re,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: P,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: P,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: W,
    // Lists. Use CSS to reduce space between items instead
    declare: W,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: P,
    // `<img>` and `<object>`
    leftMargin: P,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: P,
    // `<body>`
    marginWidth: P,
    // `<body>`
    noResize: W,
    // `<frame>`
    noHref: W,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: W,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: W,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: P,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: se,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: P,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: P,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: W,
    disableRemotePlayback: W,
    prefix: null,
    property: null,
    results: P,
    security: null,
    unselectable: null
  }
});
var ko = Ct({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: $i,
  properties: {
    about: Ce,
    accentHeight: P,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: P,
    amplitude: P,
    arabicForm: null,
    ascent: P,
    attributeName: null,
    attributeType: null,
    azimuth: P,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: P,
    by: null,
    calcMode: null,
    capHeight: P,
    className: re,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: P,
    diffuseConstant: P,
    direction: null,
    display: null,
    dur: null,
    divisor: P,
    dominantBaseline: null,
    download: W,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: P,
    enableBackground: null,
    end: null,
    event: null,
    exponent: P,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: P,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Et,
    g2: Et,
    glyphName: Et,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: P,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: P,
    horizOriginX: P,
    horizOriginY: P,
    id: null,
    ideographic: P,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: P,
    k: P,
    k1: P,
    k2: P,
    k3: P,
    k4: P,
    kernelMatrix: Ce,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: P,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: P,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: P,
    overlineThickness: P,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: P,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: re,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: P,
    pointsAtY: P,
    pointsAtZ: P,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ce,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ce,
    rev: Ce,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ce,
    requiredFeatures: Ce,
    requiredFonts: Ce,
    requiredFormats: Ce,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: P,
    specularExponent: P,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: P,
    strikethroughThickness: P,
    string: null,
    stroke: null,
    strokeDashArray: Ce,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: P,
    strokeOpacity: P,
    strokeWidth: null,
    style: null,
    surfaceScale: P,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ce,
    tabIndex: P,
    tableValues: null,
    target: null,
    targetX: P,
    targetY: P,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ce,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: P,
    underlineThickness: P,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: P,
    values: null,
    vAlphabetic: P,
    vMathematical: P,
    vectorEffect: null,
    vHanging: P,
    vIdeographic: P,
    version: null,
    vertAdvY: P,
    vertOriginX: P,
    vertOriginY: P,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: P,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var yo = /^data[-\w.:]+$/i;
var Tu = /-[a-z]/g;
var No = /[A-Z]/g;
function Mr(e2, t2) {
  const n = $t(t2);
  let r2 = t2, u = ke;
  if (n in e2.normal)
    return e2.property[e2.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && yo.test(t2)) {
    if (t2.charAt(4) === "-") {
      const a = t2.slice(5).replace(Tu, Lo);
      r2 = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t2.slice(4);
      if (!Tu.test(a)) {
        let i = a.replace(No, Oo);
        i.charAt(0) !== "-" && (i = "-" + i), t2 = "data" + i;
      }
    }
    u = wr;
  }
  return new u(r2, t2);
}
function Oo(e2) {
  return "-" + e2.toLowerCase();
}
function Lo(e2) {
  return e2.charAt(1).toUpperCase();
}
var Ln = Vi([Qi, Gi, Ki, Ji, Io], "html");
var en = Vi([Qi, Gi, Ki, Ji, ko], "svg");
function bu(e2) {
  const t2 = [], n = String(e2 || "");
  let r2 = n.indexOf(","), u = 0, a = false;
  for (; !a; ) {
    r2 === -1 && (r2 = n.length, a = true);
    const i = n.slice(u, r2).trim();
    (i || !a) && t2.push(i), u = r2 + 1, r2 = n.indexOf(",", u);
  }
  return t2;
}
function Zi(e2, t2) {
  const n = {};
  return (e2[e2.length - 1] === "" ? [...e2, ""] : e2).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === false ? "" : " ")
  ).trim();
}
var Au = /[#.]/g;
function Ro(e2, t2) {
  const n = e2 || "", r2 = {};
  let u = 0, a, i;
  for (; u < n.length; ) {
    Au.lastIndex = u;
    const o = Au.exec(n), l3 = n.slice(u, o ? o.index : n.length);
    l3 && (a ? a === "#" ? r2.id = l3 : Array.isArray(r2.className) ? r2.className.push(l3) : r2.className = [l3] : i = l3, u += l3.length), o && (a = o[0], u++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t2 || "div",
    properties: r2,
    children: []
  };
}
function _u(e2) {
  const t2 = String(e2 || "").trim();
  return t2 ? t2.split(/[ \t\n\r\f]+/g) : [];
}
function ea(e2) {
  return e2.join(" ").trim();
}
var hr = {}.hasOwnProperty;
function ta(e2, t2, n) {
  const r2 = n && Mo(n);
  function u(a, i, ...o) {
    let l3 = -1, c;
    if (a == null) {
      c = { type: "root", children: [] };
      const h = (
        /** @type {Child} */
        i
      );
      o.unshift(h);
    } else if (c = Ro(a, t2), c.tagName = c.tagName.toLowerCase(), r2 && hr.call(r2, c.tagName) && (c.tagName = r2[c.tagName]), Do(i))
      o.unshift(i);
    else {
      let h;
      for (h in i)
        hr.call(i, h) && Po(e2, c.properties, h, i[h]);
    }
    for (; ++l3 < o.length; )
      dr(c.children, o[l3]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return u;
}
function Do(e2) {
  if (e2 === null || typeof e2 != "object" || Array.isArray(e2))
    return true;
  if (typeof e2.type != "string") return false;
  const t2 = (
    /** @type {Record<string, unknown>} */
    e2
  ), n = Object.keys(e2);
  for (const r2 of n) {
    const u = t2[r2];
    if (u && typeof u == "object") {
      if (!Array.isArray(u)) return true;
      const a = (
        /** @type {Array<unknown>} */
        u
      );
      for (const i of a)
        if (typeof i != "number" && typeof i != "string")
          return true;
    }
  }
  return !!("children" in e2 && Array.isArray(e2.children));
}
function Po(e2, t2, n, r2) {
  const u = Mr(e2, n);
  let a = -1, i;
  if (r2 != null) {
    if (typeof r2 == "number") {
      if (Number.isNaN(r2)) return;
      i = r2;
    } else typeof r2 == "boolean" ? i = r2 : typeof r2 == "string" ? u.spaceSeparated ? i = _u(r2) : u.commaSeparated ? i = bu(r2) : u.commaOrSpaceSeparated ? i = _u(bu(r2).join(" ")) : i = Cu(u, u.property, r2) : Array.isArray(r2) ? i = r2.concat() : i = u.property === "style" ? wo(r2) : String(r2);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++a < i.length; ) {
        const l3 = (
          /** @type {number | string} */
          Cu(u, u.property, i[a])
        );
        o[a] = l3;
      }
      i = o;
    }
    if (u.property === "className" && Array.isArray(t2.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t2.className.concat(o);
    }
    t2[u.property] = i;
  }
}
function dr(e2, t2) {
  let n = -1;
  if (t2 != null) if (typeof t2 == "string" || typeof t2 == "number")
    e2.push({ type: "text", value: String(t2) });
  else if (Array.isArray(t2))
    for (; ++n < t2.length; )
      dr(e2, t2[n]);
  else if (typeof t2 == "object" && "type" in t2)
    t2.type === "root" ? dr(e2, t2.children) : e2.push(t2);
  else
    throw new Error("Expected node, nodes, or string, got `" + t2 + "`");
}
function Cu(e2, t2, n) {
  if (typeof n == "string") {
    if (e2.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e2.boolean || e2.overloadedBoolean) && (n === "" || $t(n) === $t(t2)))
      return true;
  }
  return n;
}
function wo(e2) {
  const t2 = [];
  let n;
  for (n in e2)
    hr.call(e2, n) && t2.push([n, e2[n]].join(": "));
  return t2.join("; ");
}
function Mo(e2) {
  const t2 = {};
  let n = -1;
  for (; ++n < e2.length; )
    t2[e2[n].toLowerCase()] = e2[n];
  return t2;
}
var Bo = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];
var Fo = ta(Ln, "div");
var Ho = ta(en, "g", Bo);
function Uo(e2) {
  const t2 = String(e2), n = [];
  return { toOffset: u, toPoint: r2 };
  function r2(a) {
    if (typeof a == "number" && a > -1 && a <= t2.length) {
      let i = 0;
      for (; ; ) {
        let o = n[i];
        if (o === void 0) {
          const l3 = Su(t2, n[i - 1]);
          o = l3 === -1 ? t2.length + 1 : l3 + 1, n[i] = o;
        }
        if (o > a)
          return {
            line: i + 1,
            column: a - (i > 0 ? n[i - 1] : 0) + 1,
            offset: a
          };
        i++;
      }
    }
  }
  function u(a) {
    if (a && typeof a.line == "number" && typeof a.column == "number" && !Number.isNaN(a.line) && !Number.isNaN(a.column)) {
      for (; n.length < a.line; ) {
        const o = n[n.length - 1], l3 = Su(t2, o), c = l3 === -1 ? t2.length + 1 : l3 + 1;
        if (o === c) break;
        n.push(c);
      }
      const i = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1;
      if (i < n[a.line - 1]) return i;
    }
  }
}
function Su(e2, t2) {
  const n = e2.indexOf("\r", t2), r2 = e2.indexOf(`
`, t2);
  return r2 === -1 ? n : n === -1 || n + 1 === r2 ? r2 : n < r2 ? n : r2;
}
var tt = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
var na = {}.hasOwnProperty;
var vo = Object.prototype;
function zo(e2, t2) {
  const n = t2 || {};
  return Br(
    {
      file: n.file || void 0,
      location: false,
      schema: n.space === "svg" ? en : Ln,
      verbose: n.verbose || false
    },
    e2
  );
}
function Br(e2, t2) {
  let n;
  switch (t2.nodeName) {
    case "#comment": {
      const r2 = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t2
      );
      return n = { type: "comment", value: r2.data }, pn(e2, r2, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r2 = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t2
      ), u = "mode" in r2 ? r2.mode === "quirks" || r2.mode === "limited-quirks" : false;
      if (n = {
        type: "root",
        children: ra(e2, t2.childNodes),
        data: { quirksMode: u }
      }, e2.file && e2.location) {
        const a = String(e2.file), i = Uo(a), o = i.toPoint(0), l3 = i.toPoint(a.length);
        n.position = { start: o, end: l3 };
      }
      return n;
    }
    case "#documentType": {
      const r2 = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t2
      );
      return n = { type: "doctype" }, pn(e2, r2, n), n;
    }
    case "#text": {
      const r2 = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t2
      );
      return n = { type: "text", value: r2.value }, pn(e2, r2, n), n;
    }
    // Element.
    default:
      return n = Yo(
        e2,
        /** @type {DefaultTreeAdapterMap['element']} */
        t2
      ), n;
  }
}
function ra(e2, t2) {
  let n = -1;
  const r2 = [];
  for (; ++n < t2.length; ) {
    const u = (
      /** @type {RootContent} */
      Br(e2, t2[n])
    );
    r2.push(u);
  }
  return r2;
}
function Yo(e2, t2) {
  const n = e2.schema;
  e2.schema = t2.namespaceURI === tt.svg ? en : Ln;
  let r2 = -1;
  const u = {};
  for (; ++r2 < t2.attrs.length; ) {
    const o = t2.attrs[r2], l3 = (o.prefix ? o.prefix + ":" : "") + o.name;
    na.call(vo, l3) || (u[l3] = o.value);
  }
  const i = (e2.schema.space === "svg" ? Ho : Fo)(t2.tagName, u, ra(e2, t2.childNodes));
  if (pn(e2, t2, i), i.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t2
    ), l3 = o.sourceCodeLocation, c = l3 && l3.startTag && pt(l3.startTag), h = l3 && l3.endTag && pt(l3.endTag), f2 = (
      /** @type {Root} */
      Br(e2, o.content)
    );
    c && h && e2.file && (f2.position = { start: c.end, end: h.start }), i.content = f2;
  }
  return e2.schema = n, i;
}
function pn(e2, t2, n) {
  if ("sourceCodeLocation" in t2 && t2.sourceCodeLocation && e2.file) {
    const r2 = qo(e2, n, t2.sourceCodeLocation);
    r2 && (e2.location = true, n.position = r2);
  }
}
function qo(e2, t2, n) {
  const r2 = pt(n);
  if (t2.type === "element") {
    const u = t2.children[t2.children.length - 1];
    if (r2 && !n.endTag && u && u.position && u.position.end && (r2.end = Object.assign({}, u.position.end)), e2.verbose) {
      const a = {};
      let i;
      if (n.attrs)
        for (i in n.attrs)
          na.call(n.attrs, i) && (a[Mr(e2.schema, i).property] = pt(
            n.attrs[i]
          ));
      n.startTag;
      const o = pt(n.startTag), l3 = n.endTag ? pt(n.endTag) : void 0, c = { opening: o };
      l3 && (c.closing = l3), c.properties = a, t2.data = { position: c };
    }
  }
  return r2;
}
function pt(e2) {
  const t2 = xu({
    line: e2.startLine,
    column: e2.startCol,
    offset: e2.startOffset
  }), n = xu({
    line: e2.endLine,
    column: e2.endCol,
    offset: e2.endOffset
  });
  return t2 || n ? { start: t2, end: n } : void 0;
}
function xu(e2) {
  return e2.line && e2.column ? e2 : void 0;
}
var Iu = {}.hasOwnProperty;
function ua(e2, t2) {
  const n = t2 || {};
  function r2(u, ...a) {
    let i = r2.invalid;
    const o = r2.handlers;
    if (u && Iu.call(u, e2)) {
      const l3 = String(u[e2]);
      i = Iu.call(o, l3) ? o[l3] : r2.unknown;
    }
    if (i)
      return i.call(this, u, ...a);
  }
  return r2.handlers = n.handlers || {}, r2.invalid = n.invalid, r2.unknown = n.unknown, r2;
}
var jo = {};
var Vo = {}.hasOwnProperty;
var ia = ua("type", { handlers: { root: Go, element: Jo, text: Xo, comment: Ko, doctype: $o } });
function Wo(e2, t2) {
  const r2 = (t2 || jo).space;
  return ia(e2, r2 === "svg" ? en : Ln);
}
function Go(e2, t2) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e2.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Fr(e2.children, n, t2), St(e2, n), n;
}
function Qo(e2, t2) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Fr(e2.children, n, t2), St(e2, n), n;
}
function $o(e2) {
  const t2 = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return St(e2, t2), t2;
}
function Xo(e2) {
  const t2 = {
    nodeName: "#text",
    value: e2.value,
    parentNode: null
  };
  return St(e2, t2), t2;
}
function Ko(e2) {
  const t2 = {
    nodeName: "#comment",
    data: e2.value,
    parentNode: null
  };
  return St(e2, t2), t2;
}
function Jo(e2, t2) {
  const n = t2;
  let r2 = n;
  e2.type === "element" && e2.tagName.toLowerCase() === "svg" && n.space === "html" && (r2 = en);
  const u = [];
  let a;
  if (e2.properties) {
    for (a in e2.properties)
      if (a !== "children" && Vo.call(e2.properties, a)) {
        const l3 = Zo(
          r2,
          a,
          e2.properties[a]
        );
        l3 && u.push(l3);
      }
  }
  const i = r2.space, o = {
    nodeName: e2.tagName,
    tagName: e2.tagName,
    attrs: u,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: tt[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Fr(e2.children, o, r2), St(e2, o), e2.tagName === "template" && e2.content && (o.content = Qo(e2.content, r2)), o;
}
function Zo(e2, t2, n) {
  const r2 = Mr(e2, t2);
  if (n === false || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r2.boolean)
    return;
  Array.isArray(n) && (n = r2.commaSeparated ? Zi(n) : ea(n));
  const u = {
    name: r2.attribute,
    value: n === true ? "" : String(n)
  };
  if (r2.space && r2.space !== "html" && r2.space !== "svg") {
    const a = u.name.indexOf(":");
    a < 0 ? u.prefix = "" : (u.name = u.name.slice(a + 1), u.prefix = r2.attribute.slice(0, a)), u.namespace = tt[r2.space];
  }
  return u;
}
function Fr(e2, t2, n) {
  let r2 = -1;
  const u = [];
  if (e2)
    for (; ++r2 < e2.length; ) {
      const a = ia(e2[r2], n);
      a.parentNode = t2, u.push(a);
    }
  return u;
}
function St(e2, t2) {
  const n = e2.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t2.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
var el = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var tl = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var ie = "�";
var m;
(function(e2) {
  e2[e2.EOF = -1] = "EOF", e2[e2.NULL = 0] = "NULL", e2[e2.TABULATION = 9] = "TABULATION", e2[e2.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e2[e2.LINE_FEED = 10] = "LINE_FEED", e2[e2.FORM_FEED = 12] = "FORM_FEED", e2[e2.SPACE = 32] = "SPACE", e2[e2.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e2[e2.QUOTATION_MARK = 34] = "QUOTATION_MARK", e2[e2.AMPERSAND = 38] = "AMPERSAND", e2[e2.APOSTROPHE = 39] = "APOSTROPHE", e2[e2.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e2[e2.SOLIDUS = 47] = "SOLIDUS", e2[e2.DIGIT_0 = 48] = "DIGIT_0", e2[e2.DIGIT_9 = 57] = "DIGIT_9", e2[e2.SEMICOLON = 59] = "SEMICOLON", e2[e2.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e2[e2.EQUALS_SIGN = 61] = "EQUALS_SIGN", e2[e2.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e2[e2.QUESTION_MARK = 63] = "QUESTION_MARK", e2[e2.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e2[e2.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e2[e2.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e2[e2.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e2[e2.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e2[e2.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(m || (m = {}));
var Te = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function aa(e2) {
  return e2 >= 55296 && e2 <= 57343;
}
function nl(e2) {
  return e2 >= 56320 && e2 <= 57343;
}
function rl(e2, t2) {
  return (e2 - 55296) * 1024 + 9216 + t2;
}
function sa(e2) {
  return e2 !== 32 && e2 !== 10 && e2 !== 13 && e2 !== 9 && e2 !== 12 && e2 >= 1 && e2 <= 31 || e2 >= 127 && e2 <= 159;
}
function oa(e2) {
  return e2 >= 64976 && e2 <= 65007 || tl.has(e2);
}
var x;
(function(e2) {
  e2.controlCharacterInInputStream = "control-character-in-input-stream", e2.noncharacterInInputStream = "noncharacter-in-input-stream", e2.surrogateInInputStream = "surrogate-in-input-stream", e2.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e2.endTagWithAttributes = "end-tag-with-attributes", e2.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e2.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e2.unexpectedNullCharacter = "unexpected-null-character", e2.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e2.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e2.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e2.missingEndTagName = "missing-end-tag-name", e2.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e2.unknownNamedCharacterReference = "unknown-named-character-reference", e2.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e2.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e2.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e2.eofBeforeTagName = "eof-before-tag-name", e2.eofInTag = "eof-in-tag", e2.missingAttributeValue = "missing-attribute-value", e2.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e2.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e2.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e2.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e2.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e2.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e2.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e2.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e2.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e2.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e2.cdataInHtmlContent = "cdata-in-html-content", e2.incorrectlyOpenedComment = "incorrectly-opened-comment", e2.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e2.eofInDoctype = "eof-in-doctype", e2.nestedComment = "nested-comment", e2.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e2.eofInComment = "eof-in-comment", e2.incorrectlyClosedComment = "incorrectly-closed-comment", e2.eofInCdata = "eof-in-cdata", e2.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e2.nullCharacterReference = "null-character-reference", e2.surrogateCharacterReference = "surrogate-character-reference", e2.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e2.controlCharacterReference = "control-character-reference", e2.noncharacterCharacterReference = "noncharacter-character-reference", e2.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e2.missingDoctypeName = "missing-doctype-name", e2.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e2.duplicateAttribute = "duplicate-attribute", e2.nonConformingDoctype = "non-conforming-doctype", e2.missingDoctype = "missing-doctype", e2.misplacedDoctype = "misplaced-doctype", e2.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e2.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e2.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e2.openElementsLeftAfterEof = "open-elements-left-after-eof", e2.abandonedHeadElementChild = "abandoned-head-element-child", e2.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e2.nestedNoscriptInHead = "nested-noscript-in-head", e2.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(x || (x = {}));
var ul = 65536;
var il = class {
  constructor(t2) {
    this.handler = t2, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = false, this.lastChunkWritten = false, this.endOfChunkHit = false, this.bufferWaterline = ul, this.isEol = false, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t2, n) {
    const { line: r2, col: u, offset: a } = this, i = u + n, o = a + n;
    return {
      code: t2,
      startLine: r2,
      endLine: r2,
      startCol: i,
      endCol: i,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t2) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t2, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t2) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (nl(n))
        return this.pos++, this._addGap(), rl(t2, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = true, m.EOF;
    return this._err(x.surrogateInInputStream), t2;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t2, n) {
    this.html.length > 0 ? this.html += t2 : this.html = t2, this.endOfChunkHit = false, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t2) {
    this.html = this.html.substring(0, this.pos + 1) + t2 + this.html.substring(this.pos + 1), this.endOfChunkHit = false;
  }
  startsWith(t2, n) {
    if (this.pos + t2.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, false;
    if (n)
      return this.html.startsWith(t2, this.pos);
    for (let r2 = 0; r2 < t2.length; r2++)
      if ((this.html.charCodeAt(this.pos + r2) | 32) !== t2.charCodeAt(r2))
        return false;
    return true;
  }
  peek(t2) {
    const n = this.pos + t2;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    const r2 = this.html.charCodeAt(n);
    return r2 === m.CARRIAGE_RETURN ? m.LINE_FEED : r2;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = false, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    let t2 = this.html.charCodeAt(this.pos);
    return t2 === m.CARRIAGE_RETURN ? (this.isEol = true, this.skipNextNewLine = true, m.LINE_FEED) : t2 === m.LINE_FEED && (this.isEol = true, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = false, this._addGap(), this.advance()) : (this.skipNextNewLine = false, aa(t2) && (t2 = this._processSurrogate(t2)), this.handler.onParseError === null || t2 > 31 && t2 < 127 || t2 === m.LINE_FEED || t2 === m.CARRIAGE_RETURN || t2 > 159 && t2 < 64976 || this._checkForProblematicCharacters(t2), t2);
  }
  _checkForProblematicCharacters(t2) {
    sa(t2) ? this._err(x.controlCharacterInInputStream) : oa(t2) && this._err(x.noncharacterInInputStream);
  }
  retreat(t2) {
    for (this.pos -= t2; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = false;
  }
};
var $;
(function(e2) {
  e2[e2.CHARACTER = 0] = "CHARACTER", e2[e2.NULL_CHARACTER = 1] = "NULL_CHARACTER", e2[e2.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e2[e2.START_TAG = 3] = "START_TAG", e2[e2.END_TAG = 4] = "END_TAG", e2[e2.COMMENT = 5] = "COMMENT", e2[e2.DOCTYPE = 6] = "DOCTYPE", e2[e2.EOF = 7] = "EOF", e2[e2.HIBERNATION = 8] = "HIBERNATION";
})($ || ($ = {}));
function la(e2, t2) {
  for (let n = e2.attrs.length - 1; n >= 0; n--)
    if (e2.attrs[n].name === t2)
      return e2.attrs[n].value;
  return null;
}
var ca = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e2) => e2.charCodeAt(0))
);
var al = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e2) => e2.charCodeAt(0))
);
var jn;
var sl = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var ol = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (jn = String.fromCodePoint) !== null && jn !== void 0 ? jn : function(e2) {
    let t2 = "";
    return e2 > 65535 && (e2 -= 65536, t2 += String.fromCharCode(e2 >>> 10 & 1023 | 55296), e2 = 56320 | e2 & 1023), t2 += String.fromCharCode(e2), t2;
  }
);
function ll(e2) {
  var t2;
  return e2 >= 55296 && e2 <= 57343 || e2 > 1114111 ? 65533 : (t2 = sl.get(e2)) !== null && t2 !== void 0 ? t2 : e2;
}
var fe;
(function(e2) {
  e2[e2.NUM = 35] = "NUM", e2[e2.SEMI = 59] = "SEMI", e2[e2.EQUALS = 61] = "EQUALS", e2[e2.ZERO = 48] = "ZERO", e2[e2.NINE = 57] = "NINE", e2[e2.LOWER_A = 97] = "LOWER_A", e2[e2.LOWER_F = 102] = "LOWER_F", e2[e2.LOWER_X = 120] = "LOWER_X", e2[e2.LOWER_Z = 122] = "LOWER_Z", e2[e2.UPPER_A = 65] = "UPPER_A", e2[e2.UPPER_F = 70] = "UPPER_F", e2[e2.UPPER_Z = 90] = "UPPER_Z";
})(fe || (fe = {}));
var cl = 32;
var Ge;
(function(e2) {
  e2[e2.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e2[e2.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e2[e2.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ge || (Ge = {}));
function mr(e2) {
  return e2 >= fe.ZERO && e2 <= fe.NINE;
}
function fl(e2) {
  return e2 >= fe.UPPER_A && e2 <= fe.UPPER_F || e2 >= fe.LOWER_A && e2 <= fe.LOWER_F;
}
function hl(e2) {
  return e2 >= fe.UPPER_A && e2 <= fe.UPPER_Z || e2 >= fe.LOWER_A && e2 <= fe.LOWER_Z || mr(e2);
}
function dl(e2) {
  return e2 === fe.EQUALS || hl(e2);
}
var ce2;
(function(e2) {
  e2[e2.EntityStart = 0] = "EntityStart", e2[e2.NumericStart = 1] = "NumericStart", e2[e2.NumericDecimal = 2] = "NumericDecimal", e2[e2.NumericHex = 3] = "NumericHex", e2[e2.NamedEntity = 4] = "NamedEntity";
})(ce2 || (ce2 = {}));
var ze;
(function(e2) {
  e2[e2.Legacy = 0] = "Legacy", e2[e2.Strict = 1] = "Strict", e2[e2.Attribute = 2] = "Attribute";
})(ze || (ze = {}));
var fa = class {
  constructor(t2, n, r2) {
    this.decodeTree = t2, this.emitCodePoint = n, this.errors = r2, this.state = ce2.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ze.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t2) {
    this.decodeMode = t2, this.state = ce2.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t2, n) {
    switch (this.state) {
      case ce2.EntityStart:
        return t2.charCodeAt(n) === fe.NUM ? (this.state = ce2.NumericStart, this.consumed += 1, this.stateNumericStart(t2, n + 1)) : (this.state = ce2.NamedEntity, this.stateNamedEntity(t2, n));
      case ce2.NumericStart:
        return this.stateNumericStart(t2, n);
      case ce2.NumericDecimal:
        return this.stateNumericDecimal(t2, n);
      case ce2.NumericHex:
        return this.stateNumericHex(t2, n);
      case ce2.NamedEntity:
        return this.stateNamedEntity(t2, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t2, n) {
    return n >= t2.length ? -1 : (t2.charCodeAt(n) | cl) === fe.LOWER_X ? (this.state = ce2.NumericHex, this.consumed += 1, this.stateNumericHex(t2, n + 1)) : (this.state = ce2.NumericDecimal, this.stateNumericDecimal(t2, n));
  }
  addToNumericResult(t2, n, r2, u) {
    if (n !== r2) {
      const a = r2 - n;
      this.result = this.result * Math.pow(u, a) + parseInt(t2.substr(n, a), u), this.consumed += a;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t2, n) {
    const r2 = n;
    for (; n < t2.length; ) {
      const u = t2.charCodeAt(n);
      if (mr(u) || fl(u))
        n += 1;
      else
        return this.addToNumericResult(t2, r2, n, 16), this.emitNumericEntity(u, 3);
    }
    return this.addToNumericResult(t2, r2, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t2, n) {
    const r2 = n;
    for (; n < t2.length; ) {
      const u = t2.charCodeAt(n);
      if (mr(u))
        n += 1;
      else
        return this.addToNumericResult(t2, r2, n, 10), this.emitNumericEntity(u, 2);
    }
    return this.addToNumericResult(t2, r2, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t2, n) {
    var r2;
    if (this.consumed <= n)
      return (r2 = this.errors) === null || r2 === void 0 || r2.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t2 === fe.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === ze.Strict)
      return 0;
    return this.emitCodePoint(ll(this.result), this.consumed), this.errors && (t2 !== fe.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t2, n) {
    const { decodeTree: r2 } = this;
    let u = r2[this.treeIndex], a = (u & Ge.VALUE_LENGTH) >> 14;
    for (; n < t2.length; n++, this.excess++) {
      const i = t2.charCodeAt(n);
      if (this.treeIndex = ml(r2, u, this.treeIndex + Math.max(1, a), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === ze.Attribute && // We shouldn't have consumed any characters after the entity,
        (a === 0 || // And there should be no invalid characters.
        dl(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (u = r2[this.treeIndex], a = (u & Ge.VALUE_LENGTH) >> 14, a !== 0) {
        if (i === fe.SEMI)
          return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess);
        this.decodeMode !== ze.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t2;
    const { result: n, decodeTree: r2 } = this, u = (r2[n] & Ge.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, u, this.consumed), (t2 = this.errors) === null || t2 === void 0 || t2.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t2, n, r2) {
    const { decodeTree: u } = this;
    return this.emitCodePoint(n === 1 ? u[t2] & ~Ge.VALUE_LENGTH : u[t2 + 1], r2), n === 3 && this.emitCodePoint(u[t2 + 2], r2), r2;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t2;
    switch (this.state) {
      case ce2.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ze.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case ce2.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case ce2.NumericHex:
        return this.emitNumericEntity(0, 3);
      case ce2.NumericStart:
        return (t2 = this.errors) === null || t2 === void 0 || t2.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case ce2.EntityStart:
        return 0;
    }
  }
};
function ha(e2) {
  let t2 = "";
  const n = new fa(e2, (r2) => t2 += ol(r2));
  return function(u, a) {
    let i = 0, o = 0;
    for (; (o = u.indexOf("&", o)) >= 0; ) {
      t2 += u.slice(i, o), n.startEntity(a);
      const c = n.write(
        u,
        // Skip the "&"
        o + 1
      );
      if (c < 0) {
        i = o + n.end();
        break;
      }
      i = o + c, o = c === 0 ? i + 1 : i;
    }
    const l3 = t2 + u.slice(i);
    return t2 = "", l3;
  };
}
function ml(e2, t2, n, r2) {
  const u = (t2 & Ge.BRANCH_LENGTH) >> 7, a = t2 & Ge.JUMP_TABLE;
  if (u === 0)
    return a !== 0 && r2 === a ? n : -1;
  if (a) {
    const l3 = r2 - a;
    return l3 < 0 || l3 >= u ? -1 : e2[n + l3] - 1;
  }
  let i = n, o = i + u - 1;
  for (; i <= o; ) {
    const l3 = i + o >>> 1, c = e2[l3];
    if (c < r2)
      i = l3 + 1;
    else if (c > r2)
      o = l3 - 1;
    else
      return e2[l3 + u];
  }
  return -1;
}
ha(ca);
ha(al);
var R;
(function(e2) {
  e2.HTML = "http://www.w3.org/1999/xhtml", e2.MATHML = "http://www.w3.org/1998/Math/MathML", e2.SVG = "http://www.w3.org/2000/svg", e2.XLINK = "http://www.w3.org/1999/xlink", e2.XML = "http://www.w3.org/XML/1998/namespace", e2.XMLNS = "http://www.w3.org/2000/xmlns/";
})(R || (R = {}));
var nt;
(function(e2) {
  e2.TYPE = "type", e2.ACTION = "action", e2.ENCODING = "encoding", e2.PROMPT = "prompt", e2.NAME = "name", e2.COLOR = "color", e2.FACE = "face", e2.SIZE = "size";
})(nt || (nt = {}));
var xe;
(function(e2) {
  e2.NO_QUIRKS = "no-quirks", e2.QUIRKS = "quirks", e2.LIMITED_QUIRKS = "limited-quirks";
})(xe || (xe = {}));
var _;
(function(e2) {
  e2.A = "a", e2.ADDRESS = "address", e2.ANNOTATION_XML = "annotation-xml", e2.APPLET = "applet", e2.AREA = "area", e2.ARTICLE = "article", e2.ASIDE = "aside", e2.B = "b", e2.BASE = "base", e2.BASEFONT = "basefont", e2.BGSOUND = "bgsound", e2.BIG = "big", e2.BLOCKQUOTE = "blockquote", e2.BODY = "body", e2.BR = "br", e2.BUTTON = "button", e2.CAPTION = "caption", e2.CENTER = "center", e2.CODE = "code", e2.COL = "col", e2.COLGROUP = "colgroup", e2.DD = "dd", e2.DESC = "desc", e2.DETAILS = "details", e2.DIALOG = "dialog", e2.DIR = "dir", e2.DIV = "div", e2.DL = "dl", e2.DT = "dt", e2.EM = "em", e2.EMBED = "embed", e2.FIELDSET = "fieldset", e2.FIGCAPTION = "figcaption", e2.FIGURE = "figure", e2.FONT = "font", e2.FOOTER = "footer", e2.FOREIGN_OBJECT = "foreignObject", e2.FORM = "form", e2.FRAME = "frame", e2.FRAMESET = "frameset", e2.H1 = "h1", e2.H2 = "h2", e2.H3 = "h3", e2.H4 = "h4", e2.H5 = "h5", e2.H6 = "h6", e2.HEAD = "head", e2.HEADER = "header", e2.HGROUP = "hgroup", e2.HR = "hr", e2.HTML = "html", e2.I = "i", e2.IMG = "img", e2.IMAGE = "image", e2.INPUT = "input", e2.IFRAME = "iframe", e2.KEYGEN = "keygen", e2.LABEL = "label", e2.LI = "li", e2.LINK = "link", e2.LISTING = "listing", e2.MAIN = "main", e2.MALIGNMARK = "malignmark", e2.MARQUEE = "marquee", e2.MATH = "math", e2.MENU = "menu", e2.META = "meta", e2.MGLYPH = "mglyph", e2.MI = "mi", e2.MO = "mo", e2.MN = "mn", e2.MS = "ms", e2.MTEXT = "mtext", e2.NAV = "nav", e2.NOBR = "nobr", e2.NOFRAMES = "noframes", e2.NOEMBED = "noembed", e2.NOSCRIPT = "noscript", e2.OBJECT = "object", e2.OL = "ol", e2.OPTGROUP = "optgroup", e2.OPTION = "option", e2.P = "p", e2.PARAM = "param", e2.PLAINTEXT = "plaintext", e2.PRE = "pre", e2.RB = "rb", e2.RP = "rp", e2.RT = "rt", e2.RTC = "rtc", e2.RUBY = "ruby", e2.S = "s", e2.SCRIPT = "script", e2.SEARCH = "search", e2.SECTION = "section", e2.SELECT = "select", e2.SOURCE = "source", e2.SMALL = "small", e2.SPAN = "span", e2.STRIKE = "strike", e2.STRONG = "strong", e2.STYLE = "style", e2.SUB = "sub", e2.SUMMARY = "summary", e2.SUP = "sup", e2.TABLE = "table", e2.TBODY = "tbody", e2.TEMPLATE = "template", e2.TEXTAREA = "textarea", e2.TFOOT = "tfoot", e2.TD = "td", e2.TH = "th", e2.THEAD = "thead", e2.TITLE = "title", e2.TR = "tr", e2.TRACK = "track", e2.TT = "tt", e2.U = "u", e2.UL = "ul", e2.SVG = "svg", e2.VAR = "var", e2.WBR = "wbr", e2.XMP = "xmp";
})(_ || (_ = {}));
var s;
(function(e2) {
  e2[e2.UNKNOWN = 0] = "UNKNOWN", e2[e2.A = 1] = "A", e2[e2.ADDRESS = 2] = "ADDRESS", e2[e2.ANNOTATION_XML = 3] = "ANNOTATION_XML", e2[e2.APPLET = 4] = "APPLET", e2[e2.AREA = 5] = "AREA", e2[e2.ARTICLE = 6] = "ARTICLE", e2[e2.ASIDE = 7] = "ASIDE", e2[e2.B = 8] = "B", e2[e2.BASE = 9] = "BASE", e2[e2.BASEFONT = 10] = "BASEFONT", e2[e2.BGSOUND = 11] = "BGSOUND", e2[e2.BIG = 12] = "BIG", e2[e2.BLOCKQUOTE = 13] = "BLOCKQUOTE", e2[e2.BODY = 14] = "BODY", e2[e2.BR = 15] = "BR", e2[e2.BUTTON = 16] = "BUTTON", e2[e2.CAPTION = 17] = "CAPTION", e2[e2.CENTER = 18] = "CENTER", e2[e2.CODE = 19] = "CODE", e2[e2.COL = 20] = "COL", e2[e2.COLGROUP = 21] = "COLGROUP", e2[e2.DD = 22] = "DD", e2[e2.DESC = 23] = "DESC", e2[e2.DETAILS = 24] = "DETAILS", e2[e2.DIALOG = 25] = "DIALOG", e2[e2.DIR = 26] = "DIR", e2[e2.DIV = 27] = "DIV", e2[e2.DL = 28] = "DL", e2[e2.DT = 29] = "DT", e2[e2.EM = 30] = "EM", e2[e2.EMBED = 31] = "EMBED", e2[e2.FIELDSET = 32] = "FIELDSET", e2[e2.FIGCAPTION = 33] = "FIGCAPTION", e2[e2.FIGURE = 34] = "FIGURE", e2[e2.FONT = 35] = "FONT", e2[e2.FOOTER = 36] = "FOOTER", e2[e2.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e2[e2.FORM = 38] = "FORM", e2[e2.FRAME = 39] = "FRAME", e2[e2.FRAMESET = 40] = "FRAMESET", e2[e2.H1 = 41] = "H1", e2[e2.H2 = 42] = "H2", e2[e2.H3 = 43] = "H3", e2[e2.H4 = 44] = "H4", e2[e2.H5 = 45] = "H5", e2[e2.H6 = 46] = "H6", e2[e2.HEAD = 47] = "HEAD", e2[e2.HEADER = 48] = "HEADER", e2[e2.HGROUP = 49] = "HGROUP", e2[e2.HR = 50] = "HR", e2[e2.HTML = 51] = "HTML", e2[e2.I = 52] = "I", e2[e2.IMG = 53] = "IMG", e2[e2.IMAGE = 54] = "IMAGE", e2[e2.INPUT = 55] = "INPUT", e2[e2.IFRAME = 56] = "IFRAME", e2[e2.KEYGEN = 57] = "KEYGEN", e2[e2.LABEL = 58] = "LABEL", e2[e2.LI = 59] = "LI", e2[e2.LINK = 60] = "LINK", e2[e2.LISTING = 61] = "LISTING", e2[e2.MAIN = 62] = "MAIN", e2[e2.MALIGNMARK = 63] = "MALIGNMARK", e2[e2.MARQUEE = 64] = "MARQUEE", e2[e2.MATH = 65] = "MATH", e2[e2.MENU = 66] = "MENU", e2[e2.META = 67] = "META", e2[e2.MGLYPH = 68] = "MGLYPH", e2[e2.MI = 69] = "MI", e2[e2.MO = 70] = "MO", e2[e2.MN = 71] = "MN", e2[e2.MS = 72] = "MS", e2[e2.MTEXT = 73] = "MTEXT", e2[e2.NAV = 74] = "NAV", e2[e2.NOBR = 75] = "NOBR", e2[e2.NOFRAMES = 76] = "NOFRAMES", e2[e2.NOEMBED = 77] = "NOEMBED", e2[e2.NOSCRIPT = 78] = "NOSCRIPT", e2[e2.OBJECT = 79] = "OBJECT", e2[e2.OL = 80] = "OL", e2[e2.OPTGROUP = 81] = "OPTGROUP", e2[e2.OPTION = 82] = "OPTION", e2[e2.P = 83] = "P", e2[e2.PARAM = 84] = "PARAM", e2[e2.PLAINTEXT = 85] = "PLAINTEXT", e2[e2.PRE = 86] = "PRE", e2[e2.RB = 87] = "RB", e2[e2.RP = 88] = "RP", e2[e2.RT = 89] = "RT", e2[e2.RTC = 90] = "RTC", e2[e2.RUBY = 91] = "RUBY", e2[e2.S = 92] = "S", e2[e2.SCRIPT = 93] = "SCRIPT", e2[e2.SEARCH = 94] = "SEARCH", e2[e2.SECTION = 95] = "SECTION", e2[e2.SELECT = 96] = "SELECT", e2[e2.SOURCE = 97] = "SOURCE", e2[e2.SMALL = 98] = "SMALL", e2[e2.SPAN = 99] = "SPAN", e2[e2.STRIKE = 100] = "STRIKE", e2[e2.STRONG = 101] = "STRONG", e2[e2.STYLE = 102] = "STYLE", e2[e2.SUB = 103] = "SUB", e2[e2.SUMMARY = 104] = "SUMMARY", e2[e2.SUP = 105] = "SUP", e2[e2.TABLE = 106] = "TABLE", e2[e2.TBODY = 107] = "TBODY", e2[e2.TEMPLATE = 108] = "TEMPLATE", e2[e2.TEXTAREA = 109] = "TEXTAREA", e2[e2.TFOOT = 110] = "TFOOT", e2[e2.TD = 111] = "TD", e2[e2.TH = 112] = "TH", e2[e2.THEAD = 113] = "THEAD", e2[e2.TITLE = 114] = "TITLE", e2[e2.TR = 115] = "TR", e2[e2.TRACK = 116] = "TRACK", e2[e2.TT = 117] = "TT", e2[e2.U = 118] = "U", e2[e2.UL = 119] = "UL", e2[e2.SVG = 120] = "SVG", e2[e2.VAR = 121] = "VAR", e2[e2.WBR = 122] = "WBR", e2[e2.XMP = 123] = "XMP";
})(s || (s = {}));
var pl = /* @__PURE__ */ new Map([
  [_.A, s.A],
  [_.ADDRESS, s.ADDRESS],
  [_.ANNOTATION_XML, s.ANNOTATION_XML],
  [_.APPLET, s.APPLET],
  [_.AREA, s.AREA],
  [_.ARTICLE, s.ARTICLE],
  [_.ASIDE, s.ASIDE],
  [_.B, s.B],
  [_.BASE, s.BASE],
  [_.BASEFONT, s.BASEFONT],
  [_.BGSOUND, s.BGSOUND],
  [_.BIG, s.BIG],
  [_.BLOCKQUOTE, s.BLOCKQUOTE],
  [_.BODY, s.BODY],
  [_.BR, s.BR],
  [_.BUTTON, s.BUTTON],
  [_.CAPTION, s.CAPTION],
  [_.CENTER, s.CENTER],
  [_.CODE, s.CODE],
  [_.COL, s.COL],
  [_.COLGROUP, s.COLGROUP],
  [_.DD, s.DD],
  [_.DESC, s.DESC],
  [_.DETAILS, s.DETAILS],
  [_.DIALOG, s.DIALOG],
  [_.DIR, s.DIR],
  [_.DIV, s.DIV],
  [_.DL, s.DL],
  [_.DT, s.DT],
  [_.EM, s.EM],
  [_.EMBED, s.EMBED],
  [_.FIELDSET, s.FIELDSET],
  [_.FIGCAPTION, s.FIGCAPTION],
  [_.FIGURE, s.FIGURE],
  [_.FONT, s.FONT],
  [_.FOOTER, s.FOOTER],
  [_.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [_.FORM, s.FORM],
  [_.FRAME, s.FRAME],
  [_.FRAMESET, s.FRAMESET],
  [_.H1, s.H1],
  [_.H2, s.H2],
  [_.H3, s.H3],
  [_.H4, s.H4],
  [_.H5, s.H5],
  [_.H6, s.H6],
  [_.HEAD, s.HEAD],
  [_.HEADER, s.HEADER],
  [_.HGROUP, s.HGROUP],
  [_.HR, s.HR],
  [_.HTML, s.HTML],
  [_.I, s.I],
  [_.IMG, s.IMG],
  [_.IMAGE, s.IMAGE],
  [_.INPUT, s.INPUT],
  [_.IFRAME, s.IFRAME],
  [_.KEYGEN, s.KEYGEN],
  [_.LABEL, s.LABEL],
  [_.LI, s.LI],
  [_.LINK, s.LINK],
  [_.LISTING, s.LISTING],
  [_.MAIN, s.MAIN],
  [_.MALIGNMARK, s.MALIGNMARK],
  [_.MARQUEE, s.MARQUEE],
  [_.MATH, s.MATH],
  [_.MENU, s.MENU],
  [_.META, s.META],
  [_.MGLYPH, s.MGLYPH],
  [_.MI, s.MI],
  [_.MO, s.MO],
  [_.MN, s.MN],
  [_.MS, s.MS],
  [_.MTEXT, s.MTEXT],
  [_.NAV, s.NAV],
  [_.NOBR, s.NOBR],
  [_.NOFRAMES, s.NOFRAMES],
  [_.NOEMBED, s.NOEMBED],
  [_.NOSCRIPT, s.NOSCRIPT],
  [_.OBJECT, s.OBJECT],
  [_.OL, s.OL],
  [_.OPTGROUP, s.OPTGROUP],
  [_.OPTION, s.OPTION],
  [_.P, s.P],
  [_.PARAM, s.PARAM],
  [_.PLAINTEXT, s.PLAINTEXT],
  [_.PRE, s.PRE],
  [_.RB, s.RB],
  [_.RP, s.RP],
  [_.RT, s.RT],
  [_.RTC, s.RTC],
  [_.RUBY, s.RUBY],
  [_.S, s.S],
  [_.SCRIPT, s.SCRIPT],
  [_.SEARCH, s.SEARCH],
  [_.SECTION, s.SECTION],
  [_.SELECT, s.SELECT],
  [_.SOURCE, s.SOURCE],
  [_.SMALL, s.SMALL],
  [_.SPAN, s.SPAN],
  [_.STRIKE, s.STRIKE],
  [_.STRONG, s.STRONG],
  [_.STYLE, s.STYLE],
  [_.SUB, s.SUB],
  [_.SUMMARY, s.SUMMARY],
  [_.SUP, s.SUP],
  [_.TABLE, s.TABLE],
  [_.TBODY, s.TBODY],
  [_.TEMPLATE, s.TEMPLATE],
  [_.TEXTAREA, s.TEXTAREA],
  [_.TFOOT, s.TFOOT],
  [_.TD, s.TD],
  [_.TH, s.TH],
  [_.THEAD, s.THEAD],
  [_.TITLE, s.TITLE],
  [_.TR, s.TR],
  [_.TRACK, s.TRACK],
  [_.TT, s.TT],
  [_.U, s.U],
  [_.UL, s.UL],
  [_.SVG, s.SVG],
  [_.VAR, s.VAR],
  [_.WBR, s.WBR],
  [_.XMP, s.XMP]
]);
function xt(e2) {
  var t2;
  return (t2 = pl.get(e2)) !== null && t2 !== void 0 ? t2 : s.UNKNOWN;
}
var D = s;
var El = {
  [R.HTML]: /* @__PURE__ */ new Set([
    D.ADDRESS,
    D.APPLET,
    D.AREA,
    D.ARTICLE,
    D.ASIDE,
    D.BASE,
    D.BASEFONT,
    D.BGSOUND,
    D.BLOCKQUOTE,
    D.BODY,
    D.BR,
    D.BUTTON,
    D.CAPTION,
    D.CENTER,
    D.COL,
    D.COLGROUP,
    D.DD,
    D.DETAILS,
    D.DIR,
    D.DIV,
    D.DL,
    D.DT,
    D.EMBED,
    D.FIELDSET,
    D.FIGCAPTION,
    D.FIGURE,
    D.FOOTER,
    D.FORM,
    D.FRAME,
    D.FRAMESET,
    D.H1,
    D.H2,
    D.H3,
    D.H4,
    D.H5,
    D.H6,
    D.HEAD,
    D.HEADER,
    D.HGROUP,
    D.HR,
    D.HTML,
    D.IFRAME,
    D.IMG,
    D.INPUT,
    D.LI,
    D.LINK,
    D.LISTING,
    D.MAIN,
    D.MARQUEE,
    D.MENU,
    D.META,
    D.NAV,
    D.NOEMBED,
    D.NOFRAMES,
    D.NOSCRIPT,
    D.OBJECT,
    D.OL,
    D.P,
    D.PARAM,
    D.PLAINTEXT,
    D.PRE,
    D.SCRIPT,
    D.SECTION,
    D.SELECT,
    D.SOURCE,
    D.STYLE,
    D.SUMMARY,
    D.TABLE,
    D.TBODY,
    D.TD,
    D.TEMPLATE,
    D.TEXTAREA,
    D.TFOOT,
    D.TH,
    D.THEAD,
    D.TITLE,
    D.TR,
    D.TRACK,
    D.UL,
    D.WBR,
    D.XMP
  ]),
  [R.MATHML]: /* @__PURE__ */ new Set([D.MI, D.MO, D.MN, D.MS, D.MTEXT, D.ANNOTATION_XML]),
  [R.SVG]: /* @__PURE__ */ new Set([D.TITLE, D.FOREIGN_OBJECT, D.DESC]),
  [R.XLINK]: /* @__PURE__ */ new Set(),
  [R.XML]: /* @__PURE__ */ new Set(),
  [R.XMLNS]: /* @__PURE__ */ new Set()
};
var pr = /* @__PURE__ */ new Set([D.H1, D.H2, D.H3, D.H4, D.H5, D.H6]);
_.STYLE, _.SCRIPT, _.XMP, _.IFRAME, _.NOEMBED, _.NOFRAMES, _.PLAINTEXT;
var E;
(function(e2) {
  e2[e2.DATA = 0] = "DATA", e2[e2.RCDATA = 1] = "RCDATA", e2[e2.RAWTEXT = 2] = "RAWTEXT", e2[e2.SCRIPT_DATA = 3] = "SCRIPT_DATA", e2[e2.PLAINTEXT = 4] = "PLAINTEXT", e2[e2.TAG_OPEN = 5] = "TAG_OPEN", e2[e2.END_TAG_OPEN = 6] = "END_TAG_OPEN", e2[e2.TAG_NAME = 7] = "TAG_NAME", e2[e2.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e2[e2.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e2[e2.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e2[e2.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e2[e2.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e2[e2.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e2[e2.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e2[e2.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e2[e2.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e2[e2.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e2[e2.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e2[e2.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e2[e2.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e2[e2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e2[e2.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e2[e2.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e2[e2.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e2[e2.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e2[e2.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e2[e2.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e2[e2.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e2[e2.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e2[e2.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e2[e2.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e2[e2.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e2[e2.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e2[e2.COMMENT_START = 42] = "COMMENT_START", e2[e2.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e2[e2.COMMENT = 44] = "COMMENT", e2[e2.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e2[e2.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e2[e2.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e2[e2.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e2[e2.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e2[e2.COMMENT_END = 50] = "COMMENT_END", e2[e2.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e2[e2.DOCTYPE = 52] = "DOCTYPE", e2[e2.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e2[e2.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e2[e2.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e2[e2.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e2[e2.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e2[e2.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e2[e2.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e2[e2.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e2[e2.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e2[e2.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e2[e2.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e2[e2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e2[e2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e2[e2.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e2[e2.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e2[e2.CDATA_SECTION = 68] = "CDATA_SECTION", e2[e2.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e2[e2.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e2[e2.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e2[e2.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(E || (E = {}));
var ae2 = {
  DATA: E.DATA,
  RCDATA: E.RCDATA,
  RAWTEXT: E.RAWTEXT,
  SCRIPT_DATA: E.SCRIPT_DATA,
  PLAINTEXT: E.PLAINTEXT,
  CDATA_SECTION: E.CDATA_SECTION
};
function gl(e2) {
  return e2 >= m.DIGIT_0 && e2 <= m.DIGIT_9;
}
function Ht(e2) {
  return e2 >= m.LATIN_CAPITAL_A && e2 <= m.LATIN_CAPITAL_Z;
}
function Tl(e2) {
  return e2 >= m.LATIN_SMALL_A && e2 <= m.LATIN_SMALL_Z;
}
function Ve(e2) {
  return Tl(e2) || Ht(e2);
}
function ku(e2) {
  return Ve(e2) || gl(e2);
}
function ln(e2) {
  return e2 + 32;
}
function da(e2) {
  return e2 === m.SPACE || e2 === m.LINE_FEED || e2 === m.TABULATION || e2 === m.FORM_FEED;
}
function yu(e2) {
  return da(e2) || e2 === m.SOLIDUS || e2 === m.GREATER_THAN_SIGN;
}
function bl(e2) {
  return e2 === m.NULL ? x.nullCharacterReference : e2 > 1114111 ? x.characterReferenceOutsideUnicodeRange : aa(e2) ? x.surrogateCharacterReference : oa(e2) ? x.noncharacterCharacterReference : sa(e2) || e2 === m.CARRIAGE_RETURN ? x.controlCharacterReference : null;
}
var Al = class {
  constructor(t2, n) {
    this.options = t2, this.handler = n, this.paused = false, this.inLoop = false, this.inForeignNode = false, this.lastStartTagName = "", this.active = false, this.state = E.DATA, this.returnState = E.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new il(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new fa(ca, (r2, u) => {
      this.preprocessor.pos = this.entityStartPos + u - 1, this._flushCodePointConsumedAsCharacterReference(r2);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(x.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r2) => {
        this._err(x.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r2);
      },
      validateNumericCharacterReference: (r2) => {
        const u = bl(r2);
        u && this._err(u, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t2, n = 0) {
    var r2, u;
    (u = (r2 = this.handler).onParseError) === null || u === void 0 || u.call(r2, this.preprocessor.getError(t2, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t2) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t2,
      startOffset: this.preprocessor.offset - t2,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = true; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t2 = this._consume();
        this._ensureHibernation() || this._callState(t2);
      }
      this.inLoop = false;
    }
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(t2) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = false, !this.inLoop && (this._runParsingLoop(), this.paused || t2 == null || t2());
  }
  write(t2, n, r2) {
    this.active = true, this.preprocessor.write(t2, n), this._runParsingLoop(), this.paused || r2 == null || r2();
  }
  insertHtmlAtCurrentPos(t2) {
    this.active = true, this.preprocessor.insertHtmlAtCurrentPos(t2), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = false, true) : false;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t2) {
    this.consumedAfterSnapshot += t2;
    for (let n = 0; n < t2; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t2, n) {
    return this.preprocessor.startsWith(t2, n) ? (this._advanceBy(t2.length - 1), true) : false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: $.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: $.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t2) {
    this.currentToken = {
      type: $.COMMENT,
      data: "",
      location: this.getCurrentLocation(t2)
    };
  }
  _createDoctypeToken(t2) {
    this.currentToken = {
      type: $.DOCTYPE,
      name: t2,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t2, n) {
    this.currentCharacterToken = {
      type: t2,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t2) {
    this.currentAttr = {
      name: t2,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t2, n;
    const r2 = this.currentToken;
    if (la(r2, this.currentAttr.name) === null) {
      if (r2.attrs.push(this.currentAttr), r2.location && this.currentLocation) {
        const u = (t2 = (n = r2.location).attrs) !== null && t2 !== void 0 ? t2 : n.attrs = /* @__PURE__ */ Object.create(null);
        u[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(x.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t2) {
    this._emitCurrentCharacterToken(t2.location), this.currentToken = null, t2.location && (t2.location.endLine = this.preprocessor.line, t2.location.endCol = this.preprocessor.col + 1, t2.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t2 = this.currentToken;
    this.prepareToken(t2), t2.tagID = xt(t2.tagName), t2.type === $.START_TAG ? (this.lastStartTagName = t2.tagName, this.handler.onStartTag(t2)) : (t2.attrs.length > 0 && this._err(x.endTagWithAttributes), t2.selfClosing && this._err(x.endTagWithTrailingSolidus), this.handler.onEndTag(t2)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t2) {
    this.prepareToken(t2), this.handler.onComment(t2), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t2) {
    this.prepareToken(t2), this.handler.onDoctype(t2), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t2) {
    if (this.currentCharacterToken) {
      switch (t2 && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t2.startLine, this.currentCharacterToken.location.endCol = t2.startCol, this.currentCharacterToken.location.endOffset = t2.startOffset), this.currentCharacterToken.type) {
        case $.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case $.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case $.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t2 = this.getCurrentLocation(0);
    t2 && (t2.endLine = t2.startLine, t2.endCol = t2.startCol, t2.endOffset = t2.startOffset), this._emitCurrentCharacterToken(t2), this.handler.onEof({ type: $.EOF, location: t2 }), this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t2, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t2) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t2, n);
  }
  _emitCodePoint(t2) {
    const n = da(t2) ? $.WHITESPACE_CHARACTER : t2 === m.NULL ? $.NULL_CHARACTER : $.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t2));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t2) {
    this._appendCharToCurrentCharacterToken($.CHARACTER, t2);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = E.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? ze.Attribute : ze.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === E.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t2) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t2) : this._emitCodePoint(t2);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t2) {
    switch (this.state) {
      case E.DATA: {
        this._stateData(t2);
        break;
      }
      case E.RCDATA: {
        this._stateRcdata(t2);
        break;
      }
      case E.RAWTEXT: {
        this._stateRawtext(t2);
        break;
      }
      case E.SCRIPT_DATA: {
        this._stateScriptData(t2);
        break;
      }
      case E.PLAINTEXT: {
        this._statePlaintext(t2);
        break;
      }
      case E.TAG_OPEN: {
        this._stateTagOpen(t2);
        break;
      }
      case E.END_TAG_OPEN: {
        this._stateEndTagOpen(t2);
        break;
      }
      case E.TAG_NAME: {
        this._stateTagName(t2);
        break;
      }
      case E.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t2);
        break;
      }
      case E.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t2);
        break;
      }
      case E.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t2);
        break;
      }
      case E.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t2);
        break;
      }
      case E.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t2);
        break;
      }
      case E.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t2);
        break;
      }
      case E.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t2);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t2);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t2);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t2);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t2);
        break;
      }
      case E.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t2);
        break;
      }
      case E.ATTRIBUTE_NAME: {
        this._stateAttributeName(t2);
        break;
      }
      case E.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t2);
        break;
      }
      case E.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t2);
        break;
      }
      case E.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t2);
        break;
      }
      case E.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t2);
        break;
      }
      case E.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t2);
        break;
      }
      case E.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t2);
        break;
      }
      case E.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t2);
        break;
      }
      case E.BOGUS_COMMENT: {
        this._stateBogusComment(t2);
        break;
      }
      case E.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t2);
        break;
      }
      case E.COMMENT_START: {
        this._stateCommentStart(t2);
        break;
      }
      case E.COMMENT_START_DASH: {
        this._stateCommentStartDash(t2);
        break;
      }
      case E.COMMENT: {
        this._stateComment(t2);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t2);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t2);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t2);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t2);
        break;
      }
      case E.COMMENT_END_DASH: {
        this._stateCommentEndDash(t2);
        break;
      }
      case E.COMMENT_END: {
        this._stateCommentEnd(t2);
        break;
      }
      case E.COMMENT_END_BANG: {
        this._stateCommentEndBang(t2);
        break;
      }
      case E.DOCTYPE: {
        this._stateDoctype(t2);
        break;
      }
      case E.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t2);
        break;
      }
      case E.DOCTYPE_NAME: {
        this._stateDoctypeName(t2);
        break;
      }
      case E.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t2);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t2);
        break;
      }
      case E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t2);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t2);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t2);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t2);
        break;
      }
      case E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t2);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t2);
        break;
      }
      case E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t2);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t2);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t2);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t2);
        break;
      }
      case E.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t2);
        break;
      }
      case E.CDATA_SECTION: {
        this._stateCdataSection(t2);
        break;
      }
      case E.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t2);
        break;
      }
      case E.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t2);
        break;
      }
      case E.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case E.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t2);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t2) {
    switch (t2) {
      case m.LESS_THAN_SIGN: {
        this.state = E.TAG_OPEN;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitCodePoint(t2);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t2) {
    switch (t2) {
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t2) {
    switch (t2) {
      case m.LESS_THAN_SIGN: {
        this.state = E.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t2) {
    switch (t2) {
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t2) {
    switch (t2) {
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t2) {
    if (Ve(t2))
      this._createStartTagToken(), this.state = E.TAG_NAME, this._stateTagName(t2);
    else
      switch (t2) {
        case m.EXCLAMATION_MARK: {
          this.state = E.MARKUP_DECLARATION_OPEN;
          break;
        }
        case m.SOLIDUS: {
          this.state = E.END_TAG_OPEN;
          break;
        }
        case m.QUESTION_MARK: {
          this._err(x.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t2);
          break;
        }
        case m.EOF: {
          this._err(x.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(x.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = E.DATA, this._stateData(t2);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t2) {
    if (Ve(t2))
      this._createEndTagToken(), this.state = E.TAG_NAME, this._stateTagName(t2);
    else
      switch (t2) {
        case m.GREATER_THAN_SIGN: {
          this._err(x.missingEndTagName), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(x.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(x.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t2);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.tagName += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Ht(t2) ? ln(t2) : t2);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t2) {
    t2 === m.SOLIDUS ? this.state = E.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RCDATA, this._stateRcdata(t2));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t2) {
    Ve(t2) ? (this.state = E.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t2)) : (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t2));
  }
  handleSpecialEndTag(t2) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.BEFORE_ATTRIBUTE_NAME, false;
      case m.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.SELF_CLOSING_START_TAG, false;
      case m.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = E.DATA, false;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t2) {
    this.handleSpecialEndTag(t2) && (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t2));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t2) {
    t2 === m.SOLIDUS ? this.state = E.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RAWTEXT, this._stateRawtext(t2));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t2) {
    Ve(t2) ? (this.state = E.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t2)) : (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t2));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t2) {
    this.handleSpecialEndTag(t2) && (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t2));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t2) {
    switch (t2) {
      case m.SOLIDUS: {
        this.state = E.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = E.SCRIPT_DATA, this._stateScriptData(t2);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t2) {
    Ve(t2) ? (this.state = E.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t2)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t2));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t2) {
    this.handleSpecialEndTag(t2) && (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t2));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t2) {
    t2 === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t2));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t2) {
    t2 === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t2));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t2);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t2);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t2) {
    t2 === m.SOLIDUS ? this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ve(t2) ? (this._emitChars("<"), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t2)) : (this._emitChars("<"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t2));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t2) {
    Ve(t2) ? (this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t2)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t2));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t2) {
    this.handleSpecialEndTag(t2) && (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t2));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t2) {
    if (this.preprocessor.startsWith(Te.SCRIPT, false) && yu(this.preprocessor.peek(Te.SCRIPT.length))) {
      this._emitCodePoint(t2);
      for (let n = 0; n < Te.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t2));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t2);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ie);
        break;
      }
      case m.EOF: {
        this._err(x.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t2);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t2) {
    t2 === m.SOLIDUS ? (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t2));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t2) {
    if (this.preprocessor.startsWith(Te.SCRIPT, false) && yu(this.preprocessor.peek(Te.SCRIPT.length))) {
      this._emitCodePoint(t2);
      for (let n = 0; n < Te.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t2));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t2);
        break;
      }
      case m.EQUALS_SIGN: {
        this._err(x.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = E.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t2);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this._leaveAttrName(), this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t2);
        break;
      }
      case m.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN: {
        this._err(x.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t2);
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.name += ie;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Ht(t2) ? ln(t2) : t2);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.EQUALS_SIGN: {
        this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t2);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        this.state = E.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this.state = E.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingAttributeValue), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = E.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t2);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t2) {
    switch (t2) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t2);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t2) {
    switch (t2) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t2);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), this.currentAttr.value += ie;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN:
      case m.EQUALS_SIGN:
      case m.GRAVE_ACCENT: {
        this._err(x.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t2);
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t2);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this._leaveAttrValue(), this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingWhitespaceBetweenAttributes), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t2);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t2) {
    switch (t2) {
      case m.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = true, this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(x.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.unexpectedSolidusInTag), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t2);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.data += ie;
        break;
      }
      default:
        n.data += String.fromCodePoint(t2);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t2) {
    this._consumeSequenceIfMatch(Te.DASH_DASH, true) ? (this._createCommentToken(Te.DASH_DASH.length + 1), this.state = E.COMMENT_START) : this._consumeSequenceIfMatch(Te.DOCTYPE, false) ? (this.currentLocation = this.getCurrentLocation(Te.DOCTYPE.length + 1), this.state = E.DOCTYPE) : this._consumeSequenceIfMatch(Te.CDATA_START, true) ? this.inForeignNode ? this.state = E.CDATA_SECTION : (this._err(x.cdataInHtmlContent), this._createCommentToken(Te.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = E.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(x.incorrectlyOpenedComment), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t2));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t2) {
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_START_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptClosingOfEmptyComment), this.state = E.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptClosingOfEmptyComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<", this.state = E.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.data += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t2);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.EXCLAMATION_MARK: {
        n.data += "!", this.state = E.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t2) {
    t2 === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = E.COMMENT, this._stateComment(t2));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t2) {
    t2 === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = E.COMMENT_END_DASH, this._stateCommentEndDash(t2));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t2) {
    t2 !== m.GREATER_THAN_SIGN && t2 !== m.EOF && this._err(x.nestedComment), this.state = E.COMMENT_END, this._stateCommentEnd(t2);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.COMMENT_END_BANG;
        break;
      }
      case m.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.HYPHEN_MINUS: {
        n.data += "--!", this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.incorrectlyClosedComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = E.COMMENT, this._stateComment(t2);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t2) {
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t2);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingWhitespaceBeforeDoctypeName), this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t2);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t2) {
    if (Ht(t2))
      this._createDoctypeToken(String.fromCharCode(ln(t2))), this.state = E.DOCTYPE_NAME;
    else
      switch (t2) {
        case m.SPACE:
        case m.LINE_FEED:
        case m.TABULATION:
        case m.FORM_FEED:
          break;
        case m.NULL: {
          this._err(x.unexpectedNullCharacter), this._createDoctypeToken(ie), this.state = E.DOCTYPE_NAME;
          break;
        }
        case m.GREATER_THAN_SIGN: {
          this._err(x.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = true, this.emitCurrentDoctype(n), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(x.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t2)), this.state = E.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.AFTER_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.name += ie;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Ht(t2) ? ln(t2) : t2);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Te.PUBLIC, false) ? this.state = E.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Te.SYSTEM, false) ? this.state = E.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(x.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypePublicIdentifier), n.forceQuirks = true, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypePublicIdentifier), n.forceQuirks = true, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.publicId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypePublicIdentifier), n.forceQuirks = true, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t2);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.publicId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypePublicIdentifier), n.forceQuirks = true, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t2);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(x.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(x.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.missingDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = true, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.systemId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypeSystemIdentifier), n.forceQuirks = true, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t2);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter), n.systemId += ie;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(x.abruptDoctypeSystemIdentifier), n.forceQuirks = true, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t2);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(x.eofInDoctype), n.forceQuirks = true, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(x.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t2);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t2) {
    const n = this.currentToken;
    switch (t2) {
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.NULL: {
        this._err(x.unexpectedNullCharacter);
        break;
      }
      case m.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t2) {
    switch (t2) {
      case m.RIGHT_SQUARE_BRACKET: {
        this.state = E.CDATA_SECTION_BRACKET;
        break;
      }
      case m.EOF: {
        this._err(x.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t2);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t2) {
    t2 === m.RIGHT_SQUARE_BRACKET ? this.state = E.CDATA_SECTION_END : (this._emitChars("]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t2));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t2) {
    switch (t2) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA;
        break;
      }
      case m.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t2);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t2 = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t2 < 0)
      if (this.preprocessor.lastChunkWritten)
        t2 = this.entityDecoder.end();
      else {
        this.active = false, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = true;
        return;
      }
    t2 === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(m.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && ku(this.preprocessor.peek(1)) ? E.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t2) {
    ku(t2) ? this._flushCodePointConsumedAsCharacterReference(t2) : (t2 === m.SEMICOLON && this._err(x.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t2));
  }
};
var ma = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]);
var Nu = /* @__PURE__ */ new Set([
  ...ma,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]);
var Cn = /* @__PURE__ */ new Set([
  s.APPLET,
  s.CAPTION,
  s.HTML,
  s.MARQUEE,
  s.OBJECT,
  s.TABLE,
  s.TD,
  s.TEMPLATE,
  s.TH
]);
var _l = /* @__PURE__ */ new Set([...Cn, s.OL, s.UL]);
var Cl = /* @__PURE__ */ new Set([...Cn, s.BUTTON]);
var Ou = /* @__PURE__ */ new Set([s.ANNOTATION_XML, s.MI, s.MN, s.MO, s.MS, s.MTEXT]);
var Lu = /* @__PURE__ */ new Set([s.DESC, s.FOREIGN_OBJECT, s.TITLE]);
var Sl = /* @__PURE__ */ new Set([s.TR, s.TEMPLATE, s.HTML]);
var xl = /* @__PURE__ */ new Set([s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML]);
var Il = /* @__PURE__ */ new Set([s.TABLE, s.TEMPLATE, s.HTML]);
var kl = /* @__PURE__ */ new Set([s.TD, s.TH]);
var yl = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t2, n, r2) {
    this.treeAdapter = n, this.handler = r2, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t2;
  }
  //Index of element
  _indexOf(t2) {
    return this.items.lastIndexOf(t2, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === R.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t2, n) {
    this.stackTop++, this.items[this.stackTop] = t2, this.current = t2, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t2, n, true);
  }
  pop() {
    const t2 = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t2, true);
  }
  replace(t2, n) {
    const r2 = this._indexOf(t2);
    this.items[r2] = n, r2 === this.stackTop && (this.current = n);
  }
  insertAfter(t2, n, r2) {
    const u = this._indexOf(t2) + 1;
    this.items.splice(u, 0, n), this.tagIDs.splice(u, 0, r2), this.stackTop++, u === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, u === this.stackTop);
  }
  popUntilTagNamePopped(t2) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t2, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== R.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t2) {
    for (; this.stackTop >= t2; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t2);
    }
  }
  popUntilElementPopped(t2) {
    const n = this._indexOf(t2);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t2, n) {
    const r2 = this._indexOfTagNames(t2, n);
    this.shortenToLength(r2 < 0 ? 0 : r2);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(pr, R.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(kl, R.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t2, n) {
    for (let r2 = this.stackTop; r2 >= 0; r2--)
      if (t2.has(this.tagIDs[r2]) && this.treeAdapter.getNamespaceURI(this.items[r2]) === n)
        return r2;
    return -1;
  }
  clearBackTo(t2, n) {
    const r2 = this._indexOfTagNames(t2, n);
    this.shortenToLength(r2 + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Il, R.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(xl, R.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(Sl, R.HTML);
  }
  remove(t2) {
    const n = this._indexOf(t2);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t2, false)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t2) {
    return this._indexOf(t2) > -1;
  }
  getCommonAncestor(t2) {
    const n = this._indexOf(t2) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInDynamicScope(t2, n) {
    for (let r2 = this.stackTop; r2 >= 0; r2--) {
      const u = this.tagIDs[r2];
      switch (this.treeAdapter.getNamespaceURI(this.items[r2])) {
        case R.HTML: {
          if (u === t2)
            return true;
          if (n.has(u))
            return false;
          break;
        }
        case R.SVG: {
          if (Lu.has(u))
            return false;
          break;
        }
        case R.MATHML: {
          if (Ou.has(u))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInScope(t2) {
    return this.hasInDynamicScope(t2, Cn);
  }
  hasInListItemScope(t2) {
    return this.hasInDynamicScope(t2, _l);
  }
  hasInButtonScope(t2) {
    return this.hasInDynamicScope(t2, Cl);
  }
  hasNumberedHeaderInScope() {
    for (let t2 = this.stackTop; t2 >= 0; t2--) {
      const n = this.tagIDs[t2];
      switch (this.treeAdapter.getNamespaceURI(this.items[t2])) {
        case R.HTML: {
          if (pr.has(n))
            return true;
          if (Cn.has(n))
            return false;
          break;
        }
        case R.SVG: {
          if (Lu.has(n))
            return false;
          break;
        }
        case R.MATHML: {
          if (Ou.has(n))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInTableScope(t2) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === R.HTML)
        switch (this.tagIDs[n]) {
          case t2:
            return true;
          case s.TABLE:
          case s.HTML:
            return false;
        }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let t2 = this.stackTop; t2 >= 0; t2--)
      if (this.treeAdapter.getNamespaceURI(this.items[t2]) === R.HTML)
        switch (this.tagIDs[t2]) {
          case s.TBODY:
          case s.THEAD:
          case s.TFOOT:
            return true;
          case s.TABLE:
          case s.HTML:
            return false;
        }
    return true;
  }
  hasInSelectScope(t2) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === R.HTML)
        switch (this.tagIDs[n]) {
          case t2:
            return true;
          case s.OPTION:
          case s.OPTGROUP:
            break;
          default:
            return false;
        }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; ma.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Nu.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t2) {
    for (; this.currentTagId !== t2 && Nu.has(this.currentTagId); )
      this.pop();
  }
};
var Vn = 3;
var Pe;
(function(e2) {
  e2[e2.Marker = 0] = "Marker", e2[e2.Element = 1] = "Element";
})(Pe || (Pe = {}));
var Ru = { type: Pe.Marker };
var Nl = class {
  constructor(t2) {
    this.treeAdapter = t2, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t2, n) {
    const r2 = [], u = n.length, a = this.treeAdapter.getTagName(t2), i = this.treeAdapter.getNamespaceURI(t2);
    for (let o = 0; o < this.entries.length; o++) {
      const l3 = this.entries[o];
      if (l3.type === Pe.Marker)
        break;
      const { element: c } = l3;
      if (this.treeAdapter.getTagName(c) === a && this.treeAdapter.getNamespaceURI(c) === i) {
        const h = this.treeAdapter.getAttrList(c);
        h.length === u && r2.push({ idx: o, attrs: h });
      }
    }
    return r2;
  }
  _ensureNoahArkCondition(t2) {
    if (this.entries.length < Vn)
      return;
    const n = this.treeAdapter.getAttrList(t2), r2 = this._getNoahArkConditionCandidates(t2, n);
    if (r2.length < Vn)
      return;
    const u = new Map(n.map((i) => [i.name, i.value]));
    let a = 0;
    for (let i = 0; i < r2.length; i++) {
      const o = r2[i];
      o.attrs.every((l3) => u.get(l3.name) === l3.value) && (a += 1, a >= Vn && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Ru);
  }
  pushElement(t2, n) {
    this._ensureNoahArkCondition(t2), this.entries.unshift({
      type: Pe.Element,
      element: t2,
      token: n
    });
  }
  insertElementAfterBookmark(t2, n) {
    const r2 = this.entries.indexOf(this.bookmark);
    this.entries.splice(r2, 0, {
      type: Pe.Element,
      element: t2,
      token: n
    });
  }
  removeEntry(t2) {
    const n = this.entries.indexOf(t2);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t2 = this.entries.indexOf(Ru);
    t2 >= 0 ? this.entries.splice(0, t2 + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t2) {
    const n = this.entries.find((r2) => r2.type === Pe.Marker || this.treeAdapter.getTagName(r2.element) === t2);
    return n && n.type === Pe.Element ? n : null;
  }
  getElementEntry(t2) {
    return this.entries.find((n) => n.type === Pe.Element && n.element === t2);
  }
};
var We2 = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: xe.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e2, t2, n) {
    return {
      nodeName: e2,
      tagName: e2,
      attrs: n,
      namespaceURI: t2,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e2) {
    return {
      nodeName: "#comment",
      data: e2,
      parentNode: null
    };
  },
  createTextNode(e2) {
    return {
      nodeName: "#text",
      value: e2,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e2, t2) {
    e2.childNodes.push(t2), t2.parentNode = e2;
  },
  insertBefore(e2, t2, n) {
    const r2 = e2.childNodes.indexOf(n);
    e2.childNodes.splice(r2, 0, t2), t2.parentNode = e2;
  },
  setTemplateContent(e2, t2) {
    e2.content = t2;
  },
  getTemplateContent(e2) {
    return e2.content;
  },
  setDocumentType(e2, t2, n, r2) {
    const u = e2.childNodes.find((a) => a.nodeName === "#documentType");
    if (u)
      u.name = t2, u.publicId = n, u.systemId = r2;
    else {
      const a = {
        nodeName: "#documentType",
        name: t2,
        publicId: n,
        systemId: r2,
        parentNode: null
      };
      We2.appendChild(e2, a);
    }
  },
  setDocumentMode(e2, t2) {
    e2.mode = t2;
  },
  getDocumentMode(e2) {
    return e2.mode;
  },
  detachNode(e2) {
    if (e2.parentNode) {
      const t2 = e2.parentNode.childNodes.indexOf(e2);
      e2.parentNode.childNodes.splice(t2, 1), e2.parentNode = null;
    }
  },
  insertText(e2, t2) {
    if (e2.childNodes.length > 0) {
      const n = e2.childNodes[e2.childNodes.length - 1];
      if (We2.isTextNode(n)) {
        n.value += t2;
        return;
      }
    }
    We2.appendChild(e2, We2.createTextNode(t2));
  },
  insertTextBefore(e2, t2, n) {
    const r2 = e2.childNodes[e2.childNodes.indexOf(n) - 1];
    r2 && We2.isTextNode(r2) ? r2.value += t2 : We2.insertBefore(e2, We2.createTextNode(t2), n);
  },
  adoptAttributes(e2, t2) {
    const n = new Set(e2.attrs.map((r2) => r2.name));
    for (let r2 = 0; r2 < t2.length; r2++)
      n.has(t2[r2].name) || e2.attrs.push(t2[r2]);
  },
  //Tree traversing
  getFirstChild(e2) {
    return e2.childNodes[0];
  },
  getChildNodes(e2) {
    return e2.childNodes;
  },
  getParentNode(e2) {
    return e2.parentNode;
  },
  getAttrList(e2) {
    return e2.attrs;
  },
  //Node data
  getTagName(e2) {
    return e2.tagName;
  },
  getNamespaceURI(e2) {
    return e2.namespaceURI;
  },
  getTextNodeContent(e2) {
    return e2.value;
  },
  getCommentNodeContent(e2) {
    return e2.data;
  },
  getDocumentTypeNodeName(e2) {
    return e2.name;
  },
  getDocumentTypeNodePublicId(e2) {
    return e2.publicId;
  },
  getDocumentTypeNodeSystemId(e2) {
    return e2.systemId;
  },
  //Node types
  isTextNode(e2) {
    return e2.nodeName === "#text";
  },
  isCommentNode(e2) {
    return e2.nodeName === "#comment";
  },
  isDocumentTypeNode(e2) {
    return e2.nodeName === "#documentType";
  },
  isElementNode(e2) {
    return Object.prototype.hasOwnProperty.call(e2, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e2, t2) {
    e2.sourceCodeLocation = t2;
  },
  getNodeSourceCodeLocation(e2) {
    return e2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e2, t2) {
    e2.sourceCodeLocation = { ...e2.sourceCodeLocation, ...t2 };
  }
};
var pa = "html";
var Ol = "about:legacy-compat";
var Ll = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var Ea = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var Rl = [
  ...Ea,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var Dl = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var ga = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var Pl = [
  ...ga,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function Du(e2, t2) {
  return t2.some((n) => e2.startsWith(n));
}
function wl(e2) {
  return e2.name === pa && e2.publicId === null && (e2.systemId === null || e2.systemId === Ol);
}
function Ml(e2) {
  if (e2.name !== pa)
    return xe.QUIRKS;
  const { systemId: t2 } = e2;
  if (t2 && t2.toLowerCase() === Ll)
    return xe.QUIRKS;
  let { publicId: n } = e2;
  if (n !== null) {
    if (n = n.toLowerCase(), Dl.has(n))
      return xe.QUIRKS;
    let r2 = t2 === null ? Rl : Ea;
    if (Du(n, r2))
      return xe.QUIRKS;
    if (r2 = t2 === null ? ga : Pl, Du(n, r2))
      return xe.LIMITED_QUIRKS;
  }
  return xe.NO_QUIRKS;
}
var Pu = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var Bl = "definitionurl";
var Fl = "definitionURL";
var Hl = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e2) => [e2.toLowerCase(), e2]));
var Ul = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: R.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: R.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: R.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: R.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: R.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: R.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: R.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: R.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: R.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: R.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: R.XMLNS }]
]);
var vl = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e2) => [e2.toLowerCase(), e2]));
var zl = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function Yl(e2) {
  const t2 = e2.tagID;
  return t2 === s.FONT && e2.attrs.some(({ name: r2 }) => r2 === nt.COLOR || r2 === nt.SIZE || r2 === nt.FACE) || zl.has(t2);
}
function Ta(e2) {
  for (let t2 = 0; t2 < e2.attrs.length; t2++)
    if (e2.attrs[t2].name === Bl) {
      e2.attrs[t2].name = Fl;
      break;
    }
}
function ba(e2) {
  for (let t2 = 0; t2 < e2.attrs.length; t2++) {
    const n = Hl.get(e2.attrs[t2].name);
    n != null && (e2.attrs[t2].name = n);
  }
}
function Hr(e2) {
  for (let t2 = 0; t2 < e2.attrs.length; t2++) {
    const n = Ul.get(e2.attrs[t2].name);
    n && (e2.attrs[t2].prefix = n.prefix, e2.attrs[t2].name = n.name, e2.attrs[t2].namespace = n.namespace);
  }
}
function ql(e2) {
  const t2 = vl.get(e2.tagName);
  t2 != null && (e2.tagName = t2, e2.tagID = xt(e2.tagName));
}
function jl(e2, t2) {
  return t2 === R.MATHML && (e2 === s.MI || e2 === s.MO || e2 === s.MN || e2 === s.MS || e2 === s.MTEXT);
}
function Vl(e2, t2, n) {
  if (t2 === R.MATHML && e2 === s.ANNOTATION_XML) {
    for (let r2 = 0; r2 < n.length; r2++)
      if (n[r2].name === nt.ENCODING) {
        const u = n[r2].value.toLowerCase();
        return u === Pu.TEXT_HTML || u === Pu.APPLICATION_XML;
      }
  }
  return t2 === R.SVG && (e2 === s.FOREIGN_OBJECT || e2 === s.DESC || e2 === s.TITLE);
}
function Wl(e2, t2, n, r2) {
  return (!r2 || r2 === R.HTML) && Vl(e2, t2, n) || (!r2 || r2 === R.MATHML) && jl(e2, t2);
}
var Gl = "hidden";
var Ql = 8;
var $l = 3;
var g;
(function(e2) {
  e2[e2.INITIAL = 0] = "INITIAL", e2[e2.BEFORE_HTML = 1] = "BEFORE_HTML", e2[e2.BEFORE_HEAD = 2] = "BEFORE_HEAD", e2[e2.IN_HEAD = 3] = "IN_HEAD", e2[e2.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e2[e2.AFTER_HEAD = 5] = "AFTER_HEAD", e2[e2.IN_BODY = 6] = "IN_BODY", e2[e2.TEXT = 7] = "TEXT", e2[e2.IN_TABLE = 8] = "IN_TABLE", e2[e2.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e2[e2.IN_CAPTION = 10] = "IN_CAPTION", e2[e2.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e2[e2.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e2[e2.IN_ROW = 13] = "IN_ROW", e2[e2.IN_CELL = 14] = "IN_CELL", e2[e2.IN_SELECT = 15] = "IN_SELECT", e2[e2.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e2[e2.IN_TEMPLATE = 17] = "IN_TEMPLATE", e2[e2.AFTER_BODY = 18] = "AFTER_BODY", e2[e2.IN_FRAMESET = 19] = "IN_FRAMESET", e2[e2.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e2[e2.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e2[e2.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(g || (g = {}));
var Xl = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var Aa = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]);
var wu = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: We2,
  onParseError: null
};
var Mu = class {
  constructor(t2, n, r2 = null, u = null) {
    this.fragmentContext = r2, this.scriptHandler = u, this.currentToken = null, this.stopped = false, this.insertionMode = g.INITIAL, this.originalInsertionMode = g.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = false, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = false, this.framesetOk = true, this.skipNextNewLine = false, this.fosterParentingEnabled = false, this.options = {
      ...wu,
      ...t2
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = true), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Al(this.options, this), this.activeFormattingElements = new Nl(this.treeAdapter), this.fragmentContextID = r2 ? xt(this.treeAdapter.getTagName(r2)) : s.UNKNOWN, this._setContextModes(r2 ?? this.document, this.fragmentContextID), this.openElements = new yl(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t2, n) {
    const r2 = new this(n);
    return r2.tokenizer.write(t2, true), r2.document;
  }
  static getFragmentParser(t2, n) {
    const r2 = {
      ...wu,
      ...n
    };
    t2 ?? (t2 = r2.treeAdapter.createElement(_.TEMPLATE, R.HTML, []));
    const u = r2.treeAdapter.createElement("documentmock", R.HTML, []), a = new this(r2, u, t2);
    return a.fragmentContextID === s.TEMPLATE && a.tmplInsertionModeStack.unshift(g.IN_TEMPLATE), a._initTokenizerForFragmentParsing(), a._insertFakeRootElement(), a._resetInsertionMode(), a._findFormInFragmentContext(), a;
  }
  getFragment() {
    const t2 = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t2, n), n;
  }
  //Errors
  /** @internal */
  _err(t2, n, r2) {
    var u;
    if (!this.onParseError)
      return;
    const a = (u = t2.location) !== null && u !== void 0 ? u : Xl, i = {
      code: n,
      startLine: a.startLine,
      startCol: a.startCol,
      startOffset: a.startOffset,
      endLine: r2 ? a.startLine : a.endLine,
      endCol: r2 ? a.startCol : a.endCol,
      endOffset: r2 ? a.startOffset : a.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  /** @internal */
  onItemPush(t2, n, r2) {
    var u, a;
    (a = (u = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(u, t2), r2 && this.openElements.stackTop > 0 && this._setContextModes(t2, n);
  }
  /** @internal */
  onItemPop(t2, n) {
    var r2, u;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t2, this.currentToken), (u = (r2 = this.treeAdapter).onItemPop) === null || u === void 0 || u.call(r2, t2, this.openElements.current), n) {
      let a, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, i = this.fragmentContextID) : { current: a, currentTagId: i } = this.openElements, this._setContextModes(a, i);
    }
  }
  _setContextModes(t2, n) {
    const r2 = t2 === this.document || this.treeAdapter.getNamespaceURI(t2) === R.HTML;
    this.currentNotInHTML = !r2, this.tokenizer.inForeignNode = !r2 && !this._isIntegrationPoint(n, t2);
  }
  /** @protected */
  _switchToTextParsing(t2, n) {
    this._insertElement(t2, R.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = g.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = g.TEXT, this.originalInsertionMode = g.IN_BODY, this.tokenizer.state = ae2.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t2 = this.fragmentContext;
    for (; t2; ) {
      if (this.treeAdapter.getTagName(t2) === _.FORM) {
        this.formElement = t2;
        break;
      }
      t2 = this.treeAdapter.getParentNode(t2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== R.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = ae2.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = ae2.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = ae2.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = ae2.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t2) {
    const n = t2.name || "", r2 = t2.publicId || "", u = t2.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r2, u), t2.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t2.location);
    }
  }
  /** @protected */
  _attachElementToTree(t2, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r2 = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t2, r2);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t2);
    else {
      const r2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r2, t2);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t2, n) {
    const r2 = this.treeAdapter.createElement(t2.tagName, n, t2.attrs);
    this._attachElementToTree(r2, t2.location);
  }
  /** @protected */
  _insertElement(t2, n) {
    const r2 = this.treeAdapter.createElement(t2.tagName, n, t2.attrs);
    this._attachElementToTree(r2, t2.location), this.openElements.push(r2, t2.tagID);
  }
  /** @protected */
  _insertFakeElement(t2, n) {
    const r2 = this.treeAdapter.createElement(t2, R.HTML, []);
    this._attachElementToTree(r2, null), this.openElements.push(r2, n);
  }
  /** @protected */
  _insertTemplate(t2) {
    const n = this.treeAdapter.createElement(t2.tagName, R.HTML, t2.attrs), r2 = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r2), this._attachElementToTree(n, t2.location), this.openElements.push(n, t2.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r2, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t2 = this.treeAdapter.createElement(_.HTML, R.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t2, null), this.treeAdapter.appendChild(this.openElements.current, t2), this.openElements.push(t2, s.HTML);
  }
  /** @protected */
  _appendCommentNode(t2, n) {
    const r2 = this.treeAdapter.createCommentNode(t2.data);
    this.treeAdapter.appendChild(n, r2), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r2, t2.location);
  }
  /** @protected */
  _insertCharacters(t2) {
    let n, r2;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r2 } = this._findFosterParentingLocation(), r2 ? this.treeAdapter.insertTextBefore(n, t2.chars, r2) : this.treeAdapter.insertText(n, t2.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t2.chars)), !t2.location)
      return;
    const u = this.treeAdapter.getChildNodes(n), a = r2 ? u.lastIndexOf(r2) : u.length, i = u[a - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: l3, endCol: c, endOffset: h } = t2.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: l3, endCol: c, endOffset: h });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t2.location);
  }
  /** @protected */
  _adoptNodes(t2, n) {
    for (let r2 = this.treeAdapter.getFirstChild(t2); r2; r2 = this.treeAdapter.getFirstChild(t2))
      this.treeAdapter.detachNode(r2), this.treeAdapter.appendChild(n, r2);
  }
  /** @protected */
  _setEndLocation(t2, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t2) && n.location) {
      const r2 = n.location, u = this.treeAdapter.getTagName(t2), a = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === $.END_TAG && u === n.tagName ? {
          endTag: { ...r2 },
          endLine: r2.endLine,
          endCol: r2.endCol,
          endOffset: r2.endOffset
        } : {
          endLine: r2.startLine,
          endCol: r2.startCol,
          endOffset: r2.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t2, a);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t2) {
    if (!this.currentNotInHTML)
      return false;
    let n, r2;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r2 = this.fragmentContextID) : { current: n, currentTagId: r2 } = this.openElements, t2.tagID === s.SVG && this.treeAdapter.getTagName(n) === _.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === R.MATHML ? false : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t2.tagID === s.MGLYPH || t2.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r2, n, R.HTML)
    );
  }
  /** @protected */
  _processToken(t2) {
    switch (t2.type) {
      case $.CHARACTER: {
        this.onCharacter(t2);
        break;
      }
      case $.NULL_CHARACTER: {
        this.onNullCharacter(t2);
        break;
      }
      case $.COMMENT: {
        this.onComment(t2);
        break;
      }
      case $.DOCTYPE: {
        this.onDoctype(t2);
        break;
      }
      case $.START_TAG: {
        this._processStartTag(t2);
        break;
      }
      case $.END_TAG: {
        this.onEndTag(t2);
        break;
      }
      case $.EOF: {
        this.onEof(t2);
        break;
      }
      case $.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t2);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t2, n, r2) {
    const u = this.treeAdapter.getNamespaceURI(n), a = this.treeAdapter.getAttrList(n);
    return Wl(t2, u, a, r2);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t2 = this.activeFormattingElements.entries.length;
    if (t2) {
      const n = this.activeFormattingElements.entries.findIndex((u) => u.type === Pe.Marker || this.openElements.contains(u.element)), r2 = n < 0 ? t2 - 1 : n - 1;
      for (let u = r2; u >= 0; u--) {
        const a = this.activeFormattingElements.entries[u];
        this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)), a.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = g.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t2 = this.openElements.stackTop; t2 >= 0; t2--)
      switch (t2 === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t2]) {
        case s.TR: {
          this.insertionMode = g.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = g.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = g.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = g.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = g.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = g.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = g.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t2);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? g.AFTER_HEAD : g.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t2 > 0) {
            this.insertionMode = g.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t2 > 0) {
            this.insertionMode = g.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = g.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t2) {
    if (t2 > 0)
      for (let n = t2 - 1; n > 0; n--) {
        const r2 = this.openElements.tagIDs[n];
        if (r2 === s.TEMPLATE)
          break;
        if (r2 === s.TABLE) {
          this.insertionMode = g.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = g.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t2) {
    return Aa.has(t2);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t2 = this.openElements.stackTop; t2 >= 0; t2--) {
      const n = this.openElements.items[t2];
      switch (this.openElements.tagIDs[t2]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === R.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r2 = this.treeAdapter.getParentNode(n);
          return r2 ? { parent: r2, beforeElement: n } : { parent: this.openElements.items[t2 - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t2) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t2, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t2);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t2, n) {
    const r2 = this.treeAdapter.getNamespaceURI(t2);
    return El[r2].has(n);
  }
  /** @internal */
  onCharacter(t2) {
    if (this.skipNextNewLine = false, this.tokenizer.inForeignNode) {
      k0(this, t2);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t2);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t2);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t2);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t2);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t2);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t2);
        break;
      }
      case g.IN_BODY:
      case g.IN_CAPTION:
      case g.IN_CELL:
      case g.IN_TEMPLATE: {
        Ca(this, t2);
        break;
      }
      case g.TEXT:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t2);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Na(this, t2);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        Sn(this, t2);
        break;
      }
      case g.AFTER_BODY: {
        xn(this, t2);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t2) {
    if (this.skipNextNewLine = false, this.tokenizer.inForeignNode) {
      I0(this, t2);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t2);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t2);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t2);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t2);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t2);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t2);
        break;
      }
      case g.TEXT: {
        this._insertCharacters(t2);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t2);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        Sn(this, t2);
        break;
      }
      case g.AFTER_BODY: {
        xn(this, t2);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onComment(t2) {
    if (this.skipNextNewLine = false, this.currentNotInHTML) {
      Er(this, t2);
      return;
    }
    switch (this.insertionMode) {
      case g.INITIAL:
      case g.BEFORE_HTML:
      case g.BEFORE_HEAD:
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD:
      case g.IN_BODY:
      case g.IN_TABLE:
      case g.IN_CAPTION:
      case g.IN_COLUMN_GROUP:
      case g.IN_TABLE_BODY:
      case g.IN_ROW:
      case g.IN_CELL:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE:
      case g.IN_TEMPLATE:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET: {
        Er(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t2);
        break;
      }
      case g.AFTER_BODY: {
        rc(this, t2);
        break;
      }
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        uc(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t2) {
    switch (this.skipNextNewLine = false, this.insertionMode) {
      case g.INITIAL: {
        ic(this, t2);
        break;
      }
      case g.BEFORE_HEAD:
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD: {
        this._err(t2, x.misplacedDoctype);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t2) {
    this.skipNextNewLine = false, this.currentToken = t2, this._processStartTag(t2), t2.selfClosing && !t2.ackSelfClosing && this._err(t2, x.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t2) {
    this.shouldProcessStartTagTokenInForeignContent(t2) ? y0(this, t2) : this._startTagOutsideForeignContent(t2);
  }
  /** @protected */
  _startTagOutsideForeignContent(t2) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t2);
        break;
      }
      case g.BEFORE_HTML: {
        ac(this, t2);
        break;
      }
      case g.BEFORE_HEAD: {
        oc(this, t2);
        break;
      }
      case g.IN_HEAD: {
        Re(this, t2);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        fc(this, t2);
        break;
      }
      case g.AFTER_HEAD: {
        dc(this, t2);
        break;
      }
      case g.IN_BODY: {
        pe(this, t2);
        break;
      }
      case g.IN_TABLE: {
        At(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t2);
        break;
      }
      case g.IN_CAPTION: {
        l0(this, t2);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        zr(this, t2);
        break;
      }
      case g.IN_TABLE_BODY: {
        Pn(this, t2);
        break;
      }
      case g.IN_ROW: {
        wn(this, t2);
        break;
      }
      case g.IN_CELL: {
        h0(this, t2);
        break;
      }
      case g.IN_SELECT: {
        Ra(this, t2);
        break;
      }
      case g.IN_SELECT_IN_TABLE: {
        m0(this, t2);
        break;
      }
      case g.IN_TEMPLATE: {
        E0(this, t2);
        break;
      }
      case g.AFTER_BODY: {
        T0(this, t2);
        break;
      }
      case g.IN_FRAMESET: {
        b0(this, t2);
        break;
      }
      case g.AFTER_FRAMESET: {
        _0(this, t2);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        S0(this, t2);
        break;
      }
      case g.AFTER_AFTER_FRAMESET: {
        x0(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t2) {
    this.skipNextNewLine = false, this.currentToken = t2, this.currentNotInHTML ? N0(this, t2) : this._endTagOutsideForeignContent(t2);
  }
  /** @protected */
  _endTagOutsideForeignContent(t2) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t2);
        break;
      }
      case g.BEFORE_HTML: {
        sc(this, t2);
        break;
      }
      case g.BEFORE_HEAD: {
        lc(this, t2);
        break;
      }
      case g.IN_HEAD: {
        cc(this, t2);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        hc(this, t2);
        break;
      }
      case g.AFTER_HEAD: {
        mc(this, t2);
        break;
      }
      case g.IN_BODY: {
        Dn(this, t2);
        break;
      }
      case g.TEXT: {
        Zc(this, t2);
        break;
      }
      case g.IN_TABLE: {
        Xt(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t2);
        break;
      }
      case g.IN_CAPTION: {
        c0(this, t2);
        break;
      }
      case g.IN_COLUMN_GROUP: {
        f0(this, t2);
        break;
      }
      case g.IN_TABLE_BODY: {
        gr(this, t2);
        break;
      }
      case g.IN_ROW: {
        La(this, t2);
        break;
      }
      case g.IN_CELL: {
        d0(this, t2);
        break;
      }
      case g.IN_SELECT: {
        Da(this, t2);
        break;
      }
      case g.IN_SELECT_IN_TABLE: {
        p0(this, t2);
        break;
      }
      case g.IN_TEMPLATE: {
        g0(this, t2);
        break;
      }
      case g.AFTER_BODY: {
        wa(this, t2);
        break;
      }
      case g.IN_FRAMESET: {
        A0(this, t2);
        break;
      }
      case g.AFTER_FRAMESET: {
        C0(this, t2);
        break;
      }
      case g.AFTER_AFTER_BODY: {
        En(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onEof(t2) {
    switch (this.insertionMode) {
      case g.INITIAL: {
        Dt(this, t2);
        break;
      }
      case g.BEFORE_HTML: {
        zt(this, t2);
        break;
      }
      case g.BEFORE_HEAD: {
        Yt(this, t2);
        break;
      }
      case g.IN_HEAD: {
        qt(this, t2);
        break;
      }
      case g.IN_HEAD_NO_SCRIPT: {
        jt(this, t2);
        break;
      }
      case g.AFTER_HEAD: {
        Vt(this, t2);
        break;
      }
      case g.IN_BODY:
      case g.IN_TABLE:
      case g.IN_CAPTION:
      case g.IN_COLUMN_GROUP:
      case g.IN_TABLE_BODY:
      case g.IN_ROW:
      case g.IN_CELL:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE: {
        ka(this, t2);
        break;
      }
      case g.TEXT: {
        e0(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        Pt(this, t2);
        break;
      }
      case g.IN_TEMPLATE: {
        Pa(this, t2);
        break;
      }
      case g.AFTER_BODY:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET:
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        vr(this, t2);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t2) {
    if (this.skipNextNewLine && (this.skipNextNewLine = false, t2.chars.charCodeAt(0) === m.LINE_FEED)) {
      if (t2.chars.length === 1)
        return;
      t2.chars = t2.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t2);
      return;
    }
    switch (this.insertionMode) {
      case g.IN_HEAD:
      case g.IN_HEAD_NO_SCRIPT:
      case g.AFTER_HEAD:
      case g.TEXT:
      case g.IN_COLUMN_GROUP:
      case g.IN_SELECT:
      case g.IN_SELECT_IN_TABLE:
      case g.IN_FRAMESET:
      case g.AFTER_FRAMESET: {
        this._insertCharacters(t2);
        break;
      }
      case g.IN_BODY:
      case g.IN_CAPTION:
      case g.IN_CELL:
      case g.IN_TEMPLATE:
      case g.AFTER_BODY:
      case g.AFTER_AFTER_BODY:
      case g.AFTER_AFTER_FRAMESET: {
        _a(this, t2);
        break;
      }
      case g.IN_TABLE:
      case g.IN_TABLE_BODY:
      case g.IN_ROW: {
        Wn(this, t2);
        break;
      }
      case g.IN_TABLE_TEXT: {
        ya(this, t2);
        break;
      }
    }
  }
};
function Kl(e2, t2) {
  let n = e2.activeFormattingElements.getElementEntryInScopeWithTagName(t2.tagName);
  return n ? e2.openElements.contains(n.element) ? e2.openElements.hasInScope(t2.tagID) || (n = null) : (e2.activeFormattingElements.removeEntry(n), n = null) : Ia(e2, t2), n;
}
function Jl(e2, t2) {
  let n = null, r2 = e2.openElements.stackTop;
  for (; r2 >= 0; r2--) {
    const u = e2.openElements.items[r2];
    if (u === t2.element)
      break;
    e2._isSpecialElement(u, e2.openElements.tagIDs[r2]) && (n = u);
  }
  return n || (e2.openElements.shortenToLength(r2 < 0 ? 0 : r2), e2.activeFormattingElements.removeEntry(t2)), n;
}
function Zl(e2, t2, n) {
  let r2 = t2, u = e2.openElements.getCommonAncestor(t2);
  for (let a = 0, i = u; i !== n; a++, i = u) {
    u = e2.openElements.getCommonAncestor(i);
    const o = e2.activeFormattingElements.getElementEntry(i), l3 = o && a >= $l;
    !o || l3 ? (l3 && e2.activeFormattingElements.removeEntry(o), e2.openElements.remove(i)) : (i = ec(e2, o), r2 === t2 && (e2.activeFormattingElements.bookmark = o), e2.treeAdapter.detachNode(r2), e2.treeAdapter.appendChild(i, r2), r2 = i);
  }
  return r2;
}
function ec(e2, t2) {
  const n = e2.treeAdapter.getNamespaceURI(t2.element), r2 = e2.treeAdapter.createElement(t2.token.tagName, n, t2.token.attrs);
  return e2.openElements.replace(t2.element, r2), t2.element = r2, r2;
}
function tc(e2, t2, n) {
  const r2 = e2.treeAdapter.getTagName(t2), u = xt(r2);
  if (e2._isElementCausesFosterParenting(u))
    e2._fosterParentElement(n);
  else {
    const a = e2.treeAdapter.getNamespaceURI(t2);
    u === s.TEMPLATE && a === R.HTML && (t2 = e2.treeAdapter.getTemplateContent(t2)), e2.treeAdapter.appendChild(t2, n);
  }
}
function nc(e2, t2, n) {
  const r2 = e2.treeAdapter.getNamespaceURI(n.element), { token: u } = n, a = e2.treeAdapter.createElement(u.tagName, r2, u.attrs);
  e2._adoptNodes(t2, a), e2.treeAdapter.appendChild(t2, a), e2.activeFormattingElements.insertElementAfterBookmark(a, u), e2.activeFormattingElements.removeEntry(n), e2.openElements.remove(n.element), e2.openElements.insertAfter(t2, a, u.tagID);
}
function Ur(e2, t2) {
  for (let n = 0; n < Ql; n++) {
    const r2 = Kl(e2, t2);
    if (!r2)
      break;
    const u = Jl(e2, r2);
    if (!u)
      break;
    e2.activeFormattingElements.bookmark = r2;
    const a = Zl(e2, u, r2.element), i = e2.openElements.getCommonAncestor(r2.element);
    e2.treeAdapter.detachNode(a), i && tc(e2, i, a), nc(e2, u, r2);
  }
}
function Er(e2, t2) {
  e2._appendCommentNode(t2, e2.openElements.currentTmplContentOrNode);
}
function rc(e2, t2) {
  e2._appendCommentNode(t2, e2.openElements.items[0]);
}
function uc(e2, t2) {
  e2._appendCommentNode(t2, e2.document);
}
function vr(e2, t2) {
  if (e2.stopped = true, t2.location) {
    const n = e2.fragmentContext ? 0 : 2;
    for (let r2 = e2.openElements.stackTop; r2 >= n; r2--)
      e2._setEndLocation(e2.openElements.items[r2], t2);
    if (!e2.fragmentContext && e2.openElements.stackTop >= 0) {
      const r2 = e2.openElements.items[0], u = e2.treeAdapter.getNodeSourceCodeLocation(r2);
      if (u && !u.endTag && (e2._setEndLocation(r2, t2), e2.openElements.stackTop >= 1)) {
        const a = e2.openElements.items[1], i = e2.treeAdapter.getNodeSourceCodeLocation(a);
        i && !i.endTag && e2._setEndLocation(a, t2);
      }
    }
  }
}
function ic(e2, t2) {
  e2._setDocumentType(t2);
  const n = t2.forceQuirks ? xe.QUIRKS : Ml(t2);
  wl(t2) || e2._err(t2, x.nonConformingDoctype), e2.treeAdapter.setDocumentMode(e2.document, n), e2.insertionMode = g.BEFORE_HTML;
}
function Dt(e2, t2) {
  e2._err(t2, x.missingDoctype, true), e2.treeAdapter.setDocumentMode(e2.document, xe.QUIRKS), e2.insertionMode = g.BEFORE_HTML, e2._processToken(t2);
}
function ac(e2, t2) {
  t2.tagID === s.HTML ? (e2._insertElement(t2, R.HTML), e2.insertionMode = g.BEFORE_HEAD) : zt(e2, t2);
}
function sc(e2, t2) {
  const n = t2.tagID;
  (n === s.HTML || n === s.HEAD || n === s.BODY || n === s.BR) && zt(e2, t2);
}
function zt(e2, t2) {
  e2._insertFakeRootElement(), e2.insertionMode = g.BEFORE_HEAD, e2._processToken(t2);
}
function oc(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.HEAD: {
      e2._insertElement(t2, R.HTML), e2.headElement = e2.openElements.current, e2.insertionMode = g.IN_HEAD;
      break;
    }
    default:
      Yt(e2, t2);
  }
}
function lc(e2, t2) {
  const n = t2.tagID;
  n === s.HEAD || n === s.BODY || n === s.HTML || n === s.BR ? Yt(e2, t2) : e2._err(t2, x.endTagWithoutMatchingOpenElement);
}
function Yt(e2, t2) {
  e2._insertFakeElement(_.HEAD, s.HEAD), e2.headElement = e2.openElements.current, e2.insertionMode = g.IN_HEAD, e2._processToken(t2);
}
function Re(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e2._appendElement(t2, R.HTML), t2.ackSelfClosing = true;
      break;
    }
    case s.TITLE: {
      e2._switchToTextParsing(t2, ae2.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e2.options.scriptingEnabled ? e2._switchToTextParsing(t2, ae2.RAWTEXT) : (e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e2._switchToTextParsing(t2, ae2.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e2._switchToTextParsing(t2, ae2.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e2._insertTemplate(t2), e2.activeFormattingElements.insertMarker(), e2.framesetOk = false, e2.insertionMode = g.IN_TEMPLATE, e2.tmplInsertionModeStack.unshift(g.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e2._err(t2, x.misplacedStartTagForHeadElement);
      break;
    }
    default:
      qt(e2, t2);
  }
}
function cc(e2, t2) {
  switch (t2.tagID) {
    case s.HEAD: {
      e2.openElements.pop(), e2.insertionMode = g.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      qt(e2, t2);
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
    default:
      e2._err(t2, x.endTagWithoutMatchingOpenElement);
  }
}
function it(e2, t2) {
  e2.openElements.tmplCount > 0 ? (e2.openElements.generateImpliedEndTagsThoroughly(), e2.openElements.currentTagId !== s.TEMPLATE && e2._err(t2, x.closingOfElementWithOpenChildElements), e2.openElements.popUntilTagNamePopped(s.TEMPLATE), e2.activeFormattingElements.clearToLastMarker(), e2.tmplInsertionModeStack.shift(), e2._resetInsertionMode()) : e2._err(t2, x.endTagWithoutMatchingOpenElement);
}
function qt(e2, t2) {
  e2.openElements.pop(), e2.insertionMode = g.AFTER_HEAD, e2._processToken(t2);
}
function fc(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Re(e2, t2);
      break;
    }
    case s.NOSCRIPT: {
      e2._err(t2, x.nestedNoscriptInHead);
      break;
    }
    default:
      jt(e2, t2);
  }
}
function hc(e2, t2) {
  switch (t2.tagID) {
    case s.NOSCRIPT: {
      e2.openElements.pop(), e2.insertionMode = g.IN_HEAD;
      break;
    }
    case s.BR: {
      jt(e2, t2);
      break;
    }
    default:
      e2._err(t2, x.endTagWithoutMatchingOpenElement);
  }
}
function jt(e2, t2) {
  const n = t2.type === $.EOF ? x.openElementsLeftAfterEof : x.disallowedContentInNoscriptInHead;
  e2._err(t2, n), e2.openElements.pop(), e2.insertionMode = g.IN_HEAD, e2._processToken(t2);
}
function dc(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.BODY: {
      e2._insertElement(t2, R.HTML), e2.framesetOk = false, e2.insertionMode = g.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e2._err(t2, x.abandonedHeadElementChild), e2.openElements.push(e2.headElement, s.HEAD), Re(e2, t2), e2.openElements.remove(e2.headElement);
      break;
    }
    case s.HEAD: {
      e2._err(t2, x.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Vt(e2, t2);
  }
}
function mc(e2, t2) {
  switch (t2.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      Vt(e2, t2);
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
    default:
      e2._err(t2, x.endTagWithoutMatchingOpenElement);
  }
}
function Vt(e2, t2) {
  e2._insertFakeElement(_.BODY, s.BODY), e2.insertionMode = g.IN_BODY, Rn(e2, t2);
}
function Rn(e2, t2) {
  switch (t2.type) {
    case $.CHARACTER: {
      Ca(e2, t2);
      break;
    }
    case $.WHITESPACE_CHARACTER: {
      _a(e2, t2);
      break;
    }
    case $.COMMENT: {
      Er(e2, t2);
      break;
    }
    case $.START_TAG: {
      pe(e2, t2);
      break;
    }
    case $.END_TAG: {
      Dn(e2, t2);
      break;
    }
    case $.EOF: {
      ka(e2, t2);
      break;
    }
  }
}
function _a(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertCharacters(t2);
}
function Ca(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertCharacters(t2), e2.framesetOk = false;
}
function pc(e2, t2) {
  e2.openElements.tmplCount === 0 && e2.treeAdapter.adoptAttributes(e2.openElements.items[0], t2.attrs);
}
function Ec(e2, t2) {
  const n = e2.openElements.tryPeekProperlyNestedBodyElement();
  n && e2.openElements.tmplCount === 0 && (e2.framesetOk = false, e2.treeAdapter.adoptAttributes(n, t2.attrs));
}
function gc(e2, t2) {
  const n = e2.openElements.tryPeekProperlyNestedBodyElement();
  e2.framesetOk && n && (e2.treeAdapter.detachNode(n), e2.openElements.popAllUpToHtmlElement(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_FRAMESET);
}
function Tc(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML);
}
function bc(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), pr.has(e2.openElements.currentTagId) && e2.openElements.pop(), e2._insertElement(t2, R.HTML);
}
function Ac(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML), e2.skipNextNewLine = true, e2.framesetOk = false;
}
function _c(e2, t2) {
  const n = e2.openElements.tmplCount > 0;
  (!e2.formElement || n) && (e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML), n || (e2.formElement = e2.openElements.current));
}
function Cc(e2, t2) {
  e2.framesetOk = false;
  const n = t2.tagID;
  for (let r2 = e2.openElements.stackTop; r2 >= 0; r2--) {
    const u = e2.openElements.tagIDs[r2];
    if (n === s.LI && u === s.LI || (n === s.DD || n === s.DT) && (u === s.DD || u === s.DT)) {
      e2.openElements.generateImpliedEndTagsWithExclusion(u), e2.openElements.popUntilTagNamePopped(u);
      break;
    }
    if (u !== s.ADDRESS && u !== s.DIV && u !== s.P && e2._isSpecialElement(e2.openElements.items[r2], u))
      break;
  }
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML);
}
function Sc(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML), e2.tokenizer.state = ae2.PLAINTEXT;
}
function xc(e2, t2) {
  e2.openElements.hasInScope(s.BUTTON) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.BUTTON)), e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML), e2.framesetOk = false;
}
function Ic(e2, t2) {
  const n = e2.activeFormattingElements.getElementEntryInScopeWithTagName(_.A);
  n && (Ur(e2, t2), e2.openElements.remove(n.element), e2.activeFormattingElements.removeEntry(n)), e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t2);
}
function kc(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t2);
}
function yc(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2.openElements.hasInScope(s.NOBR) && (Ur(e2, t2), e2._reconstructActiveFormattingElements()), e2._insertElement(t2, R.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t2);
}
function Nc(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML), e2.activeFormattingElements.insertMarker(), e2.framesetOk = false;
}
function Oc(e2, t2) {
  e2.treeAdapter.getDocumentMode(e2.document) !== xe.QUIRKS && e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t2, R.HTML), e2.framesetOk = false, e2.insertionMode = g.IN_TABLE;
}
function Sa(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._appendElement(t2, R.HTML), e2.framesetOk = false, t2.ackSelfClosing = true;
}
function xa(e2) {
  const t2 = la(e2, nt.TYPE);
  return t2 != null && t2.toLowerCase() === Gl;
}
function Lc(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._appendElement(t2, R.HTML), xa(t2) || (e2.framesetOk = false), t2.ackSelfClosing = true;
}
function Rc(e2, t2) {
  e2._appendElement(t2, R.HTML), t2.ackSelfClosing = true;
}
function Dc(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._appendElement(t2, R.HTML), e2.framesetOk = false, t2.ackSelfClosing = true;
}
function Pc(e2, t2) {
  t2.tagName = _.IMG, t2.tagID = s.IMG, Sa(e2, t2);
}
function wc(e2, t2) {
  e2._insertElement(t2, R.HTML), e2.skipNextNewLine = true, e2.tokenizer.state = ae2.RCDATA, e2.originalInsertionMode = e2.insertionMode, e2.framesetOk = false, e2.insertionMode = g.TEXT;
}
function Mc(e2, t2) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._reconstructActiveFormattingElements(), e2.framesetOk = false, e2._switchToTextParsing(t2, ae2.RAWTEXT);
}
function Bc(e2, t2) {
  e2.framesetOk = false, e2._switchToTextParsing(t2, ae2.RAWTEXT);
}
function Bu(e2, t2) {
  e2._switchToTextParsing(t2, ae2.RAWTEXT);
}
function Fc(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML), e2.framesetOk = false, e2.insertionMode = e2.insertionMode === g.IN_TABLE || e2.insertionMode === g.IN_CAPTION || e2.insertionMode === g.IN_TABLE_BODY || e2.insertionMode === g.IN_ROW || e2.insertionMode === g.IN_CELL ? g.IN_SELECT_IN_TABLE : g.IN_SELECT;
}
function Hc(e2, t2) {
  e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML);
}
function Uc(e2, t2) {
  e2.openElements.hasInScope(s.RUBY) && e2.openElements.generateImpliedEndTags(), e2._insertElement(t2, R.HTML);
}
function vc(e2, t2) {
  e2.openElements.hasInScope(s.RUBY) && e2.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e2._insertElement(t2, R.HTML);
}
function zc(e2, t2) {
  e2._reconstructActiveFormattingElements(), Ta(t2), Hr(t2), t2.selfClosing ? e2._appendElement(t2, R.MATHML) : e2._insertElement(t2, R.MATHML), t2.ackSelfClosing = true;
}
function Yc(e2, t2) {
  e2._reconstructActiveFormattingElements(), ba(t2), Hr(t2), t2.selfClosing ? e2._appendElement(t2, R.SVG) : e2._insertElement(t2, R.SVG), t2.ackSelfClosing = true;
}
function Fu(e2, t2) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t2, R.HTML);
}
function pe(e2, t2) {
  switch (t2.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      kc(e2, t2);
      break;
    }
    case s.A: {
      Ic(e2, t2);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      bc(e2, t2);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Tc(e2, t2);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      Cc(e2, t2);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      Sa(e2, t2);
      break;
    }
    case s.HR: {
      Dc(e2, t2);
      break;
    }
    case s.RB:
    case s.RTC: {
      Uc(e2, t2);
      break;
    }
    case s.RT:
    case s.RP: {
      vc(e2, t2);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Ac(e2, t2);
      break;
    }
    case s.XMP: {
      Mc(e2, t2);
      break;
    }
    case s.SVG: {
      Yc(e2, t2);
      break;
    }
    case s.HTML: {
      pc(e2, t2);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Re(e2, t2);
      break;
    }
    case s.BODY: {
      Ec(e2, t2);
      break;
    }
    case s.FORM: {
      _c(e2, t2);
      break;
    }
    case s.NOBR: {
      yc(e2, t2);
      break;
    }
    case s.MATH: {
      zc(e2, t2);
      break;
    }
    case s.TABLE: {
      Oc(e2, t2);
      break;
    }
    case s.INPUT: {
      Lc(e2, t2);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      Rc(e2, t2);
      break;
    }
    case s.IMAGE: {
      Pc(e2, t2);
      break;
    }
    case s.BUTTON: {
      xc(e2, t2);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Nc(e2, t2);
      break;
    }
    case s.IFRAME: {
      Bc(e2, t2);
      break;
    }
    case s.SELECT: {
      Fc(e2, t2);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      Hc(e2, t2);
      break;
    }
    case s.NOEMBED:
    case s.NOFRAMES: {
      Bu(e2, t2);
      break;
    }
    case s.FRAMESET: {
      gc(e2, t2);
      break;
    }
    case s.TEXTAREA: {
      wc(e2, t2);
      break;
    }
    case s.NOSCRIPT: {
      e2.options.scriptingEnabled ? Bu(e2, t2) : Fu(e2, t2);
      break;
    }
    case s.PLAINTEXT: {
      Sc(e2, t2);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      Fu(e2, t2);
  }
}
function qc(e2, t2) {
  if (e2.openElements.hasInScope(s.BODY) && (e2.insertionMode = g.AFTER_BODY, e2.options.sourceCodeLocationInfo)) {
    const n = e2.openElements.tryPeekProperlyNestedBodyElement();
    n && e2._setEndLocation(n, t2);
  }
}
function jc(e2, t2) {
  e2.openElements.hasInScope(s.BODY) && (e2.insertionMode = g.AFTER_BODY, wa(e2, t2));
}
function Vc(e2, t2) {
  const n = t2.tagID;
  e2.openElements.hasInScope(n) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n));
}
function Wc(e2) {
  const t2 = e2.openElements.tmplCount > 0, { formElement: n } = e2;
  t2 || (e2.formElement = null), (n || t2) && e2.openElements.hasInScope(s.FORM) && (e2.openElements.generateImpliedEndTags(), t2 ? e2.openElements.popUntilTagNamePopped(s.FORM) : n && e2.openElements.remove(n));
}
function Gc(e2) {
  e2.openElements.hasInButtonScope(s.P) || e2._insertFakeElement(_.P, s.P), e2._closePElement();
}
function Qc(e2) {
  e2.openElements.hasInListItemScope(s.LI) && (e2.openElements.generateImpliedEndTagsWithExclusion(s.LI), e2.openElements.popUntilTagNamePopped(s.LI));
}
function $c(e2, t2) {
  const n = t2.tagID;
  e2.openElements.hasInScope(n) && (e2.openElements.generateImpliedEndTagsWithExclusion(n), e2.openElements.popUntilTagNamePopped(n));
}
function Xc(e2) {
  e2.openElements.hasNumberedHeaderInScope() && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilNumberedHeaderPopped());
}
function Kc(e2, t2) {
  const n = t2.tagID;
  e2.openElements.hasInScope(n) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n), e2.activeFormattingElements.clearToLastMarker());
}
function Jc(e2) {
  e2._reconstructActiveFormattingElements(), e2._insertFakeElement(_.BR, s.BR), e2.openElements.pop(), e2.framesetOk = false;
}
function Ia(e2, t2) {
  const n = t2.tagName, r2 = t2.tagID;
  for (let u = e2.openElements.stackTop; u > 0; u--) {
    const a = e2.openElements.items[u], i = e2.openElements.tagIDs[u];
    if (r2 === i && (r2 !== s.UNKNOWN || e2.treeAdapter.getTagName(a) === n)) {
      e2.openElements.generateImpliedEndTagsWithExclusion(r2), e2.openElements.stackTop >= u && e2.openElements.shortenToLength(u);
      break;
    }
    if (e2._isSpecialElement(a, i))
      break;
  }
}
function Dn(e2, t2) {
  switch (t2.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Ur(e2, t2);
      break;
    }
    case s.P: {
      Gc(e2);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Vc(e2, t2);
      break;
    }
    case s.LI: {
      Qc(e2);
      break;
    }
    case s.DD:
    case s.DT: {
      $c(e2, t2);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      Xc(e2);
      break;
    }
    case s.BR: {
      Jc(e2);
      break;
    }
    case s.BODY: {
      qc(e2, t2);
      break;
    }
    case s.HTML: {
      jc(e2, t2);
      break;
    }
    case s.FORM: {
      Wc(e2);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Kc(e2, t2);
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
    default:
      Ia(e2, t2);
  }
}
function ka(e2, t2) {
  e2.tmplInsertionModeStack.length > 0 ? Pa(e2, t2) : vr(e2, t2);
}
function Zc(e2, t2) {
  var n;
  t2.tagID === s.SCRIPT && ((n = e2.scriptHandler) === null || n === void 0 || n.call(e2, e2.openElements.current)), e2.openElements.pop(), e2.insertionMode = e2.originalInsertionMode;
}
function e0(e2, t2) {
  e2._err(t2, x.eofInElementThatCanContainOnlyText), e2.openElements.pop(), e2.insertionMode = e2.originalInsertionMode, e2.onEof(t2);
}
function Wn(e2, t2) {
  if (Aa.has(e2.openElements.currentTagId))
    switch (e2.pendingCharacterTokens.length = 0, e2.hasNonWhitespacePendingCharacterToken = false, e2.originalInsertionMode = e2.insertionMode, e2.insertionMode = g.IN_TABLE_TEXT, t2.type) {
      case $.CHARACTER: {
        Na(e2, t2);
        break;
      }
      case $.WHITESPACE_CHARACTER: {
        ya(e2, t2);
        break;
      }
    }
  else
    tn(e2, t2);
}
function t0(e2, t2) {
  e2.openElements.clearBackToTableContext(), e2.activeFormattingElements.insertMarker(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_CAPTION;
}
function n0(e2, t2) {
  e2.openElements.clearBackToTableContext(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_COLUMN_GROUP;
}
function r0(e2, t2) {
  e2.openElements.clearBackToTableContext(), e2._insertFakeElement(_.COLGROUP, s.COLGROUP), e2.insertionMode = g.IN_COLUMN_GROUP, zr(e2, t2);
}
function u0(e2, t2) {
  e2.openElements.clearBackToTableContext(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_TABLE_BODY;
}
function i0(e2, t2) {
  e2.openElements.clearBackToTableContext(), e2._insertFakeElement(_.TBODY, s.TBODY), e2.insertionMode = g.IN_TABLE_BODY, Pn(e2, t2);
}
function a0(e2, t2) {
  e2.openElements.hasInTableScope(s.TABLE) && (e2.openElements.popUntilTagNamePopped(s.TABLE), e2._resetInsertionMode(), e2._processStartTag(t2));
}
function s0(e2, t2) {
  xa(t2) ? e2._appendElement(t2, R.HTML) : tn(e2, t2), t2.ackSelfClosing = true;
}
function o0(e2, t2) {
  !e2.formElement && e2.openElements.tmplCount === 0 && (e2._insertElement(t2, R.HTML), e2.formElement = e2.openElements.current, e2.openElements.pop());
}
function At(e2, t2) {
  switch (t2.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      i0(e2, t2);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Re(e2, t2);
      break;
    }
    case s.COL: {
      r0(e2, t2);
      break;
    }
    case s.FORM: {
      o0(e2, t2);
      break;
    }
    case s.TABLE: {
      a0(e2, t2);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      u0(e2, t2);
      break;
    }
    case s.INPUT: {
      s0(e2, t2);
      break;
    }
    case s.CAPTION: {
      t0(e2, t2);
      break;
    }
    case s.COLGROUP: {
      n0(e2, t2);
      break;
    }
    default:
      tn(e2, t2);
  }
}
function Xt(e2, t2) {
  switch (t2.tagID) {
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.TABLE) && (e2.openElements.popUntilTagNamePopped(s.TABLE), e2._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      tn(e2, t2);
  }
}
function tn(e2, t2) {
  const n = e2.fosterParentingEnabled;
  e2.fosterParentingEnabled = true, Rn(e2, t2), e2.fosterParentingEnabled = n;
}
function ya(e2, t2) {
  e2.pendingCharacterTokens.push(t2);
}
function Na(e2, t2) {
  e2.pendingCharacterTokens.push(t2), e2.hasNonWhitespacePendingCharacterToken = true;
}
function Pt(e2, t2) {
  let n = 0;
  if (e2.hasNonWhitespacePendingCharacterToken)
    for (; n < e2.pendingCharacterTokens.length; n++)
      tn(e2, e2.pendingCharacterTokens[n]);
  else
    for (; n < e2.pendingCharacterTokens.length; n++)
      e2._insertCharacters(e2.pendingCharacterTokens[n]);
  e2.insertionMode = e2.originalInsertionMode, e2._processToken(t2);
}
var Oa = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function l0(e2, t2) {
  const n = t2.tagID;
  Oa.has(n) ? e2.openElements.hasInTableScope(s.CAPTION) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.CAPTION), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = g.IN_TABLE, At(e2, t2)) : pe(e2, t2);
}
function c0(e2, t2) {
  const n = t2.tagID;
  switch (n) {
    case s.CAPTION:
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.CAPTION) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.CAPTION), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = g.IN_TABLE, n === s.TABLE && Xt(e2, t2));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Dn(e2, t2);
  }
}
function zr(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.COL: {
      e2._appendElement(t2, R.HTML), t2.ackSelfClosing = true;
      break;
    }
    case s.TEMPLATE: {
      Re(e2, t2);
      break;
    }
    default:
      Sn(e2, t2);
  }
}
function f0(e2, t2) {
  switch (t2.tagID) {
    case s.COLGROUP: {
      e2.openElements.currentTagId === s.COLGROUP && (e2.openElements.pop(), e2.insertionMode = g.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
    case s.COL:
      break;
    default:
      Sn(e2, t2);
  }
}
function Sn(e2, t2) {
  e2.openElements.currentTagId === s.COLGROUP && (e2.openElements.pop(), e2.insertionMode = g.IN_TABLE, e2._processToken(t2));
}
function Pn(e2, t2) {
  switch (t2.tagID) {
    case s.TR: {
      e2.openElements.clearBackToTableBodyContext(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e2.openElements.clearBackToTableBodyContext(), e2._insertFakeElement(_.TR, s.TR), e2.insertionMode = g.IN_ROW, wn(e2, t2);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.openElements.hasTableBodyContextInTableScope() && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE, At(e2, t2));
      break;
    }
    default:
      At(e2, t2);
  }
}
function gr(e2, t2) {
  const n = t2.tagID;
  switch (t2.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.openElements.hasInTableScope(n) && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e2.openElements.hasTableBodyContextInTableScope() && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE, Xt(e2, t2));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      Xt(e2, t2);
  }
}
function wn(e2, t2) {
  switch (t2.tagID) {
    case s.TH:
    case s.TD: {
      e2.openElements.clearBackToTableRowContext(), e2._insertElement(t2, R.HTML), e2.insertionMode = g.IN_CELL, e2.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE_BODY, Pn(e2, t2));
      break;
    }
    default:
      At(e2, t2);
  }
}
function La(e2, t2) {
  switch (t2.tagID) {
    case s.TR: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE_BODY, gr(e2, t2));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e2.openElements.hasInTableScope(t2.tagID) || e2.openElements.hasInTableScope(s.TR)) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = g.IN_TABLE_BODY, gr(e2, t2));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      Xt(e2, t2);
  }
}
function h0(e2, t2) {
  const n = t2.tagID;
  Oa.has(n) ? (e2.openElements.hasInTableScope(s.TD) || e2.openElements.hasInTableScope(s.TH)) && (e2._closeTableCell(), wn(e2, t2)) : pe(e2, t2);
}
function d0(e2, t2) {
  const n = t2.tagID;
  switch (n) {
    case s.TD:
    case s.TH: {
      e2.openElements.hasInTableScope(n) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = g.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e2.openElements.hasInTableScope(n) && (e2._closeTableCell(), La(e2, t2));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Dn(e2, t2);
  }
}
function Ra(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.OPTION: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2._insertElement(t2, R.HTML);
      break;
    }
    case s.OPTGROUP: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2.openElements.currentTagId === s.OPTGROUP && e2.openElements.pop(), e2._insertElement(t2, R.HTML);
      break;
    }
    case s.HR: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2.openElements.currentTagId === s.OPTGROUP && e2.openElements.pop(), e2._appendElement(t2, R.HTML), t2.ackSelfClosing = true;
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e2.openElements.hasInSelectScope(s.SELECT) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), t2.tagID !== s.SELECT && e2._processStartTag(t2));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Re(e2, t2);
      break;
    }
  }
}
function Da(e2, t2) {
  switch (t2.tagID) {
    case s.OPTGROUP: {
      e2.openElements.stackTop > 0 && e2.openElements.currentTagId === s.OPTION && e2.openElements.tagIDs[e2.openElements.stackTop - 1] === s.OPTGROUP && e2.openElements.pop(), e2.openElements.currentTagId === s.OPTGROUP && e2.openElements.pop();
      break;
    }
    case s.OPTION: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop();
      break;
    }
    case s.SELECT: {
      e2.openElements.hasInSelectScope(s.SELECT) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      it(e2, t2);
      break;
    }
  }
}
function m0(e2, t2) {
  const n = t2.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), e2._processStartTag(t2)) : Ra(e2, t2);
}
function p0(e2, t2) {
  const n = t2.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? e2.openElements.hasInTableScope(n) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), e2.onEndTag(t2)) : Da(e2, t2);
}
function E0(e2, t2) {
  switch (t2.tagID) {
    // First, handle tags that can start without a mode change
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Re(e2, t2);
      break;
    }
    // Re-process the token in the appropriate mode
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.tmplInsertionModeStack[0] = g.IN_TABLE, e2.insertionMode = g.IN_TABLE, At(e2, t2);
      break;
    }
    case s.COL: {
      e2.tmplInsertionModeStack[0] = g.IN_COLUMN_GROUP, e2.insertionMode = g.IN_COLUMN_GROUP, zr(e2, t2);
      break;
    }
    case s.TR: {
      e2.tmplInsertionModeStack[0] = g.IN_TABLE_BODY, e2.insertionMode = g.IN_TABLE_BODY, Pn(e2, t2);
      break;
    }
    case s.TD:
    case s.TH: {
      e2.tmplInsertionModeStack[0] = g.IN_ROW, e2.insertionMode = g.IN_ROW, wn(e2, t2);
      break;
    }
    default:
      e2.tmplInsertionModeStack[0] = g.IN_BODY, e2.insertionMode = g.IN_BODY, pe(e2, t2);
  }
}
function g0(e2, t2) {
  t2.tagID === s.TEMPLATE && it(e2, t2);
}
function Pa(e2, t2) {
  e2.openElements.tmplCount > 0 ? (e2.openElements.popUntilTagNamePopped(s.TEMPLATE), e2.activeFormattingElements.clearToLastMarker(), e2.tmplInsertionModeStack.shift(), e2._resetInsertionMode(), e2.onEof(t2)) : vr(e2, t2);
}
function T0(e2, t2) {
  t2.tagID === s.HTML ? pe(e2, t2) : xn(e2, t2);
}
function wa(e2, t2) {
  var n;
  if (t2.tagID === s.HTML) {
    if (e2.fragmentContext || (e2.insertionMode = g.AFTER_AFTER_BODY), e2.options.sourceCodeLocationInfo && e2.openElements.tagIDs[0] === s.HTML) {
      e2._setEndLocation(e2.openElements.items[0], t2);
      const r2 = e2.openElements.items[1];
      r2 && !(!((n = e2.treeAdapter.getNodeSourceCodeLocation(r2)) === null || n === void 0) && n.endTag) && e2._setEndLocation(r2, t2);
    }
  } else
    xn(e2, t2);
}
function xn(e2, t2) {
  e2.insertionMode = g.IN_BODY, Rn(e2, t2);
}
function b0(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.FRAMESET: {
      e2._insertElement(t2, R.HTML);
      break;
    }
    case s.FRAME: {
      e2._appendElement(t2, R.HTML), t2.ackSelfClosing = true;
      break;
    }
    case s.NOFRAMES: {
      Re(e2, t2);
      break;
    }
  }
}
function A0(e2, t2) {
  t2.tagID === s.FRAMESET && !e2.openElements.isRootHtmlElementCurrent() && (e2.openElements.pop(), !e2.fragmentContext && e2.openElements.currentTagId !== s.FRAMESET && (e2.insertionMode = g.AFTER_FRAMESET));
}
function _0(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.NOFRAMES: {
      Re(e2, t2);
      break;
    }
  }
}
function C0(e2, t2) {
  t2.tagID === s.HTML && (e2.insertionMode = g.AFTER_AFTER_FRAMESET);
}
function S0(e2, t2) {
  t2.tagID === s.HTML ? pe(e2, t2) : En(e2, t2);
}
function En(e2, t2) {
  e2.insertionMode = g.IN_BODY, Rn(e2, t2);
}
function x0(e2, t2) {
  switch (t2.tagID) {
    case s.HTML: {
      pe(e2, t2);
      break;
    }
    case s.NOFRAMES: {
      Re(e2, t2);
      break;
    }
  }
}
function I0(e2, t2) {
  t2.chars = ie, e2._insertCharacters(t2);
}
function k0(e2, t2) {
  e2._insertCharacters(t2), e2.framesetOk = false;
}
function Ma(e2) {
  for (; e2.treeAdapter.getNamespaceURI(e2.openElements.current) !== R.HTML && !e2._isIntegrationPoint(e2.openElements.currentTagId, e2.openElements.current); )
    e2.openElements.pop();
}
function y0(e2, t2) {
  if (Yl(t2))
    Ma(e2), e2._startTagOutsideForeignContent(t2);
  else {
    const n = e2._getAdjustedCurrentElement(), r2 = e2.treeAdapter.getNamespaceURI(n);
    r2 === R.MATHML ? Ta(t2) : r2 === R.SVG && (ql(t2), ba(t2)), Hr(t2), t2.selfClosing ? e2._appendElement(t2, r2) : e2._insertElement(t2, r2), t2.ackSelfClosing = true;
  }
}
function N0(e2, t2) {
  if (t2.tagID === s.P || t2.tagID === s.BR) {
    Ma(e2), e2._endTagOutsideForeignContent(t2);
    return;
  }
  for (let n = e2.openElements.stackTop; n > 0; n--) {
    const r2 = e2.openElements.items[n];
    if (e2.treeAdapter.getNamespaceURI(r2) === R.HTML) {
      e2._endTagOutsideForeignContent(t2);
      break;
    }
    const u = e2.treeAdapter.getTagName(r2);
    if (u.toLowerCase() === t2.tagName) {
      t2.tagName = u, e2.openElements.shortenToLength(n);
      break;
    }
  }
}
_.AREA, _.BASE, _.BASEFONT, _.BGSOUND, _.BR, _.COL, _.EMBED, _.FRAME, _.HR, _.IMG, _.INPUT, _.KEYGEN, _.LINK, _.META, _.PARAM, _.SOURCE, _.TRACK, _.WBR;
var Mn = Ba("end");
var Me = Ba("start");
function Ba(e2) {
  return t2;
  function t2(n) {
    const r2 = n && n.position && n.position[e2] || {};
    if (typeof r2.line == "number" && r2.line > 0 && typeof r2.column == "number" && r2.column > 0)
      return {
        line: r2.line,
        column: r2.column,
        offset: typeof r2.offset == "number" && r2.offset > -1 ? r2.offset : void 0
      };
  }
}
function O0(e2) {
  const t2 = Me(e2), n = Mn(e2);
  if (t2 && n)
    return { start: t2, end: n };
}
var Bn = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e2) {
    if (e2 == null)
      return P0;
    if (typeof e2 == "function")
      return Fn(e2);
    if (typeof e2 == "object")
      return Array.isArray(e2) ? L0(e2) : R0(e2);
    if (typeof e2 == "string")
      return D0(e2);
    throw new Error("Expected function, string, or object as test");
  }
);
function L0(e2) {
  const t2 = [];
  let n = -1;
  for (; ++n < e2.length; )
    t2[n] = Bn(e2[n]);
  return Fn(r2);
  function r2(...u) {
    let a = -1;
    for (; ++a < t2.length; )
      if (t2[a].apply(this, u)) return true;
    return false;
  }
}
function R0(e2) {
  const t2 = (
    /** @type {Record<string, unknown>} */
    e2
  );
  return Fn(n);
  function n(r2) {
    const u = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r2
    );
    let a;
    for (a in e2)
      if (u[a] !== t2[a]) return false;
    return true;
  }
}
function D0(e2) {
  return Fn(t2);
  function t2(n) {
    return n && n.type === e2;
  }
}
function Fn(e2) {
  return t2;
  function t2(n, r2, u) {
    return !!(w0(n) && e2.call(
      this,
      n,
      typeof r2 == "number" ? r2 : void 0,
      u || void 0
    ));
  }
}
function P0() {
  return true;
}
function w0(e2) {
  return e2 !== null && typeof e2 == "object" && "type" in e2;
}
var Fa = [];
var M0 = true;
var Tr = false;
var B0 = "skip";
function Ha(e2, t2, n, r2) {
  let u;
  typeof t2 == "function" && typeof n != "function" ? (r2 = n, n = t2) : u = t2;
  const a = Bn(u), i = r2 ? -1 : 1;
  o(e2, void 0, [])();
  function o(l3, c, h) {
    const f2 = (
      /** @type {Record<string, unknown>} */
      l3 && typeof l3 == "object" ? l3 : {}
    );
    if (typeof f2.type == "string") {
      const d = (
        // `hast`
        typeof f2.tagName == "string" ? f2.tagName : (
          // `xast`
          typeof f2.name == "string" ? f2.name : void 0
        )
      );
      Object.defineProperty(p2, "name", {
        value: "node (" + (l3.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return p2;
    function p2() {
      let d = Fa, A, C, y2;
      if ((!t2 || a(l3, c, h[h.length - 1] || void 0)) && (d = F0(n(l3, h)), d[0] === Tr))
        return d;
      if ("children" in l3 && l3.children) {
        const S = (
          /** @type {UnistParent} */
          l3
        );
        if (S.children && d[0] !== B0)
          for (C = (r2 ? S.children.length : -1) + i, y2 = h.concat(S); C > -1 && C < S.children.length; ) {
            const O = S.children[C];
            if (A = o(O, C, y2)(), A[0] === Tr)
              return A;
            C = typeof A[1] == "number" ? A[1] : C + i;
          }
      }
      return d;
    }
  }
}
function F0(e2) {
  return Array.isArray(e2) ? e2 : typeof e2 == "number" ? [M0, e2] : e2 == null ? Fa : [e2];
}
function nn(e2, t2, n, r2) {
  let u, a, i;
  typeof t2 == "function" && typeof n != "function" ? (a = void 0, i = t2, u = n) : (a = t2, i = n, u = r2), Ha(e2, a, o, u);
  function o(l3, c) {
    const h = c[c.length - 1], f2 = h ? h.children.indexOf(l3) : void 0;
    return i(l3, f2, h);
  }
}
var H0 = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi;
var U0 = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]);
var Hu = { sourceCodeLocationInfo: true, scriptingEnabled: false };
function Ua(e2, t2) {
  const n = $0(e2), r2 = ua("type", {
    handlers: { root: v0, element: z0, text: Y0, comment: za, doctype: q0, raw: V0 },
    unknown: W0
  }), u = {
    parser: n ? new Mu(Hu) : Mu.getFragmentParser(void 0, Hu),
    handle(o) {
      r2(o, u);
    },
    stitches: false,
    options: t2 || {}
  };
  r2(e2, u), It(u, Me());
  const a = n ? u.parser.document : u.parser.getFragment(), i = zo(a, {
    // To do: support `space`?
    file: u.options.file
  });
  return u.stitches && nn(i, "comment", function(o, l3, c) {
    const h = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (h.value.stitch && c && l3 !== void 0) {
      const f2 = c.children;
      return f2[l3] = h.value.stitch, l3;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e2.type ? i.children[0] : i;
}
function va(e2, t2) {
  let n = -1;
  if (e2)
    for (; ++n < e2.length; )
      t2.handle(e2[n]);
}
function v0(e2, t2) {
  va(e2.children, t2);
}
function z0(e2, t2) {
  G0(e2, t2), va(e2.children, t2), Q0(e2, t2);
}
function Y0(e2, t2) {
  t2.parser.tokenizer.state > 4 && (t2.parser.tokenizer.state = 0);
  const n = {
    type: $.CHARACTER,
    chars: e2.value,
    location: rn(e2)
  };
  It(t2, Me(e2)), t2.parser.currentToken = n, t2.parser._processToken(t2.parser.currentToken);
}
function q0(e2, t2) {
  const n = {
    type: $.DOCTYPE,
    name: "html",
    forceQuirks: false,
    publicId: "",
    systemId: "",
    location: rn(e2)
  };
  It(t2, Me(e2)), t2.parser.currentToken = n, t2.parser._processToken(t2.parser.currentToken);
}
function j0(e2, t2) {
  t2.stitches = true;
  const n = X0(e2);
  if ("children" in e2 && "children" in n) {
    const r2 = (
      /** @type {Root} */
      Ua({ type: "root", children: e2.children }, t2.options)
    );
    n.children = r2.children;
  }
  za({ type: "comment", value: { stitch: n } }, t2);
}
function za(e2, t2) {
  const n = e2.value, r2 = {
    type: $.COMMENT,
    data: n,
    location: rn(e2)
  };
  It(t2, Me(e2)), t2.parser.currentToken = r2, t2.parser._processToken(t2.parser.currentToken);
}
function V0(e2, t2) {
  if (t2.parser.tokenizer.preprocessor.html = "", t2.parser.tokenizer.preprocessor.pos = -1, t2.parser.tokenizer.preprocessor.lastGapPos = -2, t2.parser.tokenizer.preprocessor.gapStack = [], t2.parser.tokenizer.preprocessor.skipNextNewLine = false, t2.parser.tokenizer.preprocessor.lastChunkWritten = false, t2.parser.tokenizer.preprocessor.endOfChunkHit = false, t2.parser.tokenizer.preprocessor.isEol = false, Ya(t2, Me(e2)), t2.parser.tokenizer.write(
    t2.options.tagfilter ? e2.value.replace(H0, "&lt;$1$2") : e2.value,
    false
  ), t2.parser.tokenizer._runParsingLoop(), t2.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t2.parser.tokenizer.state === 78) {
    t2.parser.tokenizer.preprocessor.lastChunkWritten = true;
    const n = t2.parser.tokenizer._consume();
    t2.parser.tokenizer._callState(n);
  }
}
function W0(e2, t2) {
  const n = (
    /** @type {Nodes} */
    e2
  );
  if (t2.options.passThrough && t2.options.passThrough.includes(n.type))
    j0(n, t2);
  else {
    let r2 = "";
    throw U0.has(n.type) && (r2 = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r2);
  }
}
function It(e2, t2) {
  Ya(e2, t2);
  const n = e2.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e2.parser.tokenizer.preprocessor.line, n.location.endCol = e2.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e2.parser.tokenizer.preprocessor.offset + 1, e2.parser.currentToken = n, e2.parser._processToken(e2.parser.currentToken)), e2.parser.tokenizer.paused = false, e2.parser.tokenizer.inLoop = false, e2.parser.tokenizer.active = false, e2.parser.tokenizer.returnState = ae2.DATA, e2.parser.tokenizer.charRefCode = -1, e2.parser.tokenizer.consumedAfterSnapshot = -1, e2.parser.tokenizer.currentLocation = null, e2.parser.tokenizer.currentCharacterToken = null, e2.parser.tokenizer.currentToken = null, e2.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function Ya(e2, t2) {
  if (t2 && t2.offset !== void 0) {
    const n = {
      startLine: t2.line,
      startCol: t2.column,
      startOffset: t2.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e2.parser.tokenizer.preprocessor.lineStartPos = -t2.column + 1, e2.parser.tokenizer.preprocessor.droppedBufferSize = t2.offset, e2.parser.tokenizer.preprocessor.line = t2.line, e2.parser.tokenizer.currentLocation = n;
  }
}
function G0(e2, t2) {
  const n = e2.tagName.toLowerCase();
  if (t2.parser.tokenizer.state === ae2.PLAINTEXT) return;
  It(t2, Me(e2));
  const r2 = t2.parser.openElements.current;
  let u = "namespaceURI" in r2 ? r2.namespaceURI : tt.html;
  u === tt.html && n === "svg" && (u = tt.svg);
  const a = Wo(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e2, children: [] },
    { space: u === tt.svg ? "svg" : "html" }
  ), i = {
    type: $.START_TAG,
    tagName: n,
    tagID: xt(n),
    // We always send start and end tags.
    selfClosing: false,
    ackSelfClosing: false,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in a ? a.attrs : [],
    location: rn(e2)
  };
  t2.parser.currentToken = i, t2.parser._processToken(t2.parser.currentToken), t2.parser.tokenizer.lastStartTagName = n;
}
function Q0(e2, t2) {
  const n = e2.tagName.toLowerCase();
  if (!t2.parser.tokenizer.inForeignNode && el.includes(n) || t2.parser.tokenizer.state === ae2.PLAINTEXT) return;
  It(t2, Mn(e2));
  const r2 = {
    type: $.END_TAG,
    tagName: n,
    tagID: xt(n),
    selfClosing: false,
    ackSelfClosing: false,
    attrs: [],
    location: rn(e2)
  };
  t2.parser.currentToken = r2, t2.parser._processToken(t2.parser.currentToken), // Current element is closed.
  n === t2.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t2.parser.tokenizer.state === ae2.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t2.parser.tokenizer.state === ae2.RAWTEXT || // `<script>`
  t2.parser.tokenizer.state === ae2.SCRIPT_DATA) && (t2.parser.tokenizer.state = ae2.DATA);
}
function $0(e2) {
  const t2 = e2.type === "root" ? e2.children[0] : e2;
  return !!(t2 && (t2.type === "doctype" || t2.type === "element" && t2.tagName.toLowerCase() === "html"));
}
function rn(e2) {
  const t2 = Me(e2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = Mn(e2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t2.line,
    startCol: t2.column,
    startOffset: t2.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function X0(e2) {
  return "children" in e2 ? Eu({ ...e2, children: [] }) : Eu(e2);
}
function K0(e2) {
  return function(t2, n) {
    return (
      /** @type {Root} */
      Ua(t2, { ...e2, file: n })
    );
  };
}
function Uu(e2, t2) {
  const n = String(e2);
  if (typeof t2 != "string")
    throw new TypeError("Expected character");
  let r2 = 0, u = n.indexOf(t2);
  for (; u !== -1; )
    r2++, u = n.indexOf(t2, u + t2.length);
  return r2;
}
var ge = Qe(/[A-Za-z]/);
var me = Qe(/[\dA-Za-z]/);
var J0 = Qe(/[#-'*+\--9=?A-Z^-~]/);
function In(e2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e2 !== null && (e2 < 32 || e2 === 127)
  );
}
var br = Qe(/\d/);
var Z0 = Qe(/[\dA-Fa-f]/);
var ef = Qe(/[!-/:-@[-`{-~]/);
function z(e2) {
  return e2 !== null && e2 < -2;
}
function ne(e2) {
  return e2 !== null && (e2 < 0 || e2 === 32);
}
function X(e2) {
  return e2 === -2 || e2 === -1 || e2 === 32;
}
var Hn = Qe(new RegExp("\\p{P}|\\p{S}", "u"));
var rt = Qe(/\s/);
function Qe(e2) {
  return t2;
  function t2(n) {
    return n !== null && n > -1 && e2.test(String.fromCharCode(n));
  }
}
function tf(e2, t2, n) {
  const u = Bn((n || {}).ignore || []), a = nf(t2);
  let i = -1;
  for (; ++i < a.length; )
    Ha(e2, "text", o);
  function o(c, h) {
    let f2 = -1, p2;
    for (; ++f2 < h.length; ) {
      const d = h[f2], A = p2 ? p2.children : void 0;
      if (u(
        d,
        A ? A.indexOf(d) : void 0,
        p2
      ))
        return;
      p2 = d;
    }
    if (p2)
      return l3(c, h);
  }
  function l3(c, h) {
    const f2 = h[h.length - 1], p2 = a[i][0], d = a[i][1];
    let A = 0;
    const y2 = f2.children.indexOf(c);
    let S = false, O = [];
    p2.lastIndex = 0;
    let L = p2.exec(c.value);
    for (; L; ) {
      const Y = L.index, q = {
        index: L.index,
        input: L.input,
        stack: [...h, c]
      };
      let k = d(...L, q);
      if (typeof k == "string" && (k = k.length > 0 ? { type: "text", value: k } : void 0), k === false ? p2.lastIndex = Y + 1 : (A !== Y && O.push({
        type: "text",
        value: c.value.slice(A, Y)
      }), Array.isArray(k) ? O.push(...k) : k && O.push(k), A = Y + L[0].length, S = true), !p2.global)
        break;
      L = p2.exec(c.value);
    }
    return S ? (A < c.value.length && O.push({ type: "text", value: c.value.slice(A) }), f2.children.splice(y2, 1, ...O)) : O = [c], y2 + O.length;
  }
}
function nf(e2) {
  const t2 = [];
  if (!Array.isArray(e2))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e2[0] || Array.isArray(e2[0]) ? e2 : [e2];
  let r2 = -1;
  for (; ++r2 < n.length; ) {
    const u = n[r2];
    t2.push([rf(u[0]), uf(u[1])]);
  }
  return t2;
}
function rf(e2) {
  return typeof e2 == "string" ? new RegExp(r(e2), "g") : e2;
}
function uf(e2) {
  return typeof e2 == "function" ? e2 : function() {
    return e2;
  };
}
var Gn = "phrasing";
var Qn = ["autolink", "link", "image", "label"];
function af() {
  return {
    transforms: [df],
    enter: {
      literalAutolink: of,
      literalAutolinkEmail: $n,
      literalAutolinkHttp: $n,
      literalAutolinkWww: $n
    },
    exit: {
      literalAutolink: hf,
      literalAutolinkEmail: ff,
      literalAutolinkHttp: lf,
      literalAutolinkWww: cf
    }
  };
}
function sf() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Gn,
        notInConstruct: Qn
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Gn,
        notInConstruct: Qn
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Gn,
        notInConstruct: Qn
      }
    ]
  };
}
function of(e2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e2);
}
function $n(e2) {
  this.config.enter.autolinkProtocol.call(this, e2);
}
function lf(e2) {
  this.config.exit.autolinkProtocol.call(this, e2);
}
function cf(e2) {
  this.config.exit.data.call(this, e2);
  const t2 = this.stack[this.stack.length - 1];
  t2.type, t2.url = "http://" + this.sliceSerialize(e2);
}
function ff(e2) {
  this.config.exit.autolinkEmail.call(this, e2);
}
function hf(e2) {
  this.exit(e2);
}
function df(e2) {
  tf(
    e2,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, mf],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), pf]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function mf(e2, t2, n, r2, u) {
  let a = "";
  if (!qa(u) || (/^w/i.test(t2) && (n = t2 + n, t2 = "", a = "http://"), !Ef(n)))
    return false;
  const i = gf(n + r2);
  if (!i[0]) return false;
  const o = {
    type: "link",
    title: null,
    url: a + t2 + i[0],
    children: [{ type: "text", value: t2 + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function pf(e2, t2, n, r2) {
  return (
    // Not an expected previous character.
    !qa(r2, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? false : {
      type: "link",
      title: null,
      url: "mailto:" + t2 + "@" + n,
      children: [{ type: "text", value: t2 + "@" + n }]
    }
  );
}
function Ef(e2) {
  const t2 = e2.split(".");
  return !(t2.length < 2 || t2[t2.length - 1] && (/_/.test(t2[t2.length - 1]) || !/[a-zA-Z\d]/.test(t2[t2.length - 1])) || t2[t2.length - 2] && (/_/.test(t2[t2.length - 2]) || !/[a-zA-Z\d]/.test(t2[t2.length - 2])));
}
function gf(e2) {
  const t2 = /[!"&'),.:;<>?\]}]+$/.exec(e2);
  if (!t2)
    return [e2, void 0];
  e2 = e2.slice(0, t2.index);
  let n = t2[0], r2 = n.indexOf(")");
  const u = Uu(e2, "(");
  let a = Uu(e2, ")");
  for (; r2 !== -1 && u > a; )
    e2 += n.slice(0, r2 + 1), n = n.slice(r2 + 1), r2 = n.indexOf(")"), a++;
  return [e2, n];
}
function qa(e2, t2) {
  const n = e2.input.charCodeAt(e2.index - 1);
  return (e2.index === 0 || rt(n) || Hn(n)) && // If it’s an email, the previous character should not be a slash.
  (!t2 || n !== 47);
}
function un(e2) {
  return e2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
ja.peek = kf;
function Tf() {
  this.buffer();
}
function bf(e2) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e2);
}
function Af() {
  this.buffer();
}
function _f(e2) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e2
  );
}
function Cf(e2) {
  const t2 = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = un(
    this.sliceSerialize(e2)
  ).toLowerCase(), n.label = t2;
}
function Sf(e2) {
  this.exit(e2);
}
function xf(e2) {
  const t2 = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = un(
    this.sliceSerialize(e2)
  ).toLowerCase(), n.label = t2;
}
function If(e2) {
  this.exit(e2);
}
function kf() {
  return "[";
}
function ja(e2, t2, n, r2) {
  const u = n.createTracker(r2);
  let a = u.move("[^");
  const i = n.enter("footnoteReference"), o = n.enter("reference");
  return a += u.move(
    n.safe(n.associationId(e2), { after: "]", before: a })
  ), o(), i(), a += u.move("]"), a;
}
function yf() {
  return {
    enter: {
      gfmFootnoteCallString: Tf,
      gfmFootnoteCall: bf,
      gfmFootnoteDefinitionLabelString: Af,
      gfmFootnoteDefinition: _f
    },
    exit: {
      gfmFootnoteCallString: Cf,
      gfmFootnoteCall: Sf,
      gfmFootnoteDefinitionLabelString: xf,
      gfmFootnoteDefinition: If
    }
  };
}
function Nf(e2) {
  let t2 = false;
  return e2 && e2.firstLineBlank && (t2 = true), {
    handlers: { footnoteDefinition: n, footnoteReference: ja },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r2, u, a, i) {
    const o = a.createTracker(i);
    let l3 = o.move("[^");
    const c = a.enter("footnoteDefinition"), h = a.enter("label");
    return l3 += o.move(
      a.safe(a.associationId(r2), { before: l3, after: "]" })
    ), h(), l3 += o.move("]:"), r2.children && r2.children.length > 0 && (o.shift(4), l3 += o.move(
      (t2 ? `
` : " ") + a.indentLines(
        a.containerFlow(r2, o.current()),
        t2 ? Va : Of
      )
    )), c(), l3;
  }
}
function Of(e2, t2, n) {
  return t2 === 0 ? e2 : Va(e2, t2, n);
}
function Va(e2, t2, n) {
  return (n ? "" : "    ") + e2;
}
var Lf = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Wa.peek = Mf;
function Rf() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Pf },
    exit: { strikethrough: wf }
  };
}
function Df() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Lf
      }
    ],
    handlers: { delete: Wa }
  };
}
function Pf(e2) {
  this.enter({ type: "delete", children: [] }, e2);
}
function wf(e2) {
  this.exit(e2);
}
function Wa(e2, t2, n, r2) {
  const u = n.createTracker(r2), a = n.enter("strikethrough");
  let i = u.move("~~");
  return i += n.containerPhrasing(e2, {
    ...u.current(),
    before: i,
    after: "~"
  }), i += u.move("~~"), a(), i;
}
function Mf() {
  return "~";
}
function Bf(e2) {
  return e2.length;
}
function Ff(e2, t2) {
  const n = t2 || {}, r2 = (n.align || []).concat(), u = n.stringLength || Bf, a = [], i = [], o = [], l3 = [];
  let c = 0, h = -1;
  for (; ++h < e2.length; ) {
    const C = [], y2 = [];
    let S = -1;
    for (e2[h].length > c && (c = e2[h].length); ++S < e2[h].length; ) {
      const O = Hf(e2[h][S]);
      if (n.alignDelimiters !== false) {
        const L = u(O);
        y2[S] = L, (l3[S] === void 0 || L > l3[S]) && (l3[S] = L);
      }
      C.push(O);
    }
    i[h] = C, o[h] = y2;
  }
  let f2 = -1;
  if (typeof r2 == "object" && "length" in r2)
    for (; ++f2 < c; )
      a[f2] = vu(r2[f2]);
  else {
    const C = vu(r2);
    for (; ++f2 < c; )
      a[f2] = C;
  }
  f2 = -1;
  const p2 = [], d = [];
  for (; ++f2 < c; ) {
    const C = a[f2];
    let y2 = "", S = "";
    C === 99 ? (y2 = ":", S = ":") : C === 108 ? y2 = ":" : C === 114 && (S = ":");
    let O = n.alignDelimiters === false ? 1 : Math.max(
      1,
      l3[f2] - y2.length - S.length
    );
    const L = y2 + "-".repeat(O) + S;
    n.alignDelimiters !== false && (O = y2.length + O + S.length, O > l3[f2] && (l3[f2] = O), d[f2] = O), p2[f2] = L;
  }
  i.splice(1, 0, p2), o.splice(1, 0, d), h = -1;
  const A = [];
  for (; ++h < i.length; ) {
    const C = i[h], y2 = o[h];
    f2 = -1;
    const S = [];
    for (; ++f2 < c; ) {
      const O = C[f2] || "";
      let L = "", Y = "";
      if (n.alignDelimiters !== false) {
        const q = l3[f2] - (y2[f2] || 0), k = a[f2];
        k === 114 ? L = " ".repeat(q) : k === 99 ? q % 2 ? (L = " ".repeat(q / 2 + 0.5), Y = " ".repeat(q / 2 - 0.5)) : (L = " ".repeat(q / 2), Y = L) : Y = " ".repeat(q);
      }
      n.delimiterStart !== false && !f2 && S.push("|"), n.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === false && O === "") && (n.delimiterStart !== false || f2) && S.push(" "), n.alignDelimiters !== false && S.push(L), S.push(O), n.alignDelimiters !== false && S.push(Y), n.padding !== false && S.push(" "), (n.delimiterEnd !== false || f2 !== c - 1) && S.push("|");
    }
    A.push(
      n.delimiterEnd === false ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return A.join(`
`);
}
function Hf(e2) {
  return e2 == null ? "" : String(e2);
}
function vu(e2) {
  const t2 = typeof e2 == "string" ? e2.codePointAt(0) : 0;
  return t2 === 67 || t2 === 99 ? 99 : t2 === 76 || t2 === 108 ? 108 : t2 === 82 || t2 === 114 ? 114 : 0;
}
function Uf(e2, t2, n, r2) {
  const u = n.enter("blockquote"), a = n.createTracker(r2);
  a.move("> "), a.shift(2);
  const i = n.indentLines(
    n.containerFlow(e2, a.current()),
    vf
  );
  return u(), i;
}
function vf(e2, t2, n) {
  return ">" + (n ? "" : " ") + e2;
}
function zf(e2, t2) {
  return zu(e2, t2.inConstruct, true) && !zu(e2, t2.notInConstruct, false);
}
function zu(e2, t2, n) {
  if (typeof t2 == "string" && (t2 = [t2]), !t2 || t2.length === 0)
    return n;
  let r2 = -1;
  for (; ++r2 < t2.length; )
    if (e2.includes(t2[r2]))
      return true;
  return false;
}
function Yu(e2, t2, n, r2) {
  let u = -1;
  for (; ++u < n.unsafe.length; )
    if (n.unsafe[u].character === `
` && zf(n.stack, n.unsafe[u]))
      return /[ \t]/.test(r2.before) ? "" : " ";
  return `\\
`;
}
function Yf(e2, t2) {
  const n = String(e2);
  let r2 = n.indexOf(t2), u = r2, a = 0, i = 0;
  if (typeof t2 != "string")
    throw new TypeError("Expected substring");
  for (; r2 !== -1; )
    r2 === u ? ++a > i && (i = a) : a = 1, u = r2 + t2.length, r2 = n.indexOf(t2, u);
  return i;
}
function qf(e2, t2) {
  return !!(t2.options.fences === false && e2.value && // If there’s no info…
  !e2.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e2.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e2.value));
}
function jf(e2) {
  const t2 = e2.options.fence || "`";
  if (t2 !== "`" && t2 !== "~")
    throw new Error(
      "Cannot serialize code with `" + t2 + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t2;
}
function Vf(e2, t2, n, r2) {
  const u = jf(n), a = e2.value || "", i = u === "`" ? "GraveAccent" : "Tilde";
  if (qf(e2, n)) {
    const f2 = n.enter("codeIndented"), p2 = n.indentLines(a, Wf);
    return f2(), p2;
  }
  const o = n.createTracker(r2), l3 = u.repeat(Math.max(Yf(a, u) + 1, 3)), c = n.enter("codeFenced");
  let h = o.move(l3);
  if (e2.lang) {
    const f2 = n.enter(`codeFencedLang${i}`);
    h += o.move(
      n.safe(e2.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), f2();
  }
  if (e2.lang && e2.meta) {
    const f2 = n.enter(`codeFencedMeta${i}`);
    h += o.move(" "), h += o.move(
      n.safe(e2.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), f2();
  }
  return h += o.move(`
`), a && (h += o.move(a + `
`)), h += o.move(l3), c(), h;
}
function Wf(e2, t2, n) {
  return (n ? "" : "    ") + e2;
}
function Yr(e2) {
  const t2 = e2.options.quote || '"';
  if (t2 !== '"' && t2 !== "'")
    throw new Error(
      "Cannot serialize title with `" + t2 + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t2;
}
function Gf(e2, t2, n, r2) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
  let o = n.enter("label");
  const l3 = n.createTracker(r2);
  let c = l3.move("[");
  return c += l3.move(
    n.safe(n.associationId(e2), {
      before: c,
      after: "]",
      ...l3.current()
    })
  ), c += l3.move("]: "), o(), // If there’s no url, or…
  !e2.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (o = n.enter("destinationLiteral"), c += l3.move("<"), c += l3.move(
    n.safe(e2.url, { before: c, after: ">", ...l3.current() })
  ), c += l3.move(">")) : (o = n.enter("destinationRaw"), c += l3.move(
    n.safe(e2.url, {
      before: c,
      after: e2.title ? " " : `
`,
      ...l3.current()
    })
  )), o(), e2.title && (o = n.enter(`title${a}`), c += l3.move(" " + u), c += l3.move(
    n.safe(e2.title, {
      before: c,
      after: u,
      ...l3.current()
    })
  ), c += l3.move(u), o()), i(), c;
}
function Qf(e2) {
  const t2 = e2.options.emphasis || "*";
  if (t2 !== "*" && t2 !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t2 + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t2;
}
function Kt(e2) {
  return "&#x" + e2.toString(16).toUpperCase() + ";";
}
function _t2(e2) {
  if (e2 === null || ne(e2) || rt(e2))
    return 1;
  if (Hn(e2))
    return 2;
}
function kn(e2, t2, n) {
  const r2 = _t2(e2), u = _t2(t2);
  return r2 === void 0 ? u === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
  ) : u === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: true, outside: true }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: false, outside: true }
  ) : r2 === 1 ? u === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : u === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: true, outside: true }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  ) : u === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : u === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}
Ga.peek = $f;
function Ga(e2, t2, n, r2) {
  const u = Qf(n), a = n.enter("emphasis"), i = n.createTracker(r2), o = i.move(u);
  let l3 = i.move(
    n.containerPhrasing(e2, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l3.charCodeAt(0), h = kn(
    r2.before.charCodeAt(r2.before.length - 1),
    c,
    u
  );
  h.inside && (l3 = Kt(c) + l3.slice(1));
  const f2 = l3.charCodeAt(l3.length - 1), p2 = kn(r2.after.charCodeAt(0), f2, u);
  p2.inside && (l3 = l3.slice(0, -1) + Kt(f2));
  const d = i.move(u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p2.outside,
    before: h.outside
  }, o + l3 + d;
}
function $f(e2, t2, n) {
  return n.options.emphasis || "*";
}
var Xf = {};
function qr(e2, t2) {
  const n = Xf, r2 = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : true, u = typeof n.includeHtml == "boolean" ? n.includeHtml : true;
  return Qa(e2, r2, u);
}
function Qa(e2, t2, n) {
  if (Kf(e2)) {
    if ("value" in e2)
      return e2.type === "html" && !n ? "" : e2.value;
    if (t2 && "alt" in e2 && e2.alt)
      return e2.alt;
    if ("children" in e2)
      return qu(e2.children, t2, n);
  }
  return Array.isArray(e2) ? qu(e2, t2, n) : "";
}
function qu(e2, t2, n) {
  const r2 = [];
  let u = -1;
  for (; ++u < e2.length; )
    r2[u] = Qa(e2[u], t2, n);
  return r2.join("");
}
function Kf(e2) {
  return !!(e2 && typeof e2 == "object");
}
function Jf(e2, t2) {
  let n = false;
  return nn(e2, function(r2) {
    if ("value" in r2 && /\r?\n|\r/.test(r2.value) || r2.type === "break")
      return n = true, Tr;
  }), !!((!e2.depth || e2.depth < 3) && qr(e2) && (t2.options.setext || n));
}
function Zf(e2, t2, n, r2) {
  const u = Math.max(Math.min(6, e2.depth || 1), 1), a = n.createTracker(r2);
  if (Jf(e2, n)) {
    const h = n.enter("headingSetext"), f2 = n.enter("phrasing"), p2 = n.containerPhrasing(e2, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f2(), h(), p2 + `
` + (u === 1 ? "=" : "-").repeat(
      // The whole size…
      p2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(p2.lastIndexOf("\r"), p2.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(u), o = n.enter("headingAtx"), l3 = n.enter("phrasing");
  a.move(i + " ");
  let c = n.containerPhrasing(e2, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = Kt(c.charCodeAt(0)) + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), l3(), o(), c;
}
$a.peek = eh;
function $a(e2) {
  return e2.value || "";
}
function eh() {
  return "<";
}
Xa.peek = th;
function Xa(e2, t2, n, r2) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
  let o = n.enter("label");
  const l3 = n.createTracker(r2);
  let c = l3.move("![");
  return c += l3.move(
    n.safe(e2.alt, { before: c, after: "]", ...l3.current() })
  ), c += l3.move("]("), o(), // If there’s no url but there is a title…
  !e2.url && e2.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (o = n.enter("destinationLiteral"), c += l3.move("<"), c += l3.move(
    n.safe(e2.url, { before: c, after: ">", ...l3.current() })
  ), c += l3.move(">")) : (o = n.enter("destinationRaw"), c += l3.move(
    n.safe(e2.url, {
      before: c,
      after: e2.title ? " " : ")",
      ...l3.current()
    })
  )), o(), e2.title && (o = n.enter(`title${a}`), c += l3.move(" " + u), c += l3.move(
    n.safe(e2.title, {
      before: c,
      after: u,
      ...l3.current()
    })
  ), c += l3.move(u), o()), c += l3.move(")"), i(), c;
}
function th() {
  return "!";
}
Ka.peek = nh;
function Ka(e2, t2, n, r2) {
  const u = e2.referenceType, a = n.enter("imageReference");
  let i = n.enter("label");
  const o = n.createTracker(r2);
  let l3 = o.move("![");
  const c = n.safe(e2.alt, {
    before: l3,
    after: "]",
    ...o.current()
  });
  l3 += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f2 = n.safe(n.associationId(e2), {
    before: l3,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f2 ? l3 += o.move(f2 + "]") : u === "shortcut" ? l3 = l3.slice(0, -1) : l3 += o.move("]"), l3;
}
function nh() {
  return "!";
}
Ja.peek = rh;
function Ja(e2, t2, n) {
  let r2 = e2.value || "", u = "`", a = -1;
  for (; new RegExp("(^|[^`])" + u + "([^`]|$)").test(r2); )
    u += "`";
  for (/[^ \r\n]/.test(r2) && (/^[ \r\n]/.test(r2) && /[ \r\n]$/.test(r2) || /^`|`$/.test(r2)) && (r2 = " " + r2 + " "); ++a < n.unsafe.length; ) {
    const i = n.unsafe[a], o = n.compilePattern(i);
    let l3;
    if (i.atBreak)
      for (; l3 = o.exec(r2); ) {
        let c = l3.index;
        r2.charCodeAt(c) === 10 && r2.charCodeAt(c - 1) === 13 && c--, r2 = r2.slice(0, c) + " " + r2.slice(l3.index + 1);
      }
  }
  return u + r2 + u;
}
function rh() {
  return "`";
}
function Za(e2, t2) {
  const n = qr(e2);
  return !!(!t2.options.resourceLink && // If there’s a url…
  e2.url && // And there’s a no title…
  !e2.title && // And the content of `node` is a single text node…
  e2.children && e2.children.length === 1 && e2.children[0].type === "text" && // And if the url is the same as the content…
  (n === e2.url || "mailto:" + n === e2.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e2.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e2.url));
}
es.peek = uh;
function es(e2, t2, n, r2) {
  const u = Yr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r2);
  let o, l3;
  if (Za(e2, n)) {
    const h = n.stack;
    n.stack = [], o = n.enter("autolink");
    let f2 = i.move("<");
    return f2 += i.move(
      n.containerPhrasing(e2, {
        before: f2,
        after: ">",
        ...i.current()
      })
    ), f2 += i.move(">"), o(), n.stack = h, f2;
  }
  o = n.enter("link"), l3 = n.enter("label");
  let c = i.move("[");
  return c += i.move(
    n.containerPhrasing(e2, {
      before: c,
      after: "](",
      ...i.current()
    })
  ), c += i.move("]("), l3(), // If there’s no url but there is a title…
  !e2.url && e2.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (l3 = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
    n.safe(e2.url, { before: c, after: ">", ...i.current() })
  ), c += i.move(">")) : (l3 = n.enter("destinationRaw"), c += i.move(
    n.safe(e2.url, {
      before: c,
      after: e2.title ? " " : ")",
      ...i.current()
    })
  )), l3(), e2.title && (l3 = n.enter(`title${a}`), c += i.move(" " + u), c += i.move(
    n.safe(e2.title, {
      before: c,
      after: u,
      ...i.current()
    })
  ), c += i.move(u), l3()), c += i.move(")"), o(), c;
}
function uh(e2, t2, n) {
  return Za(e2, n) ? "<" : "[";
}
ts.peek = ih;
function ts(e2, t2, n, r2) {
  const u = e2.referenceType, a = n.enter("linkReference");
  let i = n.enter("label");
  const o = n.createTracker(r2);
  let l3 = o.move("[");
  const c = n.containerPhrasing(e2, {
    before: l3,
    after: "]",
    ...o.current()
  });
  l3 += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f2 = n.safe(n.associationId(e2), {
    before: l3,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f2 ? l3 += o.move(f2 + "]") : u === "shortcut" ? l3 = l3.slice(0, -1) : l3 += o.move("]"), l3;
}
function ih() {
  return "[";
}
function jr(e2) {
  const t2 = e2.options.bullet || "*";
  if (t2 !== "*" && t2 !== "+" && t2 !== "-")
    throw new Error(
      "Cannot serialize items with `" + t2 + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t2;
}
function ah(e2) {
  const t2 = jr(e2), n = e2.options.bulletOther;
  if (!n)
    return t2 === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t2)
    throw new Error(
      "Expected `bullet` (`" + t2 + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function sh(e2) {
  const t2 = e2.options.bulletOrdered || ".";
  if (t2 !== "." && t2 !== ")")
    throw new Error(
      "Cannot serialize items with `" + t2 + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t2;
}
function ns(e2) {
  const t2 = e2.options.rule || "*";
  if (t2 !== "*" && t2 !== "-" && t2 !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t2 + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t2;
}
function oh(e2, t2, n, r2) {
  const u = n.enter("list"), a = n.bulletCurrent;
  let i = e2.ordered ? sh(n) : jr(n);
  const o = e2.ordered ? i === "." ? ")" : "." : ah(n);
  let l3 = t2 && n.bulletLastUsed ? i === n.bulletLastUsed : false;
  if (!e2.ordered) {
    const h = e2.children ? e2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l3 = true), ns(n) === i && h
    ) {
      let f2 = -1;
      for (; ++f2 < e2.children.length; ) {
        const p2 = e2.children[f2];
        if (p2 && p2.type === "listItem" && p2.children && p2.children[0] && p2.children[0].type === "thematicBreak") {
          l3 = true;
          break;
        }
      }
    }
  }
  l3 && (i = o), n.bulletCurrent = i;
  const c = n.containerFlow(e2, r2);
  return n.bulletLastUsed = i, n.bulletCurrent = a, u(), c;
}
function lh(e2) {
  const t2 = e2.options.listItemIndent || "one";
  if (t2 !== "tab" && t2 !== "one" && t2 !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t2;
}
function ch(e2, t2, n, r2) {
  const u = lh(n);
  let a = n.bulletCurrent || jr(n);
  t2 && t2.type === "list" && t2.ordered && (a = (typeof t2.start == "number" && t2.start > -1 ? t2.start : 1) + (n.options.incrementListMarker === false ? 0 : t2.children.indexOf(e2)) + a);
  let i = a.length + 1;
  (u === "tab" || u === "mixed" && (t2 && t2.type === "list" && t2.spread || e2.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = n.createTracker(r2);
  o.move(a + " ".repeat(i - a.length)), o.shift(i);
  const l3 = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e2, o.current()),
    h
  );
  return l3(), c;
  function h(f2, p2, d) {
    return p2 ? (d ? "" : " ".repeat(i)) + f2 : (d ? a : a + " ".repeat(i - a.length)) + f2;
  }
}
function fh(e2, t2, n, r2) {
  const u = n.enter("paragraph"), a = n.enter("phrasing"), i = n.containerPhrasing(e2, r2);
  return a(), u(), i;
}
var hh = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Bn([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function dh(e2, t2, n, r2) {
  return (e2.children.some(function(i) {
    return hh(i);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e2, r2);
}
function mh(e2) {
  const t2 = e2.options.strong || "*";
  if (t2 !== "*" && t2 !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t2 + "` for `options.strong`, expected `*`, or `_`"
    );
  return t2;
}
rs.peek = ph;
function rs(e2, t2, n, r2) {
  const u = mh(n), a = n.enter("strong"), i = n.createTracker(r2), o = i.move(u + u);
  let l3 = i.move(
    n.containerPhrasing(e2, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l3.charCodeAt(0), h = kn(
    r2.before.charCodeAt(r2.before.length - 1),
    c,
    u
  );
  h.inside && (l3 = Kt(c) + l3.slice(1));
  const f2 = l3.charCodeAt(l3.length - 1), p2 = kn(r2.after.charCodeAt(0), f2, u);
  p2.inside && (l3 = l3.slice(0, -1) + Kt(f2));
  const d = i.move(u + u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p2.outside,
    before: h.outside
  }, o + l3 + d;
}
function ph(e2, t2, n) {
  return n.options.strong || "*";
}
function Eh(e2, t2, n, r2) {
  return n.safe(e2.value, r2);
}
function gh(e2) {
  const t2 = e2.options.ruleRepetition || 3;
  if (t2 < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t2 + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t2;
}
function Th(e2, t2, n) {
  const r2 = (ns(n) + (n.options.ruleSpaces ? " " : "")).repeat(gh(n));
  return n.options.ruleSpaces ? r2.slice(0, -1) : r2;
}
var us = {
  blockquote: Uf,
  break: Yu,
  code: Vf,
  definition: Gf,
  emphasis: Ga,
  hardBreak: Yu,
  heading: Zf,
  html: $a,
  image: Xa,
  imageReference: Ka,
  inlineCode: Ja,
  link: es,
  linkReference: ts,
  list: oh,
  listItem: ch,
  paragraph: fh,
  root: dh,
  strong: rs,
  text: Eh,
  thematicBreak: Th
};
function bh() {
  return {
    enter: {
      table: Ah,
      tableData: ju,
      tableHeader: ju,
      tableRow: Ch
    },
    exit: {
      codeText: Sh,
      table: _h,
      tableData: Xn,
      tableHeader: Xn,
      tableRow: Xn
    }
  };
}
function Ah(e2) {
  const t2 = e2._align;
  this.enter(
    {
      type: "table",
      align: t2.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e2
  ), this.data.inTable = true;
}
function _h(e2) {
  this.exit(e2), this.data.inTable = void 0;
}
function Ch(e2) {
  this.enter({ type: "tableRow", children: [] }, e2);
}
function Xn(e2) {
  this.exit(e2);
}
function ju(e2) {
  this.enter({ type: "tableCell", children: [] }, e2);
}
function Sh(e2) {
  let t2 = this.resume();
  this.data.inTable && (t2 = t2.replace(/\\([\\|])/g, xh));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t2, this.exit(e2);
}
function xh(e2, t2) {
  return t2 === "|" ? t2 : e2;
}
function Ih(e2) {
  const t2 = e2 || {}, n = t2.tableCellPadding, r2 = t2.tablePipeAlign, u = t2.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p2,
      table: i,
      tableCell: l3,
      tableRow: o
    }
  };
  function i(d, A, C, y2) {
    return c(h(d, C, y2), d.align);
  }
  function o(d, A, C, y2) {
    const S = f2(d, C, y2), O = c([S]);
    return O.slice(0, O.indexOf(`
`));
  }
  function l3(d, A, C, y2) {
    const S = C.enter("tableCell"), O = C.enter("phrasing"), L = C.containerPhrasing(d, {
      ...y2,
      before: a,
      after: a
    });
    return O(), S(), L;
  }
  function c(d, A) {
    return Ff(d, {
      align: A,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r2,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: u
    });
  }
  function h(d, A, C) {
    const y2 = d.children;
    let S = -1;
    const O = [], L = A.enter("table");
    for (; ++S < y2.length; )
      O[S] = f2(y2[S], A, C);
    return L(), O;
  }
  function f2(d, A, C) {
    const y2 = d.children;
    let S = -1;
    const O = [], L = A.enter("tableRow");
    for (; ++S < y2.length; )
      O[S] = l3(y2[S], d, A, C);
    return L(), O;
  }
  function p2(d, A, C) {
    let y2 = us.inlineCode(d, A, C);
    return C.stack.includes("tableCell") && (y2 = y2.replace(/\|/g, "\\$&")), y2;
  }
}
function kh() {
  return {
    exit: {
      taskListCheckValueChecked: Vu,
      taskListCheckValueUnchecked: Vu,
      paragraph: Nh
    }
  };
}
function yh() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: Oh }
  };
}
function Vu(e2) {
  const t2 = this.stack[this.stack.length - 2];
  t2.type, t2.checked = e2.type === "taskListCheckValueChecked";
}
function Nh(e2) {
  const t2 = this.stack[this.stack.length - 2];
  if (t2 && t2.type === "listItem" && typeof t2.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r2 = n.children[0];
    if (r2 && r2.type === "text") {
      const u = t2.children;
      let a = -1, i;
      for (; ++a < u.length; ) {
        const o = u[a];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === n && (r2.value = r2.value.slice(1), r2.value.length === 0 ? n.children.shift() : n.position && r2.position && typeof r2.position.start.offset == "number" && (r2.position.start.column++, r2.position.start.offset++, n.position.start = Object.assign({}, r2.position.start)));
    }
  }
  this.exit(e2);
}
function Oh(e2, t2, n, r2) {
  const u = e2.children[0], a = typeof e2.checked == "boolean" && u && u.type === "paragraph", i = "[" + (e2.checked ? "x" : " ") + "] ", o = n.createTracker(r2);
  a && o.move(i);
  let l3 = us.listItem(e2, t2, n, {
    ...r2,
    ...o.current()
  });
  return a && (l3 = l3.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l3;
  function c(h) {
    return h + i;
  }
}
function Lh() {
  return [
    af(),
    yf(),
    Rf(),
    bh(),
    kh()
  ];
}
function Rh(e2) {
  return {
    extensions: [
      sf(),
      Nf(e2),
      Df(),
      Ih(e2),
      yh()
    ]
  };
}
function gn(e2, t2, n, r2) {
  const u = e2.length;
  let a = 0, i;
  if (t2 < 0 ? t2 = -t2 > u ? 0 : u + t2 : t2 = t2 > u ? u : t2, n = n > 0 ? n : 0, r2.length < 1e4)
    i = Array.from(r2), i.unshift(t2, n), e2.splice(...i);
  else
    for (n && e2.splice(t2, n); a < r2.length; )
      i = r2.slice(a, a + 1e4), i.unshift(t2, 0), e2.splice(...i), a += 1e4, t2 += 1e4;
}
var Wu = {}.hasOwnProperty;
function Dh(e2) {
  const t2 = {};
  let n = -1;
  for (; ++n < e2.length; )
    Ph(t2, e2[n]);
  return t2;
}
function Ph(e2, t2) {
  let n;
  for (n in t2) {
    const u = (Wu.call(e2, n) ? e2[n] : void 0) || (e2[n] = {}), a = t2[n];
    let i;
    if (a)
      for (i in a) {
        Wu.call(u, i) || (u[i] = []);
        const o = a[i];
        wh(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function wh(e2, t2) {
  let n = -1;
  const r2 = [];
  for (; ++n < t2.length; )
    (t2[n].add === "after" ? e2 : r2).push(t2[n]);
  gn(e2, 0, 0, r2);
}
var Mh = {
  tokenize: zh,
  partial: true
};
var is = {
  tokenize: Yh,
  partial: true
};
var as = {
  tokenize: qh,
  partial: true
};
var ss = {
  tokenize: jh,
  partial: true
};
var Bh = {
  tokenize: Vh,
  partial: true
};
var os = {
  name: "wwwAutolink",
  tokenize: Uh,
  previous: cs
};
var ls = {
  name: "protocolAutolink",
  tokenize: vh,
  previous: fs
};
var Ye = {
  name: "emailAutolink",
  tokenize: Hh,
  previous: hs
};
var Be = {};
function Fh() {
  return {
    text: Be
  };
}
var et3 = 48;
for (; et3 < 123; )
  Be[et3] = Ye, et3++, et3 === 58 ? et3 = 65 : et3 === 91 && (et3 = 97);
Be[43] = Ye;
Be[45] = Ye;
Be[46] = Ye;
Be[95] = Ye;
Be[72] = [Ye, ls];
Be[104] = [Ye, ls];
Be[87] = [Ye, os];
Be[119] = [Ye, os];
function Hh(e2, t2, n) {
  const r2 = this;
  let u, a;
  return i;
  function i(f2) {
    return !Ar(f2) || !hs.call(r2, r2.previous) || Vr(r2.events) ? n(f2) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkEmail"), o(f2));
  }
  function o(f2) {
    return Ar(f2) ? (e2.consume(f2), o) : f2 === 64 ? (e2.consume(f2), l3) : n(f2);
  }
  function l3(f2) {
    return f2 === 46 ? e2.check(Bh, h, c)(f2) : f2 === 45 || f2 === 95 || me(f2) ? (a = true, e2.consume(f2), l3) : h(f2);
  }
  function c(f2) {
    return e2.consume(f2), u = true, l3;
  }
  function h(f2) {
    return a && u && ge(r2.previous) ? (e2.exit("literalAutolinkEmail"), e2.exit("literalAutolink"), t2(f2)) : n(f2);
  }
}
function Uh(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return i !== 87 && i !== 119 || !cs.call(r2, r2.previous) || Vr(r2.events) ? n(i) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkWww"), e2.check(Mh, e2.attempt(is, e2.attempt(as, a), n), n)(i));
  }
  function a(i) {
    return e2.exit("literalAutolinkWww"), e2.exit("literalAutolink"), t2(i);
  }
}
function vh(e2, t2, n) {
  const r2 = this;
  let u = "", a = false;
  return i;
  function i(f2) {
    return (f2 === 72 || f2 === 104) && fs.call(r2, r2.previous) && !Vr(r2.events) ? (e2.enter("literalAutolink"), e2.enter("literalAutolinkHttp"), u += String.fromCodePoint(f2), e2.consume(f2), o) : n(f2);
  }
  function o(f2) {
    if (ge(f2) && u.length < 5)
      return u += String.fromCodePoint(f2), e2.consume(f2), o;
    if (f2 === 58) {
      const p2 = u.toLowerCase();
      if (p2 === "http" || p2 === "https")
        return e2.consume(f2), l3;
    }
    return n(f2);
  }
  function l3(f2) {
    return f2 === 47 ? (e2.consume(f2), a ? c : (a = true, l3)) : n(f2);
  }
  function c(f2) {
    return f2 === null || In(f2) || ne(f2) || rt(f2) || Hn(f2) ? n(f2) : e2.attempt(is, e2.attempt(as, h), n)(f2);
  }
  function h(f2) {
    return e2.exit("literalAutolinkHttp"), e2.exit("literalAutolink"), t2(f2);
  }
}
function zh(e2, t2, n) {
  let r2 = 0;
  return u;
  function u(i) {
    return (i === 87 || i === 119) && r2 < 3 ? (r2++, e2.consume(i), u) : i === 46 && r2 === 3 ? (e2.consume(i), a) : n(i);
  }
  function a(i) {
    return i === null ? n(i) : t2(i);
  }
}
function Yh(e2, t2, n) {
  let r2, u, a;
  return i;
  function i(c) {
    return c === 46 || c === 95 ? e2.check(ss, l3, o)(c) : c === null || ne(c) || rt(c) || c !== 45 && Hn(c) ? l3(c) : (a = true, e2.consume(c), i);
  }
  function o(c) {
    return c === 95 ? r2 = true : (u = r2, r2 = void 0), e2.consume(c), i;
  }
  function l3(c) {
    return u || r2 || !a ? n(c) : t2(c);
  }
}
function qh(e2, t2) {
  let n = 0, r2 = 0;
  return u;
  function u(i) {
    return i === 40 ? (n++, e2.consume(i), u) : i === 41 && r2 < n ? a(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e2.check(ss, t2, a)(i) : i === null || ne(i) || rt(i) ? t2(i) : (e2.consume(i), u);
  }
  function a(i) {
    return i === 41 && r2++, e2.consume(i), u;
  }
}
function jh(e2, t2, n) {
  return r2;
  function r2(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e2.consume(o), r2) : o === 38 ? (e2.consume(o), a) : o === 93 ? (e2.consume(o), u) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || ne(o) || rt(o) ? t2(o) : n(o)
    );
  }
  function u(o) {
    return o === null || o === 40 || o === 91 || ne(o) || rt(o) ? t2(o) : r2(o);
  }
  function a(o) {
    return ge(o) ? i(o) : n(o);
  }
  function i(o) {
    return o === 59 ? (e2.consume(o), r2) : ge(o) ? (e2.consume(o), i) : n(o);
  }
}
function Vh(e2, t2, n) {
  return r2;
  function r2(a) {
    return e2.consume(a), u;
  }
  function u(a) {
    return me(a) ? n(a) : t2(a);
  }
}
function cs(e2) {
  return e2 === null || e2 === 40 || e2 === 42 || e2 === 95 || e2 === 91 || e2 === 93 || e2 === 126 || ne(e2);
}
function fs(e2) {
  return !ge(e2);
}
function hs(e2) {
  return !(e2 === 47 || Ar(e2));
}
function Ar(e2) {
  return e2 === 43 || e2 === 45 || e2 === 46 || e2 === 95 || me(e2);
}
function Vr(e2) {
  let t2 = e2.length, n = false;
  for (; t2--; ) {
    const r2 = e2[t2][1];
    if ((r2.type === "labelLink" || r2.type === "labelImage") && !r2._balanced) {
      n = true;
      break;
    }
    if (r2._gfmAutolinkLiteralWalkedInto) {
      n = false;
      break;
    }
  }
  return e2.length > 0 && !n && (e2[e2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true), n;
}
function kt(e2) {
  const t2 = [];
  let n = -1, r2 = 0, u = 0;
  for (; ++n < e2.length; ) {
    const a = e2.charCodeAt(n);
    let i = "";
    if (a === 37 && me(e2.charCodeAt(n + 1)) && me(e2.charCodeAt(n + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e2.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(a, o), u = 1) : i = "�";
    } else
      i = String.fromCharCode(a);
    i && (t2.push(e2.slice(r2, n), encodeURIComponent(i)), r2 = n + u + 1, i = ""), u && (n += u, u = 0);
  }
  return t2.join("") + e2.slice(r2);
}
function Wh(e2, t2, n) {
  const r2 = [];
  let u = -1;
  for (; ++u < e2.length; ) {
    const a = e2[u].resolveAll;
    a && !r2.includes(a) && (t2 = a(t2, n), r2.push(a));
  }
  return t2;
}
function J(e2, t2, n, r2) {
  const u = r2 ? r2 - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(l3) {
    return X(l3) ? (e2.enter(n), o(l3)) : t2(l3);
  }
  function o(l3) {
    return X(l3) && a++ < u ? (e2.consume(l3), o) : (e2.exit(n), t2(l3));
  }
}
var Gh = {
  partial: true,
  tokenize: Qh
};
function Qh(e2, t2, n) {
  return r2;
  function r2(a) {
    return X(a) ? J(e2, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? t2(a) : n(a);
  }
}
function Wt(e2, t2) {
  let n;
  return r2;
  function r2(u) {
    return z(u) ? (e2.enter("lineEnding"), e2.consume(u), e2.exit("lineEnding"), n = true, r2) : X(u) ? J(e2, r2, n ? "linePrefix" : "lineSuffix")(u) : t2(u);
  }
}
var $h = {
  tokenize: rd,
  partial: true
};
function Xh() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: ed,
        continuation: {
          tokenize: td
        },
        exit: nd
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: Zh
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Kh,
        resolveTo: Jh
      }
    }
  };
}
function Kh(e2, t2, n) {
  const r2 = this;
  let u = r2.events.length;
  const a = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const l3 = r2.events[u][1];
    if (l3.type === "labelImage") {
      i = l3;
      break;
    }
    if (l3.type === "gfmFootnoteCall" || l3.type === "labelLink" || l3.type === "label" || l3.type === "image" || l3.type === "link")
      break;
  }
  return o;
  function o(l3) {
    if (!i || !i._balanced)
      return n(l3);
    const c = un(r2.sliceSerialize({
      start: i.end,
      end: r2.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l3) : (e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(l3), e2.exit("gfmFootnoteCallLabelMarker"), t2(l3));
  }
}
function Jh(e2, t2) {
  let n = e2.length;
  for (; n--; )
    if (e2[n][1].type === "labelImage" && e2[n][0] === "enter") {
      e2[n][1];
      break;
    }
  e2[n + 1][1].type = "data", e2[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r2 = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e2[n + 3][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e2[n + 3][1].end),
    end: Object.assign({}, e2[n + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, e2[e2.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e2[n + 1],
    e2[n + 2],
    ["enter", r2, t2],
    // The `[`
    e2[n + 3],
    e2[n + 4],
    // The `^`.
    ["enter", u, t2],
    ["exit", u, t2],
    // Everything in between.
    ["enter", a, t2],
    ["enter", i, t2],
    ["exit", i, t2],
    ["exit", a, t2],
    // The ending (`]`, properly parsed and labelled).
    e2[e2.length - 2],
    e2[e2.length - 1],
    ["exit", r2, t2]
  ];
  return e2.splice(n, e2.length - n + 1, ...o), e2;
}
function Zh(e2, t2, n) {
  const r2 = this, u = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
  let a = 0, i;
  return o;
  function o(f2) {
    return e2.enter("gfmFootnoteCall"), e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(f2), e2.exit("gfmFootnoteCallLabelMarker"), l3;
  }
  function l3(f2) {
    return f2 !== 94 ? n(f2) : (e2.enter("gfmFootnoteCallMarker"), e2.consume(f2), e2.exit("gfmFootnoteCallMarker"), e2.enter("gfmFootnoteCallString"), e2.enter("chunkString").contentType = "string", c);
  }
  function c(f2) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f2 === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f2 === null || f2 === 91 || ne(f2)
    )
      return n(f2);
    if (f2 === 93) {
      e2.exit("chunkString");
      const p2 = e2.exit("gfmFootnoteCallString");
      return u.includes(un(r2.sliceSerialize(p2))) ? (e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(f2), e2.exit("gfmFootnoteCallLabelMarker"), e2.exit("gfmFootnoteCall"), t2) : n(f2);
    }
    return ne(f2) || (i = true), a++, e2.consume(f2), f2 === 92 ? h : c;
  }
  function h(f2) {
    return f2 === 91 || f2 === 92 || f2 === 93 ? (e2.consume(f2), a++, c) : c(f2);
  }
}
function ed(e2, t2, n) {
  const r2 = this, u = r2.parser.gfmFootnotes || (r2.parser.gfmFootnotes = []);
  let a, i = 0, o;
  return l3;
  function l3(A) {
    return e2.enter("gfmFootnoteDefinition")._container = true, e2.enter("gfmFootnoteDefinitionLabel"), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(A), e2.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(A) {
    return A === 94 ? (e2.enter("gfmFootnoteDefinitionMarker"), e2.consume(A), e2.exit("gfmFootnoteDefinitionMarker"), e2.enter("gfmFootnoteDefinitionLabelString"), e2.enter("chunkString").contentType = "string", h) : n(A);
  }
  function h(A) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      A === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      A === null || A === 91 || ne(A)
    )
      return n(A);
    if (A === 93) {
      e2.exit("chunkString");
      const C = e2.exit("gfmFootnoteDefinitionLabelString");
      return a = un(r2.sliceSerialize(C)), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(A), e2.exit("gfmFootnoteDefinitionLabelMarker"), e2.exit("gfmFootnoteDefinitionLabel"), p2;
    }
    return ne(A) || (o = true), i++, e2.consume(A), A === 92 ? f2 : h;
  }
  function f2(A) {
    return A === 91 || A === 92 || A === 93 ? (e2.consume(A), i++, h) : h(A);
  }
  function p2(A) {
    return A === 58 ? (e2.enter("definitionMarker"), e2.consume(A), e2.exit("definitionMarker"), u.includes(a) || u.push(a), J(e2, d, "gfmFootnoteDefinitionWhitespace")) : n(A);
  }
  function d(A) {
    return t2(A);
  }
}
function td(e2, t2, n) {
  return e2.check(Gh, t2, e2.attempt($h, t2, n));
}
function nd(e2) {
  e2.exit("gfmFootnoteDefinition");
}
function rd(e2, t2, n) {
  const r2 = this;
  return J(e2, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r2.events[r2.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], true).length === 4 ? t2(a) : n(a);
  }
}
function ud(e2) {
  let n = (e2 || {}).singleTilde;
  const r2 = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return n == null && (n = true), {
    text: {
      126: r2
    },
    insideSpan: {
      null: [r2]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, o) {
    let l3 = -1;
    for (; ++l3 < i.length; )
      if (i[l3][0] === "enter" && i[l3][1].type === "strikethroughSequenceTemporary" && i[l3][1]._close) {
        let c = l3;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[l3][1].end.offset - i[l3][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[l3][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[l3][1].end)
            }, f2 = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[l3][1].start)
            }, p2 = [["enter", h, o], ["enter", i[c][1], o], ["exit", i[c][1], o], ["enter", f2, o]], d = o.parser.constructs.insideSpan.null;
            d && gn(p2, p2.length, 0, Wh(d, i.slice(c + 1, l3), o)), gn(p2, p2.length, 0, [["exit", f2, o], ["enter", i[l3][1], o], ["exit", i[l3][1], o], ["exit", h, o]]), gn(i, c - 1, l3 - c + 3, p2), l3 = c + p2.length - 2;
            break;
          }
      }
    for (l3 = -1; ++l3 < i.length; )
      i[l3][1].type === "strikethroughSequenceTemporary" && (i[l3][1].type = "data");
    return i;
  }
  function a(i, o, l3) {
    const c = this.previous, h = this.events;
    let f2 = 0;
    return p2;
    function p2(A) {
      return c === 126 && h[h.length - 1][1].type !== "characterEscape" ? l3(A) : (i.enter("strikethroughSequenceTemporary"), d(A));
    }
    function d(A) {
      const C = _t2(c);
      if (A === 126)
        return f2 > 1 ? l3(A) : (i.consume(A), f2++, d);
      if (f2 < 2 && !n) return l3(A);
      const y2 = i.exit("strikethroughSequenceTemporary"), S = _t2(A);
      return y2._open = !S || S === 2 && !!C, y2._close = !C || C === 2 && !!S, o(A);
    }
  }
}
var id = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t2, n, r2) {
    ad(this, t2, n, r2);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t2) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r2 = [];
    for (; n > 0; )
      n -= 1, r2.push(t2.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t2.length = this.map[n][0];
    r2.push(t2.slice()), t2.length = 0;
    let u = r2.pop();
    for (; u; ) {
      for (const a of u)
        t2.push(a);
      u = r2.pop();
    }
    this.map.length = 0;
  }
};
function ad(e2, t2, n, r2) {
  let u = 0;
  if (!(n === 0 && r2.length === 0)) {
    for (; u < e2.map.length; ) {
      if (e2.map[u][0] === t2) {
        e2.map[u][1] += n, e2.map[u][2].push(...r2);
        return;
      }
      u += 1;
    }
    e2.map.push([t2, n, r2]);
  }
}
function sd(e2, t2) {
  let n = false;
  const r2 = [];
  for (; t2 < e2.length; ) {
    const u = e2[t2];
    if (n) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r2.push(e2[t2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (e2[t2 - 1][1].type === "tableDelimiterMarker") {
          const a = r2.length - 1;
          r2[a] = r2[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (n = true);
    t2 += 1;
  }
  return r2;
}
function od() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: ld,
        resolveAll: cd
      }
    }
  };
}
function ld(e2, t2, n) {
  const r2 = this;
  let u = 0, a = 0, i;
  return o;
  function o(I) {
    let H = r2.events.length - 1;
    for (; H > -1; ) {
      const F = r2.events[H][1].type;
      if (F === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      F === "linePrefix") H--;
      else break;
    }
    const U = H > -1 ? r2.events[H][1].type : null, v = U === "tableHead" || U === "tableRow" ? k : l3;
    return v === k && r2.parser.lazy[r2.now().line] ? n(I) : v(I);
  }
  function l3(I) {
    return e2.enter("tableHead"), e2.enter("tableRow"), c(I);
  }
  function c(I) {
    return I === 124 || (i = true, a += 1), h(I);
  }
  function h(I) {
    return I === null ? n(I) : z(I) ? a > 1 ? (a = 0, r2.interrupt = true, e2.exit("tableRow"), e2.enter("lineEnding"), e2.consume(I), e2.exit("lineEnding"), d) : n(I) : X(I) ? J(e2, h, "whitespace")(I) : (a += 1, i && (i = false, u += 1), I === 124 ? (e2.enter("tableCellDivider"), e2.consume(I), e2.exit("tableCellDivider"), i = true, h) : (e2.enter("data"), f2(I)));
  }
  function f2(I) {
    return I === null || I === 124 || ne(I) ? (e2.exit("data"), h(I)) : (e2.consume(I), I === 92 ? p2 : f2);
  }
  function p2(I) {
    return I === 92 || I === 124 ? (e2.consume(I), f2) : f2(I);
  }
  function d(I) {
    return r2.interrupt = false, r2.parser.lazy[r2.now().line] ? n(I) : (e2.enter("tableDelimiterRow"), i = false, X(I) ? J(e2, A, "linePrefix", r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(I) : A(I));
  }
  function A(I) {
    return I === 45 || I === 58 ? y2(I) : I === 124 ? (i = true, e2.enter("tableCellDivider"), e2.consume(I), e2.exit("tableCellDivider"), C) : q(I);
  }
  function C(I) {
    return X(I) ? J(e2, y2, "whitespace")(I) : y2(I);
  }
  function y2(I) {
    return I === 58 ? (a += 1, i = true, e2.enter("tableDelimiterMarker"), e2.consume(I), e2.exit("tableDelimiterMarker"), S) : I === 45 ? (a += 1, S(I)) : I === null || z(I) ? Y(I) : q(I);
  }
  function S(I) {
    return I === 45 ? (e2.enter("tableDelimiterFiller"), O(I)) : q(I);
  }
  function O(I) {
    return I === 45 ? (e2.consume(I), O) : I === 58 ? (i = true, e2.exit("tableDelimiterFiller"), e2.enter("tableDelimiterMarker"), e2.consume(I), e2.exit("tableDelimiterMarker"), L) : (e2.exit("tableDelimiterFiller"), L(I));
  }
  function L(I) {
    return X(I) ? J(e2, Y, "whitespace")(I) : Y(I);
  }
  function Y(I) {
    return I === 124 ? A(I) : I === null || z(I) ? !i || u !== a ? q(I) : (e2.exit("tableDelimiterRow"), e2.exit("tableHead"), t2(I)) : q(I);
  }
  function q(I) {
    return n(I);
  }
  function k(I) {
    return e2.enter("tableRow"), Q(I);
  }
  function Q(I) {
    return I === 124 ? (e2.enter("tableCellDivider"), e2.consume(I), e2.exit("tableCellDivider"), Q) : I === null || z(I) ? (e2.exit("tableRow"), t2(I)) : X(I) ? J(e2, Q, "whitespace")(I) : (e2.enter("data"), Z(I));
  }
  function Z(I) {
    return I === null || I === 124 || ne(I) ? (e2.exit("data"), Q(I)) : (e2.consume(I), I === 92 ? ee : Z);
  }
  function ee(I) {
    return I === 92 || I === 124 ? (e2.consume(I), Z) : Z(I);
  }
}
function cd(e2, t2) {
  let n = -1, r2 = true, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], o = false, l3 = 0, c, h, f2;
  const p2 = new id();
  for (; ++n < e2.length; ) {
    const d = e2[n], A = d[1];
    d[0] === "enter" ? A.type === "tableHead" ? (o = false, l3 !== 0 && (Gu(p2, t2, l3, c, h), h = void 0, l3 = 0), c = {
      type: "table",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p2.add(n, 0, [["enter", c, t2]])) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (r2 = true, f2 = void 0, a = [0, 0, 0, 0], i = [0, n + 1, 0, 0], o && (o = false, h = {
      type: "tableBody",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p2.add(n, 0, [["enter", h, t2]])), u = A.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") ? (r2 = false, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], f2 = cn(p2, t2, a, u, void 0, f2), a = [0, 0, 0, 0]), i[2] = n)) : A.type === "tableCellDivider" && (r2 ? r2 = false : (a[1] !== 0 && (i[0] = i[1], f2 = cn(p2, t2, a, u, void 0, f2)), a = i, i = [a[1], n, 0, 0])) : A.type === "tableHead" ? (o = true, l3 = n) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (l3 = n, a[1] !== 0 ? (i[0] = i[1], f2 = cn(p2, t2, a, u, n, f2)) : i[1] !== 0 && (f2 = cn(p2, t2, i, u, n, f2)), u = 0) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") && (i[3] = n);
  }
  for (l3 !== 0 && Gu(p2, t2, l3, c, h), p2.consume(t2.events), n = -1; ++n < t2.events.length; ) {
    const d = t2.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = sd(t2.events, n));
  }
  return e2;
}
function cn(e2, t2, n, r2, u, a) {
  const i = r2 === 1 ? "tableHeader" : r2 === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, mt(t2.events, n[0])), e2.add(n[0], 0, [["exit", a, t2]]));
  const l3 = mt(t2.events, n[1]);
  if (a = {
    type: i,
    start: Object.assign({}, l3),
    // Note: correct end is set later.
    end: Object.assign({}, l3)
  }, e2.add(n[1], 0, [["enter", a, t2]]), n[2] !== 0) {
    const c = mt(t2.events, n[2]), h = mt(t2.events, n[3]), f2 = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, h)
    };
    if (e2.add(n[2], 0, [["enter", f2, t2]]), r2 !== 2) {
      const p2 = t2.events[n[2]], d = t2.events[n[3]];
      if (p2[1].end = Object.assign({}, d[1].end), p2[1].type = "chunkText", p2[1].contentType = "text", n[3] > n[2] + 1) {
        const A = n[2] + 1, C = n[3] - n[2] - 1;
        e2.add(A, C, []);
      }
    }
    e2.add(n[3] + 1, 0, [["exit", f2, t2]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, mt(t2.events, u)), e2.add(u, 0, [["exit", a, t2]]), a = void 0), a;
}
function Gu(e2, t2, n, r2, u) {
  const a = [], i = mt(t2.events, n);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, t2])), r2.end = Object.assign({}, i), a.push(["exit", r2, t2]), e2.add(n + 1, 0, a);
}
function mt(e2, t2) {
  const n = e2[t2], r2 = n[0] === "enter" ? "start" : "end";
  return n[1][r2];
}
var fd = {
  name: "tasklistCheck",
  tokenize: dd
};
function hd() {
  return {
    text: {
      91: fd
    }
  };
}
function dd(e2, t2, n) {
  const r2 = this;
  return u;
  function u(l3) {
    return (
      // Exit if there’s stuff before.
      r2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r2._gfmTasklistFirstContentOfListItem ? n(l3) : (e2.enter("taskListCheck"), e2.enter("taskListCheckMarker"), e2.consume(l3), e2.exit("taskListCheckMarker"), a)
    );
  }
  function a(l3) {
    return ne(l3) ? (e2.enter("taskListCheckValueUnchecked"), e2.consume(l3), e2.exit("taskListCheckValueUnchecked"), i) : l3 === 88 || l3 === 120 ? (e2.enter("taskListCheckValueChecked"), e2.consume(l3), e2.exit("taskListCheckValueChecked"), i) : n(l3);
  }
  function i(l3) {
    return l3 === 93 ? (e2.enter("taskListCheckMarker"), e2.consume(l3), e2.exit("taskListCheckMarker"), e2.exit("taskListCheck"), o) : n(l3);
  }
  function o(l3) {
    return z(l3) ? t2(l3) : X(l3) ? e2.check({
      tokenize: md
    }, t2, n)(l3) : n(l3);
  }
}
function md(e2, t2, n) {
  return J(e2, r2, "whitespace");
  function r2(u) {
    return u === null ? n(u) : t2(u);
  }
}
function pd(e2) {
  return Dh([
    Fh(),
    Xh(),
    ud(e2),
    od(),
    hd()
  ]);
}
var Ed = {};
function gd(e2) {
  const t2 = (
    /** @type {Processor<Root>} */
    this
  ), n = e2 || Ed, r2 = t2.data(), u = r2.micromarkExtensions || (r2.micromarkExtensions = []), a = r2.fromMarkdownExtensions || (r2.fromMarkdownExtensions = []), i = r2.toMarkdownExtensions || (r2.toMarkdownExtensions = []);
  u.push(pd(n)), a.push(Lh()), i.push(Rh(n));
}
var ds = (0, import_react.createContext)(
  void 0
);
var Wr = () => {
  const e2 = (0, import_react.useContext)(ds);
  if (!e2)
    throw new Error(
      "useViewportAnchor must be used within a CurrentAnchorProvider"
    );
  return e2;
};
var Td = () => {
  const e2 = (0, import_react.useRef)(null), { observe: t2, unobserve: n } = Wr();
  return (0, import_react.useEffect)(() => {
    const u = e2.current;
    if (u)
      return t2(u), () => n(u);
  }, [t2, n]), { ref: (0, import_react.useCallback)((u) => {
    u && (e2.current = u);
  }, []) };
};
var Ng = ({ children: e2 }) => {
  const [t2, n] = (0, import_react.useState)(""), r2 = (0, import_react.useRef)(null), u = (0, import_react.useRef)(/* @__PURE__ */ new Set()), a = (0, import_react.useRef)(/* @__PURE__ */ new Set());
  (0, import_react.useEffect)(() => (r2.current = new IntersectionObserver(
    (l3) => {
      for (const c of l3)
        c.isIntersecting && c.target.id && n(c.target.id);
    },
    {
      rootMargin: "0px 0px -80% 0px",
      threshold: 0.75
    }
  ), a.current.forEach((l3) => {
    var c;
    u.current.add(l3), (c = r2.current) == null || c.observe(l3);
  }), a.current.clear(), () => {
    var l3;
    return (l3 = r2.current) == null ? void 0 : l3.disconnect();
  }), []), (0, import_react.useEffect)(() => {
    const l3 = u.current, c = () => {
      const h = window.scrollY === 0, f2 = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      if (h)
        n("");
      else if (f2) {
        const p2 = Array.from(l3).pop(), d = (p2 == null ? void 0 : p2.id) ?? "";
        n(d);
      }
    };
    return document.addEventListener("scroll", c), () => {
      l3.clear(), document.removeEventListener("scroll", c);
    };
  }, []);
  const i = (0, import_react.useMemo)(() => ({
    observe: (l3) => {
      if (l3) {
        if (!r2.current) {
          a.current.add(l3);
          return;
        }
        u.current.add(l3), r2.current.observe(l3);
      }
    },
    unobserve: (l3) => {
      var c;
      l3 && (a.current.delete(l3), u.current.delete(l3), (c = r2.current) == null || c.unobserve(l3));
    }
  }), []), o = (0, import_react.useMemo)(
    () => ({ activeAnchor: t2, setActiveAnchor: n, ...i }),
    [t2, n, i]
  );
  return ae.jsx(ds, { value: o, children: e2 });
};
var bd = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600",
  outline: "border border-border rounded-md text-foreground"
};
var Ad = {
  green: "text-green-500 dark:text-green-600",
  blue: "text-sky-400 dark:text-sky-600",
  yellow: "text-yellow-400 dark:text-yellow-600",
  red: "text-red-400 dark:text-red-600",
  purple: "text-purple-400 dark:text-purple-600",
  indigo: "text-indigo-400 dark:text-indigo-600",
  gray: "text-gray-400 dark:text-gray-600",
  outline: ""
};
var Qu = ({
  color: e2,
  label: t2,
  className: n,
  invert: r2
}) => ae.jsx(
  "span",
  {
    className: We(
      "flex items-center duration-200 transition-opacity text-center uppercase text-[0.65rem] font-bold rounded text-background dark:text-zinc-50 h-full",
      e2 === "outline" ? "px-3" : "mt-0.5 px-1",
      r2 ? Ad[e2] : bd[e2],
      n
    ),
    children: t2
  }
);
var _d = Object.getOwnPropertyNames;
var Cd = Object.getOwnPropertySymbols;
var Sd = Object.prototype.hasOwnProperty;
function $u(e2, t2) {
  return function(r2, u, a) {
    return e2(r2, u, a) && t2(r2, u, a);
  };
}
function fn(e2) {
  return function(n, r2, u) {
    if (!n || !r2 || typeof n != "object" || typeof r2 != "object")
      return e2(n, r2, u);
    var a = u.cache, i = a.get(n), o = a.get(r2);
    if (i && o)
      return i === r2 && o === n;
    a.set(n, r2), a.set(r2, n);
    var l3 = e2(n, r2, u);
    return a.delete(n), a.delete(r2), l3;
  };
}
function Xu(e2) {
  return _d(e2).concat(Cd(e2));
}
var xd = Object.hasOwn || function(e2, t2) {
  return Sd.call(e2, t2);
};
function at(e2, t2) {
  return e2 === t2 || !e2 && !t2 && e2 !== e2 && t2 !== t2;
}
var Id = "__v";
var kd = "__o";
var yd = "_owner";
var Ku = Object.getOwnPropertyDescriptor;
var Ju = Object.keys;
function Nd(e2, t2, n) {
  var r2 = e2.length;
  if (t2.length !== r2)
    return false;
  for (; r2-- > 0; )
    if (!n.equals(e2[r2], t2[r2], r2, r2, e2, t2, n))
      return false;
  return true;
}
function Od(e2, t2) {
  return at(e2.getTime(), t2.getTime());
}
function Ld(e2, t2) {
  return e2.name === t2.name && e2.message === t2.message && e2.cause === t2.cause && e2.stack === t2.stack;
}
function Rd(e2, t2) {
  return e2 === t2;
}
function Zu(e2, t2, n) {
  var r2 = e2.size;
  if (r2 !== t2.size)
    return false;
  if (!r2)
    return true;
  for (var u = new Array(r2), a = e2.entries(), i, o, l3 = 0; (i = a.next()) && !i.done; ) {
    for (var c = t2.entries(), h = false, f2 = 0; (o = c.next()) && !o.done; ) {
      if (u[f2]) {
        f2++;
        continue;
      }
      var p2 = i.value, d = o.value;
      if (n.equals(p2[0], d[0], l3, f2, e2, t2, n) && n.equals(p2[1], d[1], p2[0], d[0], e2, t2, n)) {
        h = u[f2] = true;
        break;
      }
      f2++;
    }
    if (!h)
      return false;
    l3++;
  }
  return true;
}
var Dd = at;
function Pd(e2, t2, n) {
  var r2 = Ju(e2), u = r2.length;
  if (Ju(t2).length !== u)
    return false;
  for (; u-- > 0; )
    if (!ms(e2, t2, n, r2[u]))
      return false;
  return true;
}
function wt(e2, t2, n) {
  var r2 = Xu(e2), u = r2.length;
  if (Xu(t2).length !== u)
    return false;
  for (var a, i, o; u-- > 0; )
    if (a = r2[u], !ms(e2, t2, n, a) || (i = Ku(e2, a), o = Ku(t2, a), (i || o) && (!i || !o || i.configurable !== o.configurable || i.enumerable !== o.enumerable || i.writable !== o.writable)))
      return false;
  return true;
}
function wd(e2, t2) {
  return at(e2.valueOf(), t2.valueOf());
}
function Md(e2, t2) {
  return e2.source === t2.source && e2.flags === t2.flags;
}
function ei(e2, t2, n) {
  var r2 = e2.size;
  if (r2 !== t2.size)
    return false;
  if (!r2)
    return true;
  for (var u = new Array(r2), a = e2.values(), i, o; (i = a.next()) && !i.done; ) {
    for (var l3 = t2.values(), c = false, h = 0; (o = l3.next()) && !o.done; ) {
      if (!u[h] && n.equals(i.value, o.value, i.value, o.value, e2, t2, n)) {
        c = u[h] = true;
        break;
      }
      h++;
    }
    if (!c)
      return false;
  }
  return true;
}
function Bd(e2, t2) {
  var n = e2.length;
  if (t2.length !== n)
    return false;
  for (; n-- > 0; )
    if (e2[n] !== t2[n])
      return false;
  return true;
}
function Fd(e2, t2) {
  return e2.hostname === t2.hostname && e2.pathname === t2.pathname && e2.protocol === t2.protocol && e2.port === t2.port && e2.hash === t2.hash && e2.username === t2.username && e2.password === t2.password;
}
function ms(e2, t2, n, r2) {
  return (r2 === yd || r2 === kd || r2 === Id) && (e2.$$typeof || t2.$$typeof) ? true : xd(t2, r2) && n.equals(e2[r2], t2[r2], r2, r2, e2, t2, n);
}
var Hd = "[object Arguments]";
var Ud = "[object Boolean]";
var vd = "[object Date]";
var zd = "[object Error]";
var Yd = "[object Map]";
var qd = "[object Number]";
var jd = "[object Object]";
var Vd = "[object RegExp]";
var Wd = "[object Set]";
var Gd = "[object String]";
var Qd = "[object URL]";
var $d = Array.isArray;
var ti = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var ni = Object.assign;
var Xd = Object.prototype.toString.call.bind(Object.prototype.toString);
function Kd(e2) {
  var t2 = e2.areArraysEqual, n = e2.areDatesEqual, r2 = e2.areErrorsEqual, u = e2.areFunctionsEqual, a = e2.areMapsEqual, i = e2.areNumbersEqual, o = e2.areObjectsEqual, l3 = e2.arePrimitiveWrappersEqual, c = e2.areRegExpsEqual, h = e2.areSetsEqual, f2 = e2.areTypedArraysEqual, p2 = e2.areUrlsEqual;
  return function(A, C, y2) {
    if (A === C)
      return true;
    if (A == null || C == null)
      return false;
    var S = typeof A;
    if (S !== typeof C)
      return false;
    if (S !== "object")
      return S === "number" ? i(A, C, y2) : S === "function" ? u(A, C, y2) : false;
    var O = A.constructor;
    if (O !== C.constructor)
      return false;
    if (O === Object)
      return o(A, C, y2);
    if ($d(A))
      return t2(A, C, y2);
    if (ti != null && ti(A))
      return f2(A, C, y2);
    if (O === Date)
      return n(A, C, y2);
    if (O === RegExp)
      return c(A, C, y2);
    if (O === Map)
      return a(A, C, y2);
    if (O === Set)
      return h(A, C, y2);
    var L = Xd(A);
    return L === vd ? n(A, C, y2) : L === Vd ? c(A, C, y2) : L === Yd ? a(A, C, y2) : L === Wd ? h(A, C, y2) : L === jd ? typeof A.then != "function" && typeof C.then != "function" && o(A, C, y2) : L === Qd ? p2(A, C, y2) : L === zd ? r2(A, C, y2) : L === Hd ? o(A, C, y2) : L === Ud || L === qd || L === Gd ? l3(A, C, y2) : false;
  };
}
function Jd(e2) {
  var t2 = e2.circular, n = e2.createCustomConfig, r2 = e2.strict, u = {
    areArraysEqual: r2 ? wt : Nd,
    areDatesEqual: Od,
    areErrorsEqual: Ld,
    areFunctionsEqual: Rd,
    areMapsEqual: r2 ? $u(Zu, wt) : Zu,
    areNumbersEqual: Dd,
    areObjectsEqual: r2 ? wt : Pd,
    arePrimitiveWrappersEqual: wd,
    areRegExpsEqual: Md,
    areSetsEqual: r2 ? $u(ei, wt) : ei,
    areTypedArraysEqual: r2 ? wt : Bd,
    areUrlsEqual: Fd
  };
  if (n && (u = ni({}, u, n(u))), t2) {
    var a = fn(u.areArraysEqual), i = fn(u.areMapsEqual), o = fn(u.areObjectsEqual), l3 = fn(u.areSetsEqual);
    u = ni({}, u, {
      areArraysEqual: a,
      areMapsEqual: i,
      areObjectsEqual: o,
      areSetsEqual: l3
    });
  }
  return u;
}
function Zd(e2) {
  return function(t2, n, r2, u, a, i, o) {
    return e2(t2, n, o);
  };
}
function em(e2) {
  var t2 = e2.circular, n = e2.comparator, r2 = e2.createState, u = e2.equals, a = e2.strict;
  if (r2)
    return function(l3, c) {
      var h = r2(), f2 = h.cache, p2 = f2 === void 0 ? t2 ? /* @__PURE__ */ new WeakMap() : void 0 : f2, d = h.meta;
      return n(l3, c, {
        cache: p2,
        equals: u,
        meta: d,
        strict: a
      });
    };
  if (t2)
    return function(l3, c) {
      return n(l3, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: u,
        meta: void 0,
        strict: a
      });
    };
  var i = {
    cache: void 0,
    equals: u,
    meta: void 0,
    strict: a
  };
  return function(l3, c) {
    return n(l3, c, i);
  };
}
var tm = $e();
$e({ strict: true });
$e({ circular: true });
$e({
  circular: true,
  strict: true
});
$e({
  createInternalComparator: function() {
    return at;
  }
});
$e({
  strict: true,
  createInternalComparator: function() {
    return at;
  }
});
$e({
  circular: true,
  createInternalComparator: function() {
    return at;
  }
});
$e({
  circular: true,
  createInternalComparator: function() {
    return at;
  },
  strict: true
});
function $e(e2) {
  e2 === void 0 && (e2 = {});
  var t2 = e2.circular, n = t2 === void 0 ? false : t2, r2 = e2.createInternalComparator, u = e2.createState, a = e2.strict, i = a === void 0 ? false : a, o = Jd(e2), l3 = Kd(o), c = r2 ? r2(l3) : Zd(l3);
  return em({ circular: n, comparator: l3, createState: u, equals: c, strict: i });
}
var nm = ({
  category: e2,
  onRequestClose: t2
}) => {
  var A, C;
  const n = Ts(e2), [r2, u] = (0, import_react.useState)(false), a = e2.collapsible ?? true, i = e2.collapsed ?? true, o = !!(!a || !i || n), [l3, c] = (0, import_react.useState)(o), h = on(((A = e2.link) == null ? void 0 : A.id) ?? "");
  (0, import_react.useEffect)(() => {
    n && c(true);
  }, [n]);
  const f2 = a && ae.jsx(
    l2,
    {
      onClick: (y2) => {
        y2.preventDefault(), c((S) => !S), u(true);
      },
      variant: "ghost",
      size: "icon",
      className: "size-6 hover:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l-5))] hover:dark:bg-[hsl(from_hsl(var(--accent))_h_s_calc(l+5))]",
      children: ae.jsx(
        ChevronRight,
        {
          size: 16,
          className: We(
            r2 && "transition",
            "shrink-0 group-data-[state=open]:rotate-90"
          )
        }
      )
    }
  ), p2 = e2.icon && ae.jsx(
    e2.icon,
    {
      size: 16,
      className: We("align-[-0.125em] ", h && "text-primary")
    }
  ), d = Tn({
    className: [
      "group text-start font-medium",
      a || typeof e2.link < "u" ? "cursor-pointer" : "cursor-default hover:bg-transparent"
    ]
  });
  return ae.jsxs(
    Root,
    {
      className: "flex flex-col",
      defaultOpen: o,
      open: l3,
      onOpenChange: () => c(true),
      children: [
        ae.jsx(Trigger, { className: "group", asChild: true, disabled: !a, children: ((C = e2.link) == null ? void 0 : C.type) === "doc" ? ae.jsxs(
          Bt,
          {
            to: ce(e2.link.id),
            className: d,
            onClick: () => {
              u(true), h && !l3 && c(true);
            },
            children: [
              p2,
              ae.jsxs("div", { className: "flex items-center gap-2 justify-between w-full text-foreground/80 group-aria-[current='page']:text-primary", children: [
                ae.jsx("div", { className: "truncate", children: e2.label }),
                f2
              ] })
            ]
          }
        ) : ae.jsxs("div", { onClick: () => u(true), className: d, children: [
          p2,
          ae.jsxs("div", { className: "flex items-center justify-between w-full", children: [
            ae.jsx("div", { className: "flex gap-2 truncate w-full", children: e2.label }),
            f2
          ] })
        ] }) }),
        ae.jsx(
          Content,
          {
            className: We(
              // CollapsibleContent class is used to animate and it should only be applied when the user has triggered the toggle
              r2 && "CollapsibleContent",
              e2.items.length === 0 && "hidden",
              "ms-6 my-1"
            ),
            children: ae.jsx("ul", { className: "relative after:absolute after:-left-[--padding-nav-item] after:translate-x-[1.5px] after:top-0 after:bottom-0 after:w-px after:bg-border", children: e2.items.map((y2) => ae.jsx(
              rm,
              {
                onRequestClose: t2,
                item: y2
              },
              ("id" in y2 ? y2.id : "") + ("href" in y2 ? y2.href : "") + y2.label
            )) })
          }
        )
      ]
    }
  );
};
var ps = (0, import_react.memo)(nm, tm);
ps.displayName = "SidebarCategory";
var Tn = j(
  "flex items-center gap-2 px-[--padding-nav-item] my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums",
  {
    variants: {
      isActive: {
        true: "bg-accent font-medium",
        false: "text-foreground/80"
      },
      isMuted: {
        true: "text-foreground/30",
        false: ""
      },
      isPending: {
        true: "bg-accent animate-pulse",
        false: ""
      }
    },
    defaultVariants: {
      isActive: false
    }
  }
);
var Es = "data-anchor";
var rm = ({
  item: e2,
  onRequestClose: t2
}) => {
  var a;
  const n = N(), { activeAnchor: r2 } = Wr(), [u] = dn();
  switch (e2.type) {
    case "category":
      return ae.jsx(ps, { category: e2, onRequestClose: t2 });
    case "doc":
      return ae.jsxs(
        Bt,
        {
          className: ({ isActive: i, isPending: o }) => Tn({ isActive: i, isPending: o }),
          to: et2(e2.id),
          onClick: t2,
          end: true,
          children: [
            e2.icon && ae.jsx(e2.icon, { size: 16, className: "align-[-0.125em]" }),
            e2.badge ? ae.jsxs(ae.Fragment, { children: [
              ae.jsx("span", { className: "truncate flex-1", title: e2.label, children: e2.label }),
              ae.jsx(Qu, { ...e2.badge })
            ] }) : e2.label
          ]
        }
      );
    case "link":
      return e2.href.startsWith("http") ? ae.jsxs(
        "a",
        {
          className: Tn(),
          href: e2.href,
          target: "_blank",
          rel: "noopener noreferrer",
          onClick: t2,
          children: [
            ae.jsx("span", { className: "whitespace-normal", children: e2.label }),
            ae.jsx("span", { className: "whitespace-nowrap", children: ae.jsx(ExternalLink, { className: "inline -translate-y-0.5", size: 12 }) })
          ]
        }
      ) : ae.jsx(
        Ts2,
        {
          to: {
            pathname: e2.href.split("#")[0],
            hash: e2.href.split("#")[1],
            search: u.toString()
          },
          [Es]: e2.href.split("#")[1],
          className: Tn({
            isActive: e2.href === [n.pathname, r2].join("#"),
            className: ((a = e2.badge) == null ? void 0 : a.placement) !== "start" && "justify-between"
          }),
          onClick: t2,
          children: e2.badge ? ae.jsxs(ae.Fragment, { children: [
            ae.jsx("span", { className: "truncate", title: e2.label, children: e2.label }),
            ae.jsx(Qu, { ...e2.badge })
          ] }) : ae.jsx("span", { className: "break-all", children: e2.label })
        }
      );
  }
};
var um = (e2, t2 = { block: "center" }) => {
  if (!e2) return;
  const n = e2.getBoundingClientRect();
  n.top >= 0 && n.left >= 0 && n.bottom <= (window.innerHeight || document.documentElement.clientHeight) && n.right <= (window.innerWidth || document.documentElement.clientWidth) || e2.scrollIntoView(t2);
};
var gs = () => {
  const { setActiveAnchor: e2 } = Wr();
  return (0, import_react.useCallback)(
    (n) => {
      const r2 = n.replace(/^#/, ""), u = r2.split("/").at(0), a = document.getElementById(decodeURIComponent(r2)), i = document.querySelector(
        `[${Es}="${u}"]`
      );
      return a ? (a.scrollIntoView(), um(i), requestIdleCallback(() => e2(u)), true) : false;
    },
    [e2]
  );
};
var Og = () => {
  const e2 = N(), t2 = gs(), n = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    !e2.hash || !n.current || t2(e2.hash);
  }, [e2.hash, t2]), (0, import_react.useEffect)(() => {
    if (!e2.hash) {
      n.current = true;
      return;
    }
    const r2 = new MutationObserver((u, a) => {
      t2(e2.hash) && (n.current = true, a.disconnect());
    });
    return r2.observe(document.body, { childList: true, subtree: true }), () => r2.disconnect();
  }, [e2.hash, t2]);
};
var Ts2 = (e2) => {
  const t2 = N(), n = gs(), r2 = et(e2.to), [u, a] = r2.split("#"), i = (o) => {
    var l3;
    (l3 = e2.onClick) == null || l3.call(e2, o), !(a !== t2.hash.slice(1) || u !== t2.pathname) && (o.preventDefault(), n(a));
  };
  return ae.jsx(Bt, { ...e2, onClick: i });
};
var im = j("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
});
var am = (e2) => {
  switch (e2) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
};
var ft = ({
  level: e2,
  children: t2,
  id: n,
  className: r2,
  registerSidebarAnchor: u
}) => {
  const a = am(e2 ?? 1), { ref: i } = Td();
  return ae.jsxs(
    a,
    {
      className: im({ className: r2, level: e2 }),
      ref: u ? i : void 0,
      id: n,
      children: [
        n && ae.jsx(
          "a",
          {
            href: `#${n}`,
            className: "before:content-['#'] no-underline absolute text-primary -left-[0.8em] pr-2.5 opacity-0 group-hover:opacity-50 hover:!opacity-100 transition-opacity duration-200",
            "aria-label": `Link to ${n}`,
            children: "​"
          }
        ),
        t2
      ]
    }
  );
};
var sm = ({
  asChild: e2,
  onClick: t2,
  enabled: n = true,
  ...r2
}) => {
  const u = e2 ? Slot : "span";
  return ae.jsx(
    u,
    {
      onClick: (a) => {
        if (n) {
          const i = document.createRange();
          i.selectNodeContents(a.currentTarget);
          const o = window.getSelection();
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        t2 == null || t2(a);
      },
      ...r2
    }
  );
};
var om = ({
  className: e2,
  children: t2,
  selectOnClick: n,
  onClick: r2
}) => ae.jsx(sm, { asChild: true, enabled: n, onClick: r2, children: ae.jsx(
  "code",
  {
    className: We(
      "font-mono border p-1 py-0.5 rounded bg-border/50 dark:bg-border/70 [overflow-wrap:anywhere]",
      e2
    ),
    children: t2
  }
) });
var lm = {
  img: ({ node: e2, ...t2 }) => /\.(mp4|webm|mov|avi)$/.test(t2.src ?? "") ? ae.jsx("video", { src: t2.src, controls: true, playsInline: true, autoPlay: true, loop: true }) : ae.jsx("img", { ...t2, className: "rounded-md" }),
  h1: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 1, id: t2, children: e2 }),
  h2: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 2, id: t2, children: e2 }),
  h3: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 3, id: t2, children: e2 }),
  h4: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 4, id: t2, children: e2 }),
  h5: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 5, id: t2, children: e2 }),
  h6: ({ children: e2, id: t2 }) => ae.jsx(ft, { level: 6, id: t2, children: e2 }),
  a: ({ href: e2, node: t2, ...n }) => e2 && !e2.startsWith("http") ? ae.jsx(Ts2, { to: e2, relative: "path", ...n }) : ae.jsx("a", { href: e2, target: "_blank", ...n, rel: "noreferrer" }),
  Button: l,
  Callout: p,
  Stepper: t,
  SyntaxHighlight: _t,
  tip: (e2) => ae.jsx(p, { type: "tip", ...e2 }),
  info: (e2) => ae.jsx(p, { type: "info", ...e2 }),
  note: (e2) => ae.jsx(p, { type: "note", ...e2 }),
  caution: (e2) => ae.jsx(p, { type: "caution", ...e2 }),
  warning: (e2) => ae.jsx(p, { type: "caution", ...e2 }),
  danger: (e2) => ae.jsx(p, { type: "danger", ...e2 }),
  pre: ({ children: e2 }) => ae.jsx(ae.Fragment, { children: e2 }),
  code: ({ className: e2, children: t2, ...n }) => {
    const { inline: r2, title: u } = n;
    if (r2 === true || r2 === "true")
      return ae.jsx(om, { className: e2, children: t2 });
    const a = e2 == null ? void 0 : e2.match(/language?-(\w+)/);
    return ae.jsx(
      _t,
      {
        language: a == null ? void 0 : a[1],
        className: "rounded-xl p-4 border dark:!bg-foreground/10 dark:border-transparent",
        showLanguageIndicator: true,
        code: String(t2).trim(),
        title: typeof u == "string" ? u : void 0
      }
    );
  }
};
var cm = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var fm = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var hm = {};
function ri(e2, t2) {
  return (hm.jsx ? fm : cm).test(e2);
}
var dm = /[ \t\n\f\r]/g;
function mm(e2) {
  return typeof e2 == "object" ? e2.type === "text" ? ui(e2.value) : false : ui(e2);
}
function ui(e2) {
  return e2.replace(dm, "") === "";
}
var an = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t2, n, r2) {
    this.normal = n, this.property = t2, r2 && (this.space = r2);
  }
};
an.prototype.normal = {};
an.prototype.property = {};
an.prototype.space = void 0;
function bs(e2, t2) {
  const n = {}, r2 = {};
  for (const u of e2)
    Object.assign(n, u.property), Object.assign(r2, u.normal);
  return new an(n, r2, t2);
}
function _r(e2) {
  return e2.toLowerCase();
}
var Ae = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t2, n) {
    this.attribute = n, this.property = t2;
  }
};
Ae.prototype.attribute = "";
Ae.prototype.booleanish = false;
Ae.prototype.boolean = false;
Ae.prototype.commaOrSpaceSeparated = false;
Ae.prototype.commaSeparated = false;
Ae.prototype.defined = false;
Ae.prototype.mustUseProperty = false;
Ae.prototype.number = false;
Ae.prototype.overloadedBoolean = false;
Ae.prototype.property = "";
Ae.prototype.spaceSeparated = false;
Ae.prototype.space = void 0;
var pm = 0;
var G = st();
var oe = st();
var As = st();
var w = st();
var ue = st();
var gt = st();
var Se = st();
function st() {
  return 2 ** ++pm;
}
var Cr = Object.freeze(Object.defineProperty({
  __proto__: null,
  boolean: G,
  booleanish: oe,
  commaOrSpaceSeparated: Se,
  commaSeparated: gt,
  number: w,
  overloadedBoolean: As,
  spaceSeparated: ue
}, Symbol.toStringTag, { value: "Module" }));
var Kn = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Cr)
);
var Gr = class extends Ae {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t2, n, r2, u) {
    let a = -1;
    if (super(t2, n), ii(this, "space", u), typeof r2 == "number")
      for (; ++a < Kn.length; ) {
        const i = Kn[a];
        ii(this, Kn[a], (r2 & Cr[i]) === Cr[i]);
      }
  }
};
Gr.prototype.defined = true;
function ii(e2, t2, n) {
  n && (e2[t2] = n);
}
function yt(e2) {
  const t2 = {}, n = {};
  for (const [r2, u] of Object.entries(e2.properties)) {
    const a = new Gr(
      r2,
      e2.transform(e2.attributes || {}, r2),
      u,
      e2.space
    );
    e2.mustUseProperty && e2.mustUseProperty.includes(r2) && (a.mustUseProperty = true), t2[r2] = a, n[_r(r2)] = r2, n[_r(a.attribute)] = r2;
  }
  return new an(t2, n, e2.space);
}
var _s = yt({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: oe,
    ariaAutoComplete: null,
    ariaBusy: oe,
    ariaChecked: oe,
    ariaColCount: w,
    ariaColIndex: w,
    ariaColSpan: w,
    ariaControls: ue,
    ariaCurrent: null,
    ariaDescribedBy: ue,
    ariaDetails: null,
    ariaDisabled: oe,
    ariaDropEffect: ue,
    ariaErrorMessage: null,
    ariaExpanded: oe,
    ariaFlowTo: ue,
    ariaGrabbed: oe,
    ariaHasPopup: null,
    ariaHidden: oe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: ue,
    ariaLevel: w,
    ariaLive: null,
    ariaModal: oe,
    ariaMultiLine: oe,
    ariaMultiSelectable: oe,
    ariaOrientation: null,
    ariaOwns: ue,
    ariaPlaceholder: null,
    ariaPosInSet: w,
    ariaPressed: oe,
    ariaReadOnly: oe,
    ariaRelevant: null,
    ariaRequired: oe,
    ariaRoleDescription: ue,
    ariaRowCount: w,
    ariaRowIndex: w,
    ariaRowSpan: w,
    ariaSelected: oe,
    ariaSetSize: w,
    ariaSort: null,
    ariaValueMax: w,
    ariaValueMin: w,
    ariaValueNow: w,
    ariaValueText: null,
    role: null
  },
  transform(e2, t2) {
    return t2 === "role" ? t2 : "aria-" + t2.slice(4).toLowerCase();
  }
});
function Cs(e2, t2) {
  return t2 in e2 ? e2[t2] : t2;
}
function Ss(e2, t2) {
  return Cs(e2, t2.toLowerCase());
}
var Em = yt({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: gt,
    acceptCharset: ue,
    accessKey: ue,
    action: null,
    allow: null,
    allowFullScreen: G,
    allowPaymentRequest: G,
    allowUserMedia: G,
    alt: null,
    as: null,
    async: G,
    autoCapitalize: null,
    autoComplete: ue,
    autoFocus: G,
    autoPlay: G,
    blocking: ue,
    capture: null,
    charSet: null,
    checked: G,
    cite: null,
    className: ue,
    cols: w,
    colSpan: null,
    content: null,
    contentEditable: oe,
    controls: G,
    controlsList: ue,
    coords: w | gt,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: G,
    defer: G,
    dir: null,
    dirName: null,
    disabled: G,
    download: As,
    draggable: oe,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: G,
    formTarget: null,
    headers: ue,
    height: w,
    hidden: G,
    high: w,
    href: null,
    hrefLang: null,
    htmlFor: ue,
    httpEquiv: ue,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: G,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: G,
    itemId: null,
    itemProp: ue,
    itemRef: ue,
    itemScope: G,
    itemType: ue,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: G,
    low: w,
    manifest: null,
    max: null,
    maxLength: w,
    media: null,
    method: null,
    min: null,
    minLength: w,
    multiple: G,
    muted: G,
    name: null,
    nonce: null,
    noModule: G,
    noValidate: G,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: G,
    optimum: w,
    pattern: null,
    ping: ue,
    placeholder: null,
    playsInline: G,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: G,
    referrerPolicy: null,
    rel: ue,
    required: G,
    reversed: G,
    rows: w,
    rowSpan: w,
    sandbox: ue,
    scope: null,
    scoped: G,
    seamless: G,
    selected: G,
    shadowRootClonable: G,
    shadowRootDelegatesFocus: G,
    shadowRootMode: null,
    shape: null,
    size: w,
    sizes: null,
    slot: null,
    span: w,
    spellCheck: oe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: w,
    step: null,
    style: null,
    tabIndex: w,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: G,
    useMap: null,
    value: oe,
    width: w,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: ue,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: w,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: w,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: G,
    // Lists. Use CSS to reduce space between items instead
    declare: G,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: w,
    // `<img>` and `<object>`
    leftMargin: w,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: w,
    // `<body>`
    marginWidth: w,
    // `<body>`
    noResize: G,
    // `<frame>`
    noHref: G,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: G,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: G,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: w,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: oe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: w,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: w,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: G,
    disableRemotePlayback: G,
    prefix: null,
    property: null,
    results: w,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Ss
});
var gm = yt({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Se,
    accentHeight: w,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: w,
    amplitude: w,
    arabicForm: null,
    ascent: w,
    attributeName: null,
    attributeType: null,
    azimuth: w,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: w,
    by: null,
    calcMode: null,
    capHeight: w,
    className: ue,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: w,
    diffuseConstant: w,
    direction: null,
    display: null,
    dur: null,
    divisor: w,
    dominantBaseline: null,
    download: G,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: w,
    enableBackground: null,
    end: null,
    event: null,
    exponent: w,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: w,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: gt,
    g2: gt,
    glyphName: gt,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: w,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: w,
    horizOriginX: w,
    horizOriginY: w,
    id: null,
    ideographic: w,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: w,
    k: w,
    k1: w,
    k2: w,
    k3: w,
    k4: w,
    kernelMatrix: Se,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: w,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: w,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: w,
    overlineThickness: w,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: w,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: ue,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: w,
    pointsAtY: w,
    pointsAtZ: w,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Se,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Se,
    rev: Se,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Se,
    requiredFeatures: Se,
    requiredFonts: Se,
    requiredFormats: Se,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: w,
    specularExponent: w,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: w,
    strikethroughThickness: w,
    string: null,
    stroke: null,
    strokeDashArray: Se,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: w,
    strokeOpacity: w,
    strokeWidth: null,
    style: null,
    surfaceScale: w,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Se,
    tabIndex: w,
    tableValues: null,
    target: null,
    targetX: w,
    targetY: w,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Se,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: w,
    underlineThickness: w,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: w,
    values: null,
    vAlphabetic: w,
    vMathematical: w,
    vectorEffect: null,
    vHanging: w,
    vIdeographic: w,
    version: null,
    vertAdvY: w,
    vertOriginX: w,
    vertOriginY: w,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: w,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Cs
});
var xs = yt({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e2, t2) {
    return "xlink:" + t2.slice(5).toLowerCase();
  }
});
var Is = yt({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Ss
});
var ks = yt({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e2, t2) {
    return "xml:" + t2.slice(3).toLowerCase();
  }
});
var Tm = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
var bm = /[A-Z]/g;
var ai = /-[a-z]/g;
var Am = /^data[-\w.:]+$/i;
function _m(e2, t2) {
  const n = _r(t2);
  let r2 = t2, u = Ae;
  if (n in e2.normal)
    return e2.property[e2.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Am.test(t2)) {
    if (t2.charAt(4) === "-") {
      const a = t2.slice(5).replace(ai, Sm);
      r2 = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t2.slice(4);
      if (!ai.test(a)) {
        let i = a.replace(bm, Cm);
        i.charAt(0) !== "-" && (i = "-" + i), t2 = "data" + i;
      }
    }
    u = Gr;
  }
  return new u(r2, t2);
}
function Cm(e2) {
  return "-" + e2.toLowerCase();
}
function Sm(e2) {
  return e2.charAt(1).toUpperCase();
}
var xm = bs([_s, Em, xs, Is, ks], "html");
var Qr = bs([_s, gm, xs, Is, ks], "svg");
var ht = {};
var Jn;
var si;
function Im() {
  if (si) return Jn;
  si = 1;
  var e2 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t2 = /\n/g, n = /^\s*/, r2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, u = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, i = /^[;\s]*/, o = /^\s+|\s+$/g, l3 = `
`, c = "/", h = "*", f2 = "", p2 = "comment", d = "declaration";
  Jn = function(C, y2) {
    if (typeof C != "string")
      throw new TypeError("First argument must be a string");
    if (!C) return [];
    y2 = y2 || {};
    var S = 1, O = 1;
    function L(v) {
      var F = v.match(t2);
      F && (S += F.length);
      var j2 = v.lastIndexOf(l3);
      O = ~j2 ? v.length - j2 : O + v.length;
    }
    function Y() {
      var v = { line: S, column: O };
      return function(F) {
        return F.position = new q(v), Z(), F;
      };
    }
    function q(v) {
      this.start = v, this.end = { line: S, column: O }, this.source = y2.source;
    }
    q.prototype.content = C;
    function k(v) {
      var F = new Error(
        y2.source + ":" + S + ":" + O + ": " + v
      );
      if (F.reason = v, F.filename = y2.source, F.line = S, F.column = O, F.source = C, !y2.silent) throw F;
    }
    function Q(v) {
      var F = v.exec(C);
      if (F) {
        var j2 = F[0];
        return L(j2), C = C.slice(j2.length), F;
      }
    }
    function Z() {
      Q(n);
    }
    function ee(v) {
      var F;
      for (v = v || []; F = I(); )
        F !== false && v.push(F);
      return v;
    }
    function I() {
      var v = Y();
      if (!(c != C.charAt(0) || h != C.charAt(1))) {
        for (var F = 2; f2 != C.charAt(F) && (h != C.charAt(F) || c != C.charAt(F + 1)); )
          ++F;
        if (F += 2, f2 === C.charAt(F - 1))
          return k("End of comment missing");
        var j2 = C.slice(2, F - 2);
        return O += 2, L(j2), C = C.slice(F), O += 2, v({
          type: p2,
          comment: j2
        });
      }
    }
    function H() {
      var v = Y(), F = Q(r2);
      if (F) {
        if (I(), !Q(u)) return k("property missing ':'");
        var j2 = Q(a), le = v({
          type: d,
          property: A(F[0].replace(e2, f2)),
          value: j2 ? A(j2[0].replace(e2, f2)) : f2
        });
        return Q(i), le;
      }
    }
    function U() {
      var v = [];
      ee(v);
      for (var F; F = H(); )
        F !== false && (v.push(F), ee(v));
      return v;
    }
    return Z(), U();
  };
  function A(C) {
    return C ? C.replace(o, f2) : f2;
  }
  return Jn;
}
var oi;
function km() {
  if (oi) return ht;
  oi = 1;
  var e2 = ht && ht.__importDefault || function(r2) {
    return r2 && r2.__esModule ? r2 : { default: r2 };
  };
  Object.defineProperty(ht, "__esModule", { value: true }), ht.default = n;
  var t2 = e2(Im());
  function n(r2, u) {
    var a = null;
    if (!r2 || typeof r2 != "string")
      return a;
    var i = (0, t2.default)(r2), o = typeof u == "function";
    return i.forEach(function(l3) {
      if (l3.type === "declaration") {
        var c = l3.property, h = l3.value;
        o ? u(c, h, l3) : h && (a = a || {}, a[c] = h);
      }
    }), a;
  }
  return ht;
}
var Mt = {};
var li;
function ym() {
  if (li) return Mt;
  li = 1, Object.defineProperty(Mt, "__esModule", { value: true }), Mt.camelCase = void 0;
  var e2 = /^--[a-zA-Z0-9_-]+$/, t2 = /-([a-z])/g, n = /^[^-]+$/, r2 = /^-(webkit|moz|ms|o|khtml)-/, u = /^-(ms)-/, a = function(c) {
    return !c || n.test(c) || e2.test(c);
  }, i = function(c, h) {
    return h.toUpperCase();
  }, o = function(c, h) {
    return "".concat(h, "-");
  }, l3 = function(c, h) {
    return h === void 0 && (h = {}), a(c) ? c : (c = c.toLowerCase(), h.reactCompat ? c = c.replace(u, o) : c = c.replace(r2, o), c.replace(t2, i));
  };
  return Mt.camelCase = l3, Mt;
}
var Bt2;
var ci;
function Nm() {
  if (ci) return Bt2;
  ci = 1;
  var e2 = Bt2 && Bt2.__importDefault || function(u) {
    return u && u.__esModule ? u : { default: u };
  }, t2 = e2(km()), n = ym();
  function r2(u, a) {
    var i = {};
    return !u || typeof u != "string" || (0, t2.default)(u, function(o, l3) {
      o && l3 && (i[(0, n.camelCase)(o, a)] = l3);
    }), i;
  }
  return r2.default = r2, Bt2 = r2, Bt2;
}
var Om = Nm();
var Lm = f(Om);
function Gt(e2) {
  return !e2 || typeof e2 != "object" ? "" : "position" in e2 || "type" in e2 ? fi(e2.position) : "start" in e2 || "end" in e2 ? fi(e2) : "line" in e2 || "column" in e2 ? Sr(e2) : "";
}
function Sr(e2) {
  return hi(e2 && e2.line) + ":" + hi(e2 && e2.column);
}
function fi(e2) {
  return Sr(e2 && e2.start) + "-" + Sr(e2 && e2.end);
}
function hi(e2) {
  return e2 && typeof e2 == "number" ? e2 : 1;
}
var Ee = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t2, n, r2) {
    super(), typeof n == "string" && (r2 = n, n = void 0);
    let u = "", a = {}, i = false;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t2 == "string" ? u = t2 : !a.cause && t2 && (i = true, u = t2.message, a.cause = t2), !a.ruleId && !a.source && typeof r2 == "string") {
      const l3 = r2.indexOf(":");
      l3 === -1 ? a.ruleId = r2 : (a.source = r2.slice(0, l3), a.ruleId = r2.slice(l3 + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const l3 = a.ancestors[a.ancestors.length - 1];
      l3 && (a.place = l3.position);
    }
    const o = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = u, this.line = o ? o.line : void 0, this.name = Gt(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = i && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
};
Ee.prototype.file = "";
Ee.prototype.name = "";
Ee.prototype.reason = "";
Ee.prototype.message = "";
Ee.prototype.stack = "";
Ee.prototype.column = void 0;
Ee.prototype.line = void 0;
Ee.prototype.ancestors = void 0;
Ee.prototype.cause = void 0;
Ee.prototype.fatal = void 0;
Ee.prototype.place = void 0;
Ee.prototype.ruleId = void 0;
Ee.prototype.source = void 0;
var $r = {}.hasOwnProperty;
var Rm = /* @__PURE__ */ new Map();
var Dm = /[A-Z]/g;
var Pm = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
var wm = /* @__PURE__ */ new Set(["td", "th"]);
var ys = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Mm(e2, t2) {
  if (!t2 || t2.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t2.filePath || void 0;
  let r2;
  if (t2.development) {
    if (typeof t2.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r2 = qm(n, t2.jsxDEV);
  } else {
    if (typeof t2.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t2.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r2 = Ym(n, t2.jsx, t2.jsxs);
  }
  const u = {
    Fragment: t2.Fragment,
    ancestors: [],
    components: t2.components || {},
    create: r2,
    elementAttributeNameCase: t2.elementAttributeNameCase || "react",
    evaluater: t2.createEvaluater ? t2.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t2.ignoreInvalidStyle || false,
    passKeys: t2.passKeys !== false,
    passNode: t2.passNode || false,
    schema: t2.space === "svg" ? Qr : xm,
    stylePropertyNameCase: t2.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t2.tableCellAlignToStyle !== false
  }, a = Ns(u, e2, void 0);
  return a && typeof a != "string" ? a : u.create(
    e2,
    u.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function Ns(e2, t2, n) {
  if (t2.type === "element")
    return Bm(e2, t2, n);
  if (t2.type === "mdxFlowExpression" || t2.type === "mdxTextExpression")
    return Fm(e2, t2);
  if (t2.type === "mdxJsxFlowElement" || t2.type === "mdxJsxTextElement")
    return Um(e2, t2, n);
  if (t2.type === "mdxjsEsm")
    return Hm(e2, t2);
  if (t2.type === "root")
    return vm(e2, t2, n);
  if (t2.type === "text")
    return zm(e2, t2);
}
function Bm(e2, t2, n) {
  const r2 = e2.schema;
  let u = r2;
  t2.tagName.toLowerCase() === "svg" && r2.space === "html" && (u = Qr, e2.schema = u), e2.ancestors.push(t2);
  const a = Ls(e2, t2.tagName, false), i = jm(e2, t2);
  let o = Kr(e2, t2);
  return Pm.has(t2.tagName) && (o = o.filter(function(l3) {
    return typeof l3 == "string" ? !mm(l3) : true;
  })), Os(e2, i, a, t2), Xr(i, o), e2.ancestors.pop(), e2.schema = r2, e2.create(t2, a, i, n);
}
function Fm(e2, t2) {
  if (t2.data && t2.data.estree && e2.evaluater) {
    const r2 = t2.data.estree.body[0];
    return r2.type, /** @type {Child | undefined} */
    e2.evaluater.evaluateExpression(r2.expression);
  }
  Jt(e2, t2.position);
}
function Hm(e2, t2) {
  if (t2.data && t2.data.estree && e2.evaluater)
    return (
      /** @type {Child | undefined} */
      e2.evaluater.evaluateProgram(t2.data.estree)
    );
  Jt(e2, t2.position);
}
function Um(e2, t2, n) {
  const r2 = e2.schema;
  let u = r2;
  t2.name === "svg" && r2.space === "html" && (u = Qr, e2.schema = u), e2.ancestors.push(t2);
  const a = t2.name === null ? e2.Fragment : Ls(e2, t2.name, true), i = Vm(e2, t2), o = Kr(e2, t2);
  return Os(e2, i, a, t2), Xr(i, o), e2.ancestors.pop(), e2.schema = r2, e2.create(t2, a, i, n);
}
function vm(e2, t2, n) {
  const r2 = {};
  return Xr(r2, Kr(e2, t2)), e2.create(t2, e2.Fragment, r2, n);
}
function zm(e2, t2) {
  return t2.value;
}
function Os(e2, t2, n, r2) {
  typeof n != "string" && n !== e2.Fragment && e2.passNode && (t2.node = r2);
}
function Xr(e2, t2) {
  if (t2.length > 0) {
    const n = t2.length > 1 ? t2 : t2[0];
    n && (e2.children = n);
  }
}
function Ym(e2, t2, n) {
  return r2;
  function r2(u, a, i, o) {
    const c = Array.isArray(i.children) ? n : t2;
    return o ? c(a, i, o) : c(a, i);
  }
}
function qm(e2, t2) {
  return n;
  function n(r2, u, a, i) {
    const o = Array.isArray(a.children), l3 = Me(r2);
    return t2(
      u,
      a,
      i,
      o,
      {
        columnNumber: l3 ? l3.column - 1 : void 0,
        fileName: e2,
        lineNumber: l3 ? l3.line : void 0
      },
      void 0
    );
  }
}
function jm(e2, t2) {
  const n = {};
  let r2, u;
  for (u in t2.properties)
    if (u !== "children" && $r.call(t2.properties, u)) {
      const a = Wm(e2, u, t2.properties[u]);
      if (a) {
        const [i, o] = a;
        e2.tableCellAlignToStyle && i === "align" && typeof o == "string" && wm.has(t2.tagName) ? r2 = o : n[i] = o;
      }
    }
  if (r2) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e2.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r2;
  }
  return n;
}
function Vm(e2, t2) {
  const n = {};
  for (const r2 of t2.attributes)
    if (r2.type === "mdxJsxExpressionAttribute")
      if (r2.data && r2.data.estree && e2.evaluater) {
        const a = r2.data.estree.body[0];
        a.type;
        const i = a.expression;
        i.type;
        const o = i.properties[0];
        o.type, Object.assign(
          n,
          e2.evaluater.evaluateExpression(o.argument)
        );
      } else
        Jt(e2, t2.position);
    else {
      const u = r2.name;
      let a;
      if (r2.value && typeof r2.value == "object")
        if (r2.value.data && r2.value.data.estree && e2.evaluater) {
          const o = r2.value.data.estree.body[0];
          o.type, a = e2.evaluater.evaluateExpression(o.expression);
        } else
          Jt(e2, t2.position);
      else
        a = r2.value === null ? true : r2.value;
      n[u] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function Kr(e2, t2) {
  const n = [];
  let r2 = -1;
  const u = e2.passKeys ? /* @__PURE__ */ new Map() : Rm;
  for (; ++r2 < t2.children.length; ) {
    const a = t2.children[r2];
    let i;
    if (e2.passKeys) {
      const l3 = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (l3) {
        const c = u.get(l3) || 0;
        i = l3 + "-" + c, u.set(l3, c + 1);
      }
    }
    const o = Ns(e2, a, i);
    o !== void 0 && n.push(o);
  }
  return n;
}
function Wm(e2, t2, n) {
  const r2 = _m(e2.schema, t2);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r2.commaSeparated ? Zi(n) : ea(n)), r2.property === "style") {
      let u = typeof n == "object" ? n : Gm(e2, String(n));
      return e2.stylePropertyNameCase === "css" && (u = Qm(u)), ["style", u];
    }
    return [
      e2.elementAttributeNameCase === "react" && r2.space ? Tm[r2.property] || r2.property : r2.attribute,
      n
    ];
  }
}
function Gm(e2, t2) {
  try {
    return Lm(t2, { reactCompat: true });
  } catch (n) {
    if (e2.ignoreInvalidStyle)
      return {};
    const r2 = (
      /** @type {Error} */
      n
    ), u = new Ee("Cannot parse `style` attribute", {
      ancestors: e2.ancestors,
      cause: r2,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw u.file = e2.filePath || void 0, u.url = ys + "#cannot-parse-style-attribute", u;
  }
}
function Ls(e2, t2, n) {
  let r2;
  if (!n)
    r2 = { type: "Literal", value: t2 };
  else if (t2.includes(".")) {
    const u = t2.split(".");
    let a = -1, i;
    for (; ++a < u.length; ) {
      const o = ri(u[a]) ? { type: "Identifier", name: u[a] } : { type: "Literal", value: u[a] };
      i = i ? {
        type: "MemberExpression",
        object: i,
        property: o,
        computed: !!(a && o.type === "Literal"),
        optional: false
      } : o;
    }
    r2 = i;
  } else
    r2 = ri(t2) && !/^[a-z]/.test(t2) ? { type: "Identifier", name: t2 } : { type: "Literal", value: t2 };
  if (r2.type === "Literal") {
    const u = (
      /** @type {string | number} */
      r2.value
    );
    return $r.call(e2.components, u) ? e2.components[u] : u;
  }
  if (e2.evaluater)
    return e2.evaluater.evaluateExpression(r2);
  Jt(e2);
}
function Jt(e2, t2) {
  const n = new Ee(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e2.ancestors,
      place: t2,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e2.filePath || void 0, n.url = ys + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Qm(e2) {
  const t2 = {};
  let n;
  for (n in e2)
    $r.call(e2, n) && (t2[$m(n)] = e2[n]);
  return t2;
}
function $m(e2) {
  let t2 = e2.replace(Dm, Xm);
  return t2.slice(0, 3) === "ms-" && (t2 = "-" + t2), t2;
}
function Xm(e2) {
  return "-" + e2.toLowerCase();
}
var Zn = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
var di = typeof document < "u" && document.createElement("i");
function Jr(e2) {
  const t2 = "&" + e2 + ";";
  di.innerHTML = t2;
  const n = di.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e2 !== "semi" || n === t2 ? false : n;
}
function we(e2, t2, n, r2) {
  const u = e2.length;
  let a = 0, i;
  if (t2 < 0 ? t2 = -t2 > u ? 0 : u + t2 : t2 = t2 > u ? u : t2, n = n > 0 ? n : 0, r2.length < 1e4)
    i = Array.from(r2), i.unshift(t2, n), e2.splice(...i);
  else
    for (n && e2.splice(t2, n); a < r2.length; )
      i = r2.slice(a, a + 1e4), i.unshift(t2, 0), e2.splice(...i), a += 1e4, t2 += 1e4;
}
function Ie(e2, t2) {
  return e2.length > 0 ? (we(e2, e2.length, 0, t2), e2) : t2;
}
var mi = {}.hasOwnProperty;
function Km(e2) {
  const t2 = {};
  let n = -1;
  for (; ++n < e2.length; )
    Jm(t2, e2[n]);
  return t2;
}
function Jm(e2, t2) {
  let n;
  for (n in t2) {
    const u = (mi.call(e2, n) ? e2[n] : void 0) || (e2[n] = {}), a = t2[n];
    let i;
    if (a)
      for (i in a) {
        mi.call(u, i) || (u[i] = []);
        const o = a[i];
        Zm(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function Zm(e2, t2) {
  let n = -1;
  const r2 = [];
  for (; ++n < t2.length; )
    (t2[n].add === "after" ? e2 : r2).push(t2[n]);
  we(e2, 0, 0, r2);
}
function Rs(e2, t2) {
  const n = Number.parseInt(e2, t2);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function Tt(e2) {
  return e2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var ep = {
  tokenize: tp
};
function tp(e2) {
  const t2 = e2.attempt(
    this.parser.constructs.contentInitial,
    r2,
    u
  );
  let n;
  return t2;
  function r2(o) {
    if (o === null) {
      e2.consume(o);
      return;
    }
    return e2.enter("lineEnding"), e2.consume(o), e2.exit("lineEnding"), J(e2, t2, "linePrefix");
  }
  function u(o) {
    return e2.enter("paragraph"), a(o);
  }
  function a(o) {
    const l3 = e2.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l3), n = l3, i(o);
  }
  function i(o) {
    if (o === null) {
      e2.exit("chunkText"), e2.exit("paragraph"), e2.consume(o);
      return;
    }
    return z(o) ? (e2.consume(o), e2.exit("chunkText"), a) : (e2.consume(o), i);
  }
}
var np = {
  tokenize: rp
};
var pi = {
  tokenize: up
};
function rp(e2) {
  const t2 = this, n = [];
  let r2 = 0, u, a, i;
  return o;
  function o(L) {
    if (r2 < n.length) {
      const Y = n[r2];
      return t2.containerState = Y[1], e2.attempt(
        Y[0].continuation,
        l3,
        c
      )(L);
    }
    return c(L);
  }
  function l3(L) {
    if (r2++, t2.containerState._closeFlow) {
      t2.containerState._closeFlow = void 0, u && O();
      const Y = t2.events.length;
      let q = Y, k;
      for (; q--; )
        if (t2.events[q][0] === "exit" && t2.events[q][1].type === "chunkFlow") {
          k = t2.events[q][1].end;
          break;
        }
      S(r2);
      let Q = Y;
      for (; Q < t2.events.length; )
        t2.events[Q][1].end = Object.assign({}, k), Q++;
      return we(
        t2.events,
        q + 1,
        0,
        t2.events.slice(Y)
      ), t2.events.length = Q, c(L);
    }
    return o(L);
  }
  function c(L) {
    if (r2 === n.length) {
      if (!u)
        return p2(L);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return A(L);
      t2.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return t2.containerState = {}, e2.check(
      pi,
      h,
      f2
    )(L);
  }
  function h(L) {
    return u && O(), S(r2), p2(L);
  }
  function f2(L) {
    return t2.parser.lazy[t2.now().line] = r2 !== n.length, i = t2.now().offset, A(L);
  }
  function p2(L) {
    return t2.containerState = {}, e2.attempt(
      pi,
      d,
      A
    )(L);
  }
  function d(L) {
    return r2++, n.push([t2.currentConstruct, t2.containerState]), p2(L);
  }
  function A(L) {
    if (L === null) {
      u && O(), S(0), e2.consume(L);
      return;
    }
    return u = u || t2.parser.flow(t2.now()), e2.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), C(L);
  }
  function C(L) {
    if (L === null) {
      y2(e2.exit("chunkFlow"), true), S(0), e2.consume(L);
      return;
    }
    return z(L) ? (e2.consume(L), y2(e2.exit("chunkFlow")), r2 = 0, t2.interrupt = void 0, o) : (e2.consume(L), C);
  }
  function y2(L, Y) {
    const q = t2.sliceStream(L);
    if (Y && q.push(null), L.previous = a, a && (a.next = L), a = L, u.defineSkip(L.start), u.write(q), t2.parser.lazy[L.start.line]) {
      let k = u.events.length;
      for (; k--; )
        if (
          // The token starts before the line ending…
          u.events[k][1].start.offset < i && // …and either is not ended yet…
          (!u.events[k][1].end || // …or ends after it.
          u.events[k][1].end.offset > i)
        )
          return;
      const Q = t2.events.length;
      let Z = Q, ee, I;
      for (; Z--; )
        if (t2.events[Z][0] === "exit" && t2.events[Z][1].type === "chunkFlow") {
          if (ee) {
            I = t2.events[Z][1].end;
            break;
          }
          ee = true;
        }
      for (S(r2), k = Q; k < t2.events.length; )
        t2.events[k][1].end = Object.assign({}, I), k++;
      we(
        t2.events,
        Z + 1,
        0,
        t2.events.slice(Q)
      ), t2.events.length = k;
    }
  }
  function S(L) {
    let Y = n.length;
    for (; Y-- > L; ) {
      const q = n[Y];
      t2.containerState = q[1], q[0].exit.call(t2, e2);
    }
    n.length = L;
  }
  function O() {
    u.write([null]), a = void 0, u = void 0, t2.containerState._closeFlow = void 0;
  }
}
function up(e2, t2, n) {
  return J(
    e2,
    e2.attempt(this.parser.constructs.document, t2, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function Zr(e2, t2, n) {
  const r2 = [];
  let u = -1;
  for (; ++u < e2.length; ) {
    const a = e2[u].resolveAll;
    a && !r2.includes(a) && (t2 = a(t2, n), r2.push(a));
  }
  return t2;
}
var xr = {
  name: "attention",
  tokenize: ap,
  resolveAll: ip
};
function ip(e2, t2) {
  let n = -1, r2, u, a, i, o, l3, c, h;
  for (; ++n < e2.length; )
    if (e2[n][0] === "enter" && e2[n][1].type === "attentionSequence" && e2[n][1]._close) {
      for (r2 = n; r2--; )
        if (e2[r2][0] === "exit" && e2[r2][1].type === "attentionSequence" && e2[r2][1]._open && // If the markers are the same:
        t2.sliceSerialize(e2[r2][1]).charCodeAt(0) === t2.sliceSerialize(e2[n][1]).charCodeAt(0)) {
          if ((e2[r2][1]._close || e2[n][1]._open) && (e2[n][1].end.offset - e2[n][1].start.offset) % 3 && !((e2[r2][1].end.offset - e2[r2][1].start.offset + e2[n][1].end.offset - e2[n][1].start.offset) % 3))
            continue;
          l3 = e2[r2][1].end.offset - e2[r2][1].start.offset > 1 && e2[n][1].end.offset - e2[n][1].start.offset > 1 ? 2 : 1;
          const f2 = Object.assign({}, e2[r2][1].end), p2 = Object.assign({}, e2[n][1].start);
          Ei(f2, -l3), Ei(p2, l3), i = {
            type: l3 > 1 ? "strongSequence" : "emphasisSequence",
            start: f2,
            end: Object.assign({}, e2[r2][1].end)
          }, o = {
            type: l3 > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e2[n][1].start),
            end: p2
          }, a = {
            type: l3 > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e2[r2][1].end),
            end: Object.assign({}, e2[n][1].start)
          }, u = {
            type: l3 > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e2[r2][1].end = Object.assign({}, i.start), e2[n][1].start = Object.assign({}, o.end), c = [], e2[r2][1].end.offset - e2[r2][1].start.offset && (c = Ie(c, [
            ["enter", e2[r2][1], t2],
            ["exit", e2[r2][1], t2]
          ])), c = Ie(c, [
            ["enter", u, t2],
            ["enter", i, t2],
            ["exit", i, t2],
            ["enter", a, t2]
          ]), c = Ie(
            c,
            Zr(
              t2.parser.constructs.insideSpan.null,
              e2.slice(r2 + 1, n),
              t2
            )
          ), c = Ie(c, [
            ["exit", a, t2],
            ["enter", o, t2],
            ["exit", o, t2],
            ["exit", u, t2]
          ]), e2[n][1].end.offset - e2[n][1].start.offset ? (h = 2, c = Ie(c, [
            ["enter", e2[n][1], t2],
            ["exit", e2[n][1], t2]
          ])) : h = 0, we(e2, r2 - 1, n - r2 + 3, c), n = r2 + c.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e2.length; )
    e2[n][1].type === "attentionSequence" && (e2[n][1].type = "data");
  return e2;
}
function ap(e2, t2) {
  const n = this.parser.constructs.attentionMarkers.null, r2 = this.previous, u = _t2(r2);
  let a;
  return i;
  function i(l3) {
    return a = l3, e2.enter("attentionSequence"), o(l3);
  }
  function o(l3) {
    if (l3 === a)
      return e2.consume(l3), o;
    const c = e2.exit("attentionSequence"), h = _t2(l3), f2 = !h || h === 2 && u || n.includes(l3), p2 = !u || u === 2 && h || n.includes(r2);
    return c._open = !!(a === 42 ? f2 : f2 && (u || !p2)), c._close = !!(a === 42 ? p2 : p2 && (h || !f2)), t2(l3);
  }
}
function Ei(e2, t2) {
  e2.column += t2, e2.offset += t2, e2._bufferIndex += t2;
}
var sp = {
  name: "autolink",
  tokenize: op
};
function op(e2, t2, n) {
  let r2 = 0;
  return u;
  function u(d) {
    return e2.enter("autolink"), e2.enter("autolinkMarker"), e2.consume(d), e2.exit("autolinkMarker"), e2.enter("autolinkProtocol"), a;
  }
  function a(d) {
    return ge(d) ? (e2.consume(d), i) : c(d);
  }
  function i(d) {
    return d === 43 || d === 45 || d === 46 || me(d) ? (r2 = 1, o(d)) : c(d);
  }
  function o(d) {
    return d === 58 ? (e2.consume(d), r2 = 0, l3) : (d === 43 || d === 45 || d === 46 || me(d)) && r2++ < 32 ? (e2.consume(d), o) : (r2 = 0, c(d));
  }
  function l3(d) {
    return d === 62 ? (e2.exit("autolinkProtocol"), e2.enter("autolinkMarker"), e2.consume(d), e2.exit("autolinkMarker"), e2.exit("autolink"), t2) : d === null || d === 32 || d === 60 || In(d) ? n(d) : (e2.consume(d), l3);
  }
  function c(d) {
    return d === 64 ? (e2.consume(d), h) : J0(d) ? (e2.consume(d), c) : n(d);
  }
  function h(d) {
    return me(d) ? f2(d) : n(d);
  }
  function f2(d) {
    return d === 46 ? (e2.consume(d), r2 = 0, h) : d === 62 ? (e2.exit("autolinkProtocol").type = "autolinkEmail", e2.enter("autolinkMarker"), e2.consume(d), e2.exit("autolinkMarker"), e2.exit("autolink"), t2) : p2(d);
  }
  function p2(d) {
    if ((d === 45 || me(d)) && r2++ < 63) {
      const A = d === 45 ? p2 : f2;
      return e2.consume(d), A;
    }
    return n(d);
  }
}
var Un = {
  tokenize: lp,
  partial: true
};
function lp(e2, t2, n) {
  return r2;
  function r2(a) {
    return X(a) ? J(e2, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? t2(a) : n(a);
  }
}
var Ds = {
  name: "blockQuote",
  tokenize: cp,
  continuation: {
    tokenize: fp
  },
  exit: hp
};
function cp(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    if (i === 62) {
      const o = r2.containerState;
      return o.open || (e2.enter("blockQuote", {
        _container: true
      }), o.open = true), e2.enter("blockQuotePrefix"), e2.enter("blockQuoteMarker"), e2.consume(i), e2.exit("blockQuoteMarker"), a;
    }
    return n(i);
  }
  function a(i) {
    return X(i) ? (e2.enter("blockQuotePrefixWhitespace"), e2.consume(i), e2.exit("blockQuotePrefixWhitespace"), e2.exit("blockQuotePrefix"), t2) : (e2.exit("blockQuotePrefix"), t2(i));
  }
}
function fp(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return X(i) ? J(
      e2,
      a,
      "linePrefix",
      r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i) : a(i);
  }
  function a(i) {
    return e2.attempt(Ds, t2, n)(i);
  }
}
function hp(e2) {
  e2.exit("blockQuote");
}
var Ps = {
  name: "characterEscape",
  tokenize: dp
};
function dp(e2, t2, n) {
  return r2;
  function r2(a) {
    return e2.enter("characterEscape"), e2.enter("escapeMarker"), e2.consume(a), e2.exit("escapeMarker"), u;
  }
  function u(a) {
    return ef(a) ? (e2.enter("characterEscapeValue"), e2.consume(a), e2.exit("characterEscapeValue"), e2.exit("characterEscape"), t2) : n(a);
  }
}
var ws = {
  name: "characterReference",
  tokenize: mp
};
function mp(e2, t2, n) {
  const r2 = this;
  let u = 0, a, i;
  return o;
  function o(f2) {
    return e2.enter("characterReference"), e2.enter("characterReferenceMarker"), e2.consume(f2), e2.exit("characterReferenceMarker"), l3;
  }
  function l3(f2) {
    return f2 === 35 ? (e2.enter("characterReferenceMarkerNumeric"), e2.consume(f2), e2.exit("characterReferenceMarkerNumeric"), c) : (e2.enter("characterReferenceValue"), a = 31, i = me, h(f2));
  }
  function c(f2) {
    return f2 === 88 || f2 === 120 ? (e2.enter("characterReferenceMarkerHexadecimal"), e2.consume(f2), e2.exit("characterReferenceMarkerHexadecimal"), e2.enter("characterReferenceValue"), a = 6, i = Z0, h) : (e2.enter("characterReferenceValue"), a = 7, i = br, h(f2));
  }
  function h(f2) {
    if (f2 === 59 && u) {
      const p2 = e2.exit("characterReferenceValue");
      return i === me && !Jr(r2.sliceSerialize(p2)) ? n(f2) : (e2.enter("characterReferenceMarker"), e2.consume(f2), e2.exit("characterReferenceMarker"), e2.exit("characterReference"), t2);
    }
    return i(f2) && u++ < a ? (e2.consume(f2), h) : n(f2);
  }
}
var gi = {
  tokenize: Ep,
  partial: true
};
var Ti = {
  name: "codeFenced",
  tokenize: pp,
  concrete: true
};
function pp(e2, t2, n) {
  const r2 = this, u = {
    tokenize: q,
    partial: true
  };
  let a = 0, i = 0, o;
  return l3;
  function l3(k) {
    return c(k);
  }
  function c(k) {
    const Q = r2.events[r2.events.length - 1];
    return a = Q && Q[1].type === "linePrefix" ? Q[2].sliceSerialize(Q[1], true).length : 0, o = k, e2.enter("codeFenced"), e2.enter("codeFencedFence"), e2.enter("codeFencedFenceSequence"), h(k);
  }
  function h(k) {
    return k === o ? (i++, e2.consume(k), h) : i < 3 ? n(k) : (e2.exit("codeFencedFenceSequence"), X(k) ? J(e2, f2, "whitespace")(k) : f2(k));
  }
  function f2(k) {
    return k === null || z(k) ? (e2.exit("codeFencedFence"), r2.interrupt ? t2(k) : e2.check(gi, C, Y)(k)) : (e2.enter("codeFencedFenceInfo"), e2.enter("chunkString", {
      contentType: "string"
    }), p2(k));
  }
  function p2(k) {
    return k === null || z(k) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceInfo"), f2(k)) : X(k) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceInfo"), J(e2, d, "whitespace")(k)) : k === 96 && k === o ? n(k) : (e2.consume(k), p2);
  }
  function d(k) {
    return k === null || z(k) ? f2(k) : (e2.enter("codeFencedFenceMeta"), e2.enter("chunkString", {
      contentType: "string"
    }), A(k));
  }
  function A(k) {
    return k === null || z(k) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceMeta"), f2(k)) : k === 96 && k === o ? n(k) : (e2.consume(k), A);
  }
  function C(k) {
    return e2.attempt(u, Y, y2)(k);
  }
  function y2(k) {
    return e2.enter("lineEnding"), e2.consume(k), e2.exit("lineEnding"), S;
  }
  function S(k) {
    return a > 0 && X(k) ? J(
      e2,
      O,
      "linePrefix",
      a + 1
    )(k) : O(k);
  }
  function O(k) {
    return k === null || z(k) ? e2.check(gi, C, Y)(k) : (e2.enter("codeFlowValue"), L(k));
  }
  function L(k) {
    return k === null || z(k) ? (e2.exit("codeFlowValue"), O(k)) : (e2.consume(k), L);
  }
  function Y(k) {
    return e2.exit("codeFenced"), t2(k);
  }
  function q(k, Q, Z) {
    let ee = 0;
    return I;
    function I(j2) {
      return k.enter("lineEnding"), k.consume(j2), k.exit("lineEnding"), H;
    }
    function H(j2) {
      return k.enter("codeFencedFence"), X(j2) ? J(
        k,
        U,
        "linePrefix",
        r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(j2) : U(j2);
    }
    function U(j2) {
      return j2 === o ? (k.enter("codeFencedFenceSequence"), v(j2)) : Z(j2);
    }
    function v(j2) {
      return j2 === o ? (ee++, k.consume(j2), v) : ee >= i ? (k.exit("codeFencedFenceSequence"), X(j2) ? J(k, F, "whitespace")(j2) : F(j2)) : Z(j2);
    }
    function F(j2) {
      return j2 === null || z(j2) ? (k.exit("codeFencedFence"), Q(j2)) : Z(j2);
    }
  }
}
function Ep(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return i === null ? n(i) : (e2.enter("lineEnding"), e2.consume(i), e2.exit("lineEnding"), a);
  }
  function a(i) {
    return r2.parser.lazy[r2.now().line] ? n(i) : t2(i);
  }
}
var er = {
  name: "codeIndented",
  tokenize: Tp
};
var gp = {
  tokenize: bp,
  partial: true
};
function Tp(e2, t2, n) {
  const r2 = this;
  return u;
  function u(c) {
    return e2.enter("codeIndented"), J(e2, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const h = r2.events[r2.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], true).length >= 4 ? i(c) : n(c);
  }
  function i(c) {
    return c === null ? l3(c) : z(c) ? e2.attempt(gp, i, l3)(c) : (e2.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || z(c) ? (e2.exit("codeFlowValue"), i(c)) : (e2.consume(c), o);
  }
  function l3(c) {
    return e2.exit("codeIndented"), t2(c);
  }
}
function bp(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return r2.parser.lazy[r2.now().line] ? n(i) : z(i) ? (e2.enter("lineEnding"), e2.consume(i), e2.exit("lineEnding"), u) : J(e2, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const o = r2.events[r2.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], true).length >= 4 ? t2(i) : z(i) ? u(i) : n(i);
  }
}
var Ap = {
  name: "codeText",
  tokenize: Sp,
  resolve: _p,
  previous: Cp
};
function _p(e2) {
  let t2 = e2.length - 4, n = 3, r2, u;
  if ((e2[n][1].type === "lineEnding" || e2[n][1].type === "space") && (e2[t2][1].type === "lineEnding" || e2[t2][1].type === "space")) {
    for (r2 = n; ++r2 < t2; )
      if (e2[r2][1].type === "codeTextData") {
        e2[n][1].type = "codeTextPadding", e2[t2][1].type = "codeTextPadding", n += 2, t2 -= 2;
        break;
      }
  }
  for (r2 = n - 1, t2++; ++r2 <= t2; )
    u === void 0 ? r2 !== t2 && e2[r2][1].type !== "lineEnding" && (u = r2) : (r2 === t2 || e2[r2][1].type === "lineEnding") && (e2[u][1].type = "codeTextData", r2 !== u + 2 && (e2[u][1].end = e2[r2 - 1][1].end, e2.splice(u + 2, r2 - u - 2), t2 -= r2 - u - 2, r2 = u + 2), u = void 0);
  return e2;
}
function Cp(e2) {
  return e2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Sp(e2, t2, n) {
  let r2 = 0, u, a;
  return i;
  function i(f2) {
    return e2.enter("codeText"), e2.enter("codeTextSequence"), o(f2);
  }
  function o(f2) {
    return f2 === 96 ? (e2.consume(f2), r2++, o) : (e2.exit("codeTextSequence"), l3(f2));
  }
  function l3(f2) {
    return f2 === null ? n(f2) : f2 === 32 ? (e2.enter("space"), e2.consume(f2), e2.exit("space"), l3) : f2 === 96 ? (a = e2.enter("codeTextSequence"), u = 0, h(f2)) : z(f2) ? (e2.enter("lineEnding"), e2.consume(f2), e2.exit("lineEnding"), l3) : (e2.enter("codeTextData"), c(f2));
  }
  function c(f2) {
    return f2 === null || f2 === 32 || f2 === 96 || z(f2) ? (e2.exit("codeTextData"), l3(f2)) : (e2.consume(f2), c);
  }
  function h(f2) {
    return f2 === 96 ? (e2.consume(f2), u++, h) : u === r2 ? (e2.exit("codeTextSequence"), e2.exit("codeText"), t2(f2)) : (a.type = "codeTextData", c(f2));
  }
}
function Ms(e2) {
  const t2 = {};
  let n = -1, r2, u, a, i, o, l3, c;
  for (; ++n < e2.length; ) {
    for (; n in t2; )
      n = t2[n];
    if (r2 = e2[n], n && r2[1].type === "chunkFlow" && e2[n - 1][1].type === "listItemPrefix" && (l3 = r2[1]._tokenizer.events, a = 0, a < l3.length && l3[a][1].type === "lineEndingBlank" && (a += 2), a < l3.length && l3[a][1].type === "content"))
      for (; ++a < l3.length && l3[a][1].type !== "content"; )
        l3[a][1].type === "chunkText" && (l3[a][1]._isInFirstContentOfListItem = true, a++);
    if (r2[0] === "enter")
      r2[1].contentType && (Object.assign(t2, xp(e2, n)), n = t2[n], c = true);
    else if (r2[1]._container) {
      for (a = n, u = void 0; a-- && (i = e2[a], i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (e2[u][1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r2[1].end = Object.assign({}, e2[u][1].start), o = e2.slice(u, n), o.unshift(r2), we(e2, u, n - u + 1, o));
    }
  }
  return !c;
}
function xp(e2, t2) {
  const n = e2[t2][1], r2 = e2[t2][2];
  let u = t2 - 1;
  const a = [], i = n._tokenizer || r2.parser[n.contentType](n.start), o = i.events, l3 = [], c = {};
  let h, f2, p2 = -1, d = n, A = 0, C = 0;
  const y2 = [C];
  for (; d; ) {
    for (; e2[++u][1] !== d; )
      ;
    a.push(u), d._tokenizer || (h = r2.sliceStream(d), d.next || h.push(null), f2 && i.defineSkip(d.start), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = true), i.write(h), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), f2 = d, d = d.next;
  }
  for (d = n; ++p2 < o.length; )
    o[p2][0] === "exit" && o[p2 - 1][0] === "enter" && o[p2][1].type === o[p2 - 1][1].type && o[p2][1].start.line !== o[p2][1].end.line && (C = p2 + 1, y2.push(C), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (i.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : y2.pop(), p2 = y2.length; p2--; ) {
    const S = o.slice(y2[p2], y2[p2 + 1]), O = a.pop();
    l3.unshift([O, O + S.length - 1]), we(e2, O, 2, S);
  }
  for (p2 = -1; ++p2 < l3.length; )
    c[A + l3[p2][0]] = A + l3[p2][1], A += l3[p2][1] - l3[p2][0] - 1;
  return c;
}
var Ip = {
  tokenize: Np,
  resolve: yp
};
var kp = {
  tokenize: Op,
  partial: true
};
function yp(e2) {
  return Ms(e2), e2;
}
function Np(e2, t2) {
  let n;
  return r2;
  function r2(o) {
    return e2.enter("content"), n = e2.enter("chunkContent", {
      contentType: "content"
    }), u(o);
  }
  function u(o) {
    return o === null ? a(o) : z(o) ? e2.check(
      kp,
      i,
      a
    )(o) : (e2.consume(o), u);
  }
  function a(o) {
    return e2.exit("chunkContent"), e2.exit("content"), t2(o);
  }
  function i(o) {
    return e2.consume(o), e2.exit("chunkContent"), n.next = e2.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, u;
  }
}
function Op(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return e2.exit("chunkContent"), e2.enter("lineEnding"), e2.consume(i), e2.exit("lineEnding"), J(e2, a, "linePrefix");
  }
  function a(i) {
    if (i === null || z(i))
      return n(i);
    const o = r2.events[r2.events.length - 1];
    return !r2.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], true).length >= 4 ? t2(i) : e2.interrupt(r2.parser.constructs.flow, n, t2)(i);
  }
}
function Bs(e2, t2, n, r2, u, a, i, o, l3) {
  const c = l3 || Number.POSITIVE_INFINITY;
  let h = 0;
  return f2;
  function f2(S) {
    return S === 60 ? (e2.enter(r2), e2.enter(u), e2.enter(a), e2.consume(S), e2.exit(a), p2) : S === null || S === 32 || S === 41 || In(S) ? n(S) : (e2.enter(r2), e2.enter(i), e2.enter(o), e2.enter("chunkString", {
      contentType: "string"
    }), C(S));
  }
  function p2(S) {
    return S === 62 ? (e2.enter(a), e2.consume(S), e2.exit(a), e2.exit(u), e2.exit(r2), t2) : (e2.enter(o), e2.enter("chunkString", {
      contentType: "string"
    }), d(S));
  }
  function d(S) {
    return S === 62 ? (e2.exit("chunkString"), e2.exit(o), p2(S)) : S === null || S === 60 || z(S) ? n(S) : (e2.consume(S), S === 92 ? A : d);
  }
  function A(S) {
    return S === 60 || S === 62 || S === 92 ? (e2.consume(S), d) : d(S);
  }
  function C(S) {
    return !h && (S === null || S === 41 || ne(S)) ? (e2.exit("chunkString"), e2.exit(o), e2.exit(i), e2.exit(r2), t2(S)) : h < c && S === 40 ? (e2.consume(S), h++, C) : S === 41 ? (e2.consume(S), h--, C) : S === null || S === 32 || S === 40 || In(S) ? n(S) : (e2.consume(S), S === 92 ? y2 : C);
  }
  function y2(S) {
    return S === 40 || S === 41 || S === 92 ? (e2.consume(S), C) : C(S);
  }
}
function Fs(e2, t2, n, r2, u, a) {
  const i = this;
  let o = 0, l3;
  return c;
  function c(d) {
    return e2.enter(r2), e2.enter(u), e2.consume(d), e2.exit(u), e2.enter(a), h;
  }
  function h(d) {
    return o > 999 || d === null || d === 91 || d === 93 && !l3 || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? n(d) : d === 93 ? (e2.exit(a), e2.enter(u), e2.consume(d), e2.exit(u), e2.exit(r2), t2) : z(d) ? (e2.enter("lineEnding"), e2.consume(d), e2.exit("lineEnding"), h) : (e2.enter("chunkString", {
      contentType: "string"
    }), f2(d));
  }
  function f2(d) {
    return d === null || d === 91 || d === 93 || z(d) || o++ > 999 ? (e2.exit("chunkString"), h(d)) : (e2.consume(d), l3 || (l3 = !X(d)), d === 92 ? p2 : f2);
  }
  function p2(d) {
    return d === 91 || d === 92 || d === 93 ? (e2.consume(d), o++, f2) : f2(d);
  }
}
function Hs(e2, t2, n, r2, u, a) {
  let i;
  return o;
  function o(p2) {
    return p2 === 34 || p2 === 39 || p2 === 40 ? (e2.enter(r2), e2.enter(u), e2.consume(p2), e2.exit(u), i = p2 === 40 ? 41 : p2, l3) : n(p2);
  }
  function l3(p2) {
    return p2 === i ? (e2.enter(u), e2.consume(p2), e2.exit(u), e2.exit(r2), t2) : (e2.enter(a), c(p2));
  }
  function c(p2) {
    return p2 === i ? (e2.exit(a), l3(i)) : p2 === null ? n(p2) : z(p2) ? (e2.enter("lineEnding"), e2.consume(p2), e2.exit("lineEnding"), J(e2, c, "linePrefix")) : (e2.enter("chunkString", {
      contentType: "string"
    }), h(p2));
  }
  function h(p2) {
    return p2 === i || p2 === null || z(p2) ? (e2.exit("chunkString"), c(p2)) : (e2.consume(p2), p2 === 92 ? f2 : h);
  }
  function f2(p2) {
    return p2 === i || p2 === 92 ? (e2.consume(p2), h) : h(p2);
  }
}
var Lp = {
  name: "definition",
  tokenize: Dp
};
var Rp = {
  tokenize: Pp,
  partial: true
};
function Dp(e2, t2, n) {
  const r2 = this;
  let u;
  return a;
  function a(d) {
    return e2.enter("definition"), i(d);
  }
  function i(d) {
    return Fs.call(
      r2,
      e2,
      o,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function o(d) {
    return u = Tt(
      r2.sliceSerialize(r2.events[r2.events.length - 1][1]).slice(1, -1)
    ), d === 58 ? (e2.enter("definitionMarker"), e2.consume(d), e2.exit("definitionMarker"), l3) : n(d);
  }
  function l3(d) {
    return ne(d) ? Wt(e2, c)(d) : c(d);
  }
  function c(d) {
    return Bs(
      e2,
      h,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function h(d) {
    return e2.attempt(Rp, f2, f2)(d);
  }
  function f2(d) {
    return X(d) ? J(e2, p2, "whitespace")(d) : p2(d);
  }
  function p2(d) {
    return d === null || z(d) ? (e2.exit("definition"), r2.parser.defined.push(u), t2(d)) : n(d);
  }
}
function Pp(e2, t2, n) {
  return r2;
  function r2(o) {
    return ne(o) ? Wt(e2, u)(o) : n(o);
  }
  function u(o) {
    return Hs(
      e2,
      a,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function a(o) {
    return X(o) ? J(e2, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || z(o) ? t2(o) : n(o);
  }
}
var wp = {
  name: "hardBreakEscape",
  tokenize: Mp
};
function Mp(e2, t2, n) {
  return r2;
  function r2(a) {
    return e2.enter("hardBreakEscape"), e2.consume(a), u;
  }
  function u(a) {
    return z(a) ? (e2.exit("hardBreakEscape"), t2(a)) : n(a);
  }
}
var Bp = {
  name: "headingAtx",
  tokenize: Hp,
  resolve: Fp
};
function Fp(e2, t2) {
  let n = e2.length - 2, r2 = 3, u, a;
  return e2[r2][1].type === "whitespace" && (r2 += 2), n - 2 > r2 && e2[n][1].type === "whitespace" && (n -= 2), e2[n][1].type === "atxHeadingSequence" && (r2 === n - 1 || n - 4 > r2 && e2[n - 2][1].type === "whitespace") && (n -= r2 + 1 === n ? 2 : 4), n > r2 && (u = {
    type: "atxHeadingText",
    start: e2[r2][1].start,
    end: e2[n][1].end
  }, a = {
    type: "chunkText",
    start: e2[r2][1].start,
    end: e2[n][1].end,
    contentType: "text"
  }, we(e2, r2, n - r2 + 1, [
    ["enter", u, t2],
    ["enter", a, t2],
    ["exit", a, t2],
    ["exit", u, t2]
  ])), e2;
}
function Hp(e2, t2, n) {
  let r2 = 0;
  return u;
  function u(h) {
    return e2.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e2.enter("atxHeadingSequence"), i(h);
  }
  function i(h) {
    return h === 35 && r2++ < 6 ? (e2.consume(h), i) : h === null || ne(h) ? (e2.exit("atxHeadingSequence"), o(h)) : n(h);
  }
  function o(h) {
    return h === 35 ? (e2.enter("atxHeadingSequence"), l3(h)) : h === null || z(h) ? (e2.exit("atxHeading"), t2(h)) : X(h) ? J(e2, o, "whitespace")(h) : (e2.enter("atxHeadingText"), c(h));
  }
  function l3(h) {
    return h === 35 ? (e2.consume(h), l3) : (e2.exit("atxHeadingSequence"), o(h));
  }
  function c(h) {
    return h === null || h === 35 || ne(h) ? (e2.exit("atxHeadingText"), o(h)) : (e2.consume(h), c);
  }
}
var Up = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var bi = ["pre", "script", "style", "textarea"];
var vp = {
  name: "htmlFlow",
  tokenize: jp,
  resolveTo: qp,
  concrete: true
};
var zp = {
  tokenize: Wp,
  partial: true
};
var Yp = {
  tokenize: Vp,
  partial: true
};
function qp(e2) {
  let t2 = e2.length;
  for (; t2-- && !(e2[t2][0] === "enter" && e2[t2][1].type === "htmlFlow"); )
    ;
  return t2 > 1 && e2[t2 - 2][1].type === "linePrefix" && (e2[t2][1].start = e2[t2 - 2][1].start, e2[t2 + 1][1].start = e2[t2 - 2][1].start, e2.splice(t2 - 2, 2)), e2;
}
function jp(e2, t2, n) {
  const r2 = this;
  let u, a, i, o, l3;
  return c;
  function c(b) {
    return h(b);
  }
  function h(b) {
    return e2.enter("htmlFlow"), e2.enter("htmlFlowData"), e2.consume(b), f2;
  }
  function f2(b) {
    return b === 33 ? (e2.consume(b), p2) : b === 47 ? (e2.consume(b), a = true, C) : b === 63 ? (e2.consume(b), u = 3, r2.interrupt ? t2 : T) : ge(b) ? (e2.consume(b), i = String.fromCharCode(b), y2) : n(b);
  }
  function p2(b) {
    return b === 45 ? (e2.consume(b), u = 2, d) : b === 91 ? (e2.consume(b), u = 5, o = 0, A) : ge(b) ? (e2.consume(b), u = 4, r2.interrupt ? t2 : T) : n(b);
  }
  function d(b) {
    return b === 45 ? (e2.consume(b), r2.interrupt ? t2 : T) : n(b);
  }
  function A(b) {
    const Oe = "CDATA[";
    return b === Oe.charCodeAt(o++) ? (e2.consume(b), o === Oe.length ? r2.interrupt ? t2 : U : A) : n(b);
  }
  function C(b) {
    return ge(b) ? (e2.consume(b), i = String.fromCharCode(b), y2) : n(b);
  }
  function y2(b) {
    if (b === null || b === 47 || b === 62 || ne(b)) {
      const Oe = b === 47, Xe = i.toLowerCase();
      return !Oe && !a && bi.includes(Xe) ? (u = 1, r2.interrupt ? t2(b) : U(b)) : Up.includes(i.toLowerCase()) ? (u = 6, Oe ? (e2.consume(b), S) : r2.interrupt ? t2(b) : U(b)) : (u = 7, r2.interrupt && !r2.parser.lazy[r2.now().line] ? n(b) : a ? O(b) : L(b));
    }
    return b === 45 || me(b) ? (e2.consume(b), i += String.fromCharCode(b), y2) : n(b);
  }
  function S(b) {
    return b === 62 ? (e2.consume(b), r2.interrupt ? t2 : U) : n(b);
  }
  function O(b) {
    return X(b) ? (e2.consume(b), O) : I(b);
  }
  function L(b) {
    return b === 47 ? (e2.consume(b), I) : b === 58 || b === 95 || ge(b) ? (e2.consume(b), Y) : X(b) ? (e2.consume(b), L) : I(b);
  }
  function Y(b) {
    return b === 45 || b === 46 || b === 58 || b === 95 || me(b) ? (e2.consume(b), Y) : q(b);
  }
  function q(b) {
    return b === 61 ? (e2.consume(b), k) : X(b) ? (e2.consume(b), q) : L(b);
  }
  function k(b) {
    return b === null || b === 60 || b === 61 || b === 62 || b === 96 ? n(b) : b === 34 || b === 39 ? (e2.consume(b), l3 = b, Q) : X(b) ? (e2.consume(b), k) : Z(b);
  }
  function Q(b) {
    return b === l3 ? (e2.consume(b), l3 = null, ee) : b === null || z(b) ? n(b) : (e2.consume(b), Q);
  }
  function Z(b) {
    return b === null || b === 34 || b === 39 || b === 47 || b === 60 || b === 61 || b === 62 || b === 96 || ne(b) ? q(b) : (e2.consume(b), Z);
  }
  function ee(b) {
    return b === 47 || b === 62 || X(b) ? L(b) : n(b);
  }
  function I(b) {
    return b === 62 ? (e2.consume(b), H) : n(b);
  }
  function H(b) {
    return b === null || z(b) ? U(b) : X(b) ? (e2.consume(b), H) : n(b);
  }
  function U(b) {
    return b === 45 && u === 2 ? (e2.consume(b), le) : b === 60 && u === 1 ? (e2.consume(b), he) : b === 62 && u === 4 ? (e2.consume(b), Ne) : b === 63 && u === 3 ? (e2.consume(b), T) : b === 93 && u === 5 ? (e2.consume(b), Fe) : z(b) && (u === 6 || u === 7) ? (e2.exit("htmlFlowData"), e2.check(
      zp,
      He,
      v
    )(b)) : b === null || z(b) ? (e2.exit("htmlFlowData"), v(b)) : (e2.consume(b), U);
  }
  function v(b) {
    return e2.check(
      Yp,
      F,
      He
    )(b);
  }
  function F(b) {
    return e2.enter("lineEnding"), e2.consume(b), e2.exit("lineEnding"), j2;
  }
  function j2(b) {
    return b === null || z(b) ? v(b) : (e2.enter("htmlFlowData"), U(b));
  }
  function le(b) {
    return b === 45 ? (e2.consume(b), T) : U(b);
  }
  function he(b) {
    return b === 47 ? (e2.consume(b), i = "", ye) : U(b);
  }
  function ye(b) {
    if (b === 62) {
      const Oe = i.toLowerCase();
      return bi.includes(Oe) ? (e2.consume(b), Ne) : U(b);
    }
    return ge(b) && i.length < 8 ? (e2.consume(b), i += String.fromCharCode(b), ye) : U(b);
  }
  function Fe(b) {
    return b === 93 ? (e2.consume(b), T) : U(b);
  }
  function T(b) {
    return b === 62 ? (e2.consume(b), Ne) : b === 45 && u === 2 ? (e2.consume(b), T) : U(b);
  }
  function Ne(b) {
    return b === null || z(b) ? (e2.exit("htmlFlowData"), He(b)) : (e2.consume(b), Ne);
  }
  function He(b) {
    return e2.exit("htmlFlow"), t2(b);
  }
}
function Vp(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return z(i) ? (e2.enter("lineEnding"), e2.consume(i), e2.exit("lineEnding"), a) : n(i);
  }
  function a(i) {
    return r2.parser.lazy[r2.now().line] ? n(i) : t2(i);
  }
}
function Wp(e2, t2, n) {
  return r2;
  function r2(u) {
    return e2.enter("lineEnding"), e2.consume(u), e2.exit("lineEnding"), e2.attempt(Un, t2, n);
  }
}
var Gp = {
  name: "htmlText",
  tokenize: Qp
};
function Qp(e2, t2, n) {
  const r2 = this;
  let u, a, i;
  return o;
  function o(T) {
    return e2.enter("htmlText"), e2.enter("htmlTextData"), e2.consume(T), l3;
  }
  function l3(T) {
    return T === 33 ? (e2.consume(T), c) : T === 47 ? (e2.consume(T), q) : T === 63 ? (e2.consume(T), L) : ge(T) ? (e2.consume(T), Z) : n(T);
  }
  function c(T) {
    return T === 45 ? (e2.consume(T), h) : T === 91 ? (e2.consume(T), a = 0, A) : ge(T) ? (e2.consume(T), O) : n(T);
  }
  function h(T) {
    return T === 45 ? (e2.consume(T), d) : n(T);
  }
  function f2(T) {
    return T === null ? n(T) : T === 45 ? (e2.consume(T), p2) : z(T) ? (i = f2, he(T)) : (e2.consume(T), f2);
  }
  function p2(T) {
    return T === 45 ? (e2.consume(T), d) : f2(T);
  }
  function d(T) {
    return T === 62 ? le(T) : T === 45 ? p2(T) : f2(T);
  }
  function A(T) {
    const Ne = "CDATA[";
    return T === Ne.charCodeAt(a++) ? (e2.consume(T), a === Ne.length ? C : A) : n(T);
  }
  function C(T) {
    return T === null ? n(T) : T === 93 ? (e2.consume(T), y2) : z(T) ? (i = C, he(T)) : (e2.consume(T), C);
  }
  function y2(T) {
    return T === 93 ? (e2.consume(T), S) : C(T);
  }
  function S(T) {
    return T === 62 ? le(T) : T === 93 ? (e2.consume(T), S) : C(T);
  }
  function O(T) {
    return T === null || T === 62 ? le(T) : z(T) ? (i = O, he(T)) : (e2.consume(T), O);
  }
  function L(T) {
    return T === null ? n(T) : T === 63 ? (e2.consume(T), Y) : z(T) ? (i = L, he(T)) : (e2.consume(T), L);
  }
  function Y(T) {
    return T === 62 ? le(T) : L(T);
  }
  function q(T) {
    return ge(T) ? (e2.consume(T), k) : n(T);
  }
  function k(T) {
    return T === 45 || me(T) ? (e2.consume(T), k) : Q(T);
  }
  function Q(T) {
    return z(T) ? (i = Q, he(T)) : X(T) ? (e2.consume(T), Q) : le(T);
  }
  function Z(T) {
    return T === 45 || me(T) ? (e2.consume(T), Z) : T === 47 || T === 62 || ne(T) ? ee(T) : n(T);
  }
  function ee(T) {
    return T === 47 ? (e2.consume(T), le) : T === 58 || T === 95 || ge(T) ? (e2.consume(T), I) : z(T) ? (i = ee, he(T)) : X(T) ? (e2.consume(T), ee) : le(T);
  }
  function I(T) {
    return T === 45 || T === 46 || T === 58 || T === 95 || me(T) ? (e2.consume(T), I) : H(T);
  }
  function H(T) {
    return T === 61 ? (e2.consume(T), U) : z(T) ? (i = H, he(T)) : X(T) ? (e2.consume(T), H) : ee(T);
  }
  function U(T) {
    return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? n(T) : T === 34 || T === 39 ? (e2.consume(T), u = T, v) : z(T) ? (i = U, he(T)) : X(T) ? (e2.consume(T), U) : (e2.consume(T), F);
  }
  function v(T) {
    return T === u ? (e2.consume(T), u = void 0, j2) : T === null ? n(T) : z(T) ? (i = v, he(T)) : (e2.consume(T), v);
  }
  function F(T) {
    return T === null || T === 34 || T === 39 || T === 60 || T === 61 || T === 96 ? n(T) : T === 47 || T === 62 || ne(T) ? ee(T) : (e2.consume(T), F);
  }
  function j2(T) {
    return T === 47 || T === 62 || ne(T) ? ee(T) : n(T);
  }
  function le(T) {
    return T === 62 ? (e2.consume(T), e2.exit("htmlTextData"), e2.exit("htmlText"), t2) : n(T);
  }
  function he(T) {
    return e2.exit("htmlTextData"), e2.enter("lineEnding"), e2.consume(T), e2.exit("lineEnding"), ye;
  }
  function ye(T) {
    return X(T) ? J(
      e2,
      Fe,
      "linePrefix",
      r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(T) : Fe(T);
  }
  function Fe(T) {
    return e2.enter("htmlTextData"), i(T);
  }
}
var eu = {
  name: "labelEnd",
  tokenize: e1,
  resolveTo: Zp,
  resolveAll: Jp
};
var $p = {
  tokenize: t1
};
var Xp = {
  tokenize: n1
};
var Kp = {
  tokenize: r1
};
function Jp(e2) {
  let t2 = -1;
  for (; ++t2 < e2.length; ) {
    const n = e2[t2][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e2.splice(t2 + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t2++);
  }
  return e2;
}
function Zp(e2, t2) {
  let n = e2.length, r2 = 0, u, a, i, o;
  for (; n--; )
    if (u = e2[n][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      e2[n][0] === "enter" && u.type === "labelLink" && (u._inactive = true);
    } else if (i) {
      if (e2[n][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = n, u.type !== "labelLink")) {
        r2 = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = n);
  const l3 = {
    type: e2[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e2[a][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e2[a][1].start),
    end: Object.assign({}, e2[i][1].end)
  }, h = {
    type: "labelText",
    start: Object.assign({}, e2[a + r2 + 2][1].end),
    end: Object.assign({}, e2[i - 2][1].start)
  };
  return o = [
    ["enter", l3, t2],
    ["enter", c, t2]
  ], o = Ie(o, e2.slice(a + 1, a + r2 + 3)), o = Ie(o, [["enter", h, t2]]), o = Ie(
    o,
    Zr(
      t2.parser.constructs.insideSpan.null,
      e2.slice(a + r2 + 4, i - 3),
      t2
    )
  ), o = Ie(o, [
    ["exit", h, t2],
    e2[i - 2],
    e2[i - 1],
    ["exit", c, t2]
  ]), o = Ie(o, e2.slice(i + 1)), o = Ie(o, [["exit", l3, t2]]), we(e2, a, e2.length, o), e2;
}
function e1(e2, t2, n) {
  const r2 = this;
  let u = r2.events.length, a, i;
  for (; u--; )
    if ((r2.events[u][1].type === "labelImage" || r2.events[u][1].type === "labelLink") && !r2.events[u][1]._balanced) {
      a = r2.events[u][1];
      break;
    }
  return o;
  function o(p2) {
    return a ? a._inactive ? f2(p2) : (i = r2.parser.defined.includes(
      Tt(
        r2.sliceSerialize({
          start: a.end,
          end: r2.now()
        })
      )
    ), e2.enter("labelEnd"), e2.enter("labelMarker"), e2.consume(p2), e2.exit("labelMarker"), e2.exit("labelEnd"), l3) : n(p2);
  }
  function l3(p2) {
    return p2 === 40 ? e2.attempt(
      $p,
      h,
      i ? h : f2
    )(p2) : p2 === 91 ? e2.attempt(
      Xp,
      h,
      i ? c : f2
    )(p2) : i ? h(p2) : f2(p2);
  }
  function c(p2) {
    return e2.attempt(
      Kp,
      h,
      f2
    )(p2);
  }
  function h(p2) {
    return t2(p2);
  }
  function f2(p2) {
    return a._balanced = true, n(p2);
  }
}
function t1(e2, t2, n) {
  return r2;
  function r2(f2) {
    return e2.enter("resource"), e2.enter("resourceMarker"), e2.consume(f2), e2.exit("resourceMarker"), u;
  }
  function u(f2) {
    return ne(f2) ? Wt(e2, a)(f2) : a(f2);
  }
  function a(f2) {
    return f2 === 41 ? h(f2) : Bs(
      e2,
      i,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(f2);
  }
  function i(f2) {
    return ne(f2) ? Wt(e2, l3)(f2) : h(f2);
  }
  function o(f2) {
    return n(f2);
  }
  function l3(f2) {
    return f2 === 34 || f2 === 39 || f2 === 40 ? Hs(
      e2,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(f2) : h(f2);
  }
  function c(f2) {
    return ne(f2) ? Wt(e2, h)(f2) : h(f2);
  }
  function h(f2) {
    return f2 === 41 ? (e2.enter("resourceMarker"), e2.consume(f2), e2.exit("resourceMarker"), e2.exit("resource"), t2) : n(f2);
  }
}
function n1(e2, t2, n) {
  const r2 = this;
  return u;
  function u(o) {
    return Fs.call(
      r2,
      e2,
      a,
      i,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function a(o) {
    return r2.parser.defined.includes(
      Tt(
        r2.sliceSerialize(r2.events[r2.events.length - 1][1]).slice(1, -1)
      )
    ) ? t2(o) : n(o);
  }
  function i(o) {
    return n(o);
  }
}
function r1(e2, t2, n) {
  return r2;
  function r2(a) {
    return e2.enter("reference"), e2.enter("referenceMarker"), e2.consume(a), e2.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (e2.enter("referenceMarker"), e2.consume(a), e2.exit("referenceMarker"), e2.exit("reference"), t2) : n(a);
  }
}
var u1 = {
  name: "labelStartImage",
  tokenize: i1,
  resolveAll: eu.resolveAll
};
function i1(e2, t2, n) {
  const r2 = this;
  return u;
  function u(o) {
    return e2.enter("labelImage"), e2.enter("labelImageMarker"), e2.consume(o), e2.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e2.enter("labelMarker"), e2.consume(o), e2.exit("labelMarker"), e2.exit("labelImage"), i) : n(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r2.parser.constructs ? n(o) : t2(o);
  }
}
var a1 = {
  name: "labelStartLink",
  tokenize: s1,
  resolveAll: eu.resolveAll
};
function s1(e2, t2, n) {
  const r2 = this;
  return u;
  function u(i) {
    return e2.enter("labelLink"), e2.enter("labelMarker"), e2.consume(i), e2.exit("labelMarker"), e2.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r2.parser.constructs ? n(i) : t2(i);
  }
}
var tr = {
  name: "lineEnding",
  tokenize: o1
};
function o1(e2, t2) {
  return n;
  function n(r2) {
    return e2.enter("lineEnding"), e2.consume(r2), e2.exit("lineEnding"), J(e2, t2, "linePrefix");
  }
}
var bn = {
  name: "thematicBreak",
  tokenize: l1
};
function l1(e2, t2, n) {
  let r2 = 0, u;
  return a;
  function a(c) {
    return e2.enter("thematicBreak"), i(c);
  }
  function i(c) {
    return u = c, o(c);
  }
  function o(c) {
    return c === u ? (e2.enter("thematicBreakSequence"), l3(c)) : r2 >= 3 && (c === null || z(c)) ? (e2.exit("thematicBreak"), t2(c)) : n(c);
  }
  function l3(c) {
    return c === u ? (e2.consume(c), r2++, l3) : (e2.exit("thematicBreakSequence"), X(c) ? J(e2, o, "whitespace")(c) : o(c));
  }
}
var be = {
  name: "list",
  tokenize: h1,
  continuation: {
    tokenize: d1
  },
  exit: p1
};
var c1 = {
  tokenize: E1,
  partial: true
};
var f1 = {
  tokenize: m1,
  partial: true
};
function h1(e2, t2, n) {
  const r2 = this, u = r2.events[r2.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], true).length : 0, i = 0;
  return o;
  function o(d) {
    const A = r2.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (A === "listUnordered" ? !r2.containerState.marker || d === r2.containerState.marker : br(d)) {
      if (r2.containerState.type || (r2.containerState.type = A, e2.enter(A, {
        _container: true
      })), A === "listUnordered")
        return e2.enter("listItemPrefix"), d === 42 || d === 45 ? e2.check(bn, n, c)(d) : c(d);
      if (!r2.interrupt || d === 49)
        return e2.enter("listItemPrefix"), e2.enter("listItemValue"), l3(d);
    }
    return n(d);
  }
  function l3(d) {
    return br(d) && ++i < 10 ? (e2.consume(d), l3) : (!r2.interrupt || i < 2) && (r2.containerState.marker ? d === r2.containerState.marker : d === 41 || d === 46) ? (e2.exit("listItemValue"), c(d)) : n(d);
  }
  function c(d) {
    return e2.enter("listItemMarker"), e2.consume(d), e2.exit("listItemMarker"), r2.containerState.marker = r2.containerState.marker || d, e2.check(
      Un,
      // Can’t be empty when interrupting.
      r2.interrupt ? n : h,
      e2.attempt(
        c1,
        p2,
        f2
      )
    );
  }
  function h(d) {
    return r2.containerState.initialBlankLine = true, a++, p2(d);
  }
  function f2(d) {
    return X(d) ? (e2.enter("listItemPrefixWhitespace"), e2.consume(d), e2.exit("listItemPrefixWhitespace"), p2) : n(d);
  }
  function p2(d) {
    return r2.containerState.size = a + r2.sliceSerialize(e2.exit("listItemPrefix"), true).length, t2(d);
  }
}
function d1(e2, t2, n) {
  const r2 = this;
  return r2.containerState._closeFlow = void 0, e2.check(Un, u, a);
  function u(o) {
    return r2.containerState.furtherBlankLines = r2.containerState.furtherBlankLines || r2.containerState.initialBlankLine, J(
      e2,
      t2,
      "listItemIndent",
      r2.containerState.size + 1
    )(o);
  }
  function a(o) {
    return r2.containerState.furtherBlankLines || !X(o) ? (r2.containerState.furtherBlankLines = void 0, r2.containerState.initialBlankLine = void 0, i(o)) : (r2.containerState.furtherBlankLines = void 0, r2.containerState.initialBlankLine = void 0, e2.attempt(f1, t2, i)(o));
  }
  function i(o) {
    return r2.containerState._closeFlow = true, r2.interrupt = void 0, J(
      e2,
      e2.attempt(be, t2, n),
      "linePrefix",
      r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function m1(e2, t2, n) {
  const r2 = this;
  return J(
    e2,
    u,
    "listItemIndent",
    r2.containerState.size + 1
  );
  function u(a) {
    const i = r2.events[r2.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], true).length === r2.containerState.size ? t2(a) : n(a);
  }
}
function p1(e2) {
  e2.exit(this.containerState.type);
}
function E1(e2, t2, n) {
  const r2 = this;
  return J(
    e2,
    u,
    "listItemPrefixWhitespace",
    r2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function u(a) {
    const i = r2.events[r2.events.length - 1];
    return !X(a) && i && i[1].type === "listItemPrefixWhitespace" ? t2(a) : n(a);
  }
}
var Ai = {
  name: "setextUnderline",
  tokenize: T1,
  resolveTo: g1
};
function g1(e2, t2) {
  let n = e2.length, r2, u, a;
  for (; n--; )
    if (e2[n][0] === "enter") {
      if (e2[n][1].type === "content") {
        r2 = n;
        break;
      }
      e2[n][1].type === "paragraph" && (u = n);
    } else
      e2[n][1].type === "content" && e2.splice(n, 1), !a && e2[n][1].type === "definition" && (a = n);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e2[u][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  };
  return e2[u][1].type = "setextHeadingText", a ? (e2.splice(u, 0, ["enter", i, t2]), e2.splice(a + 1, 0, ["exit", e2[r2][1], t2]), e2[r2][1].end = Object.assign({}, e2[a][1].end)) : e2[r2][1] = i, e2.push(["exit", i, t2]), e2;
}
function T1(e2, t2, n) {
  const r2 = this;
  let u;
  return a;
  function a(c) {
    let h = r2.events.length, f2;
    for (; h--; )
      if (r2.events[h][1].type !== "lineEnding" && r2.events[h][1].type !== "linePrefix" && r2.events[h][1].type !== "content") {
        f2 = r2.events[h][1].type === "paragraph";
        break;
      }
    return !r2.parser.lazy[r2.now().line] && (r2.interrupt || f2) ? (e2.enter("setextHeadingLine"), u = c, i(c)) : n(c);
  }
  function i(c) {
    return e2.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === u ? (e2.consume(c), o) : (e2.exit("setextHeadingLineSequence"), X(c) ? J(e2, l3, "lineSuffix")(c) : l3(c));
  }
  function l3(c) {
    return c === null || z(c) ? (e2.exit("setextHeadingLine"), t2(c)) : n(c);
  }
}
var b1 = {
  tokenize: A1
};
function A1(e2) {
  const t2 = this, n = e2.attempt(
    // Try to parse a blank line.
    Un,
    r2,
    // Try to parse initial flow (essentially, only code).
    e2.attempt(
      this.parser.constructs.flowInitial,
      u,
      J(
        e2,
        e2.attempt(
          this.parser.constructs.flow,
          u,
          e2.attempt(Ip, u)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r2(a) {
    if (a === null) {
      e2.consume(a);
      return;
    }
    return e2.enter("lineEndingBlank"), e2.consume(a), e2.exit("lineEndingBlank"), t2.currentConstruct = void 0, n;
  }
  function u(a) {
    if (a === null) {
      e2.consume(a);
      return;
    }
    return e2.enter("lineEnding"), e2.consume(a), e2.exit("lineEnding"), t2.currentConstruct = void 0, n;
  }
}
var _1 = {
  resolveAll: vs()
};
var C1 = Us("string");
var S1 = Us("text");
function Us(e2) {
  return {
    tokenize: t2,
    resolveAll: vs(
      e2 === "text" ? x1 : void 0
    )
  };
  function t2(n) {
    const r2 = this, u = this.parser.constructs[e2], a = n.attempt(u, i, o);
    return i;
    function i(h) {
      return c(h) ? a(h) : o(h);
    }
    function o(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), l3;
    }
    function l3(h) {
      return c(h) ? (n.exit("data"), a(h)) : (n.consume(h), l3);
    }
    function c(h) {
      if (h === null)
        return true;
      const f2 = u[h];
      let p2 = -1;
      if (f2)
        for (; ++p2 < f2.length; ) {
          const d = f2[p2];
          if (!d.previous || d.previous.call(r2, r2.previous))
            return true;
        }
      return false;
    }
  }
}
function vs(e2) {
  return t2;
  function t2(n, r2) {
    let u = -1, a;
    for (; ++u <= n.length; )
      a === void 0 ? n[u] && n[u][1].type === "data" && (a = u, u++) : (!n[u] || n[u][1].type !== "data") && (u !== a + 2 && (n[a][1].end = n[u - 1][1].end, n.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return e2 ? e2(n, r2) : n;
  }
}
function x1(e2, t2) {
  let n = 0;
  for (; ++n <= e2.length; )
    if ((n === e2.length || e2[n][1].type === "lineEnding") && e2[n - 1][1].type === "data") {
      const r2 = e2[n - 1][1], u = t2.sliceStream(r2);
      let a = u.length, i = -1, o = 0, l3;
      for (; a--; ) {
        const c = u[a];
        if (typeof c == "string") {
          for (i = c.length; c.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (c === -2)
          l3 = true, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e2.length || l3 || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r2.end.line,
            column: r2.end.column - o,
            offset: r2.end.offset - o,
            _index: r2.start._index + a,
            _bufferIndex: a ? i : r2.start._bufferIndex + i
          },
          end: Object.assign({}, r2.end)
        };
        r2.end = Object.assign({}, c.start), r2.start.offset === r2.end.offset ? Object.assign(r2, c) : (e2.splice(
          n,
          0,
          ["enter", c, t2],
          ["exit", c, t2]
        ), n += 2);
      }
      n++;
    }
  return e2;
}
function I1(e2, t2, n) {
  let r2 = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], o = [];
  const l3 = {
    consume: O,
    enter: L,
    exit: Y,
    attempt: Q(q),
    check: Q(k),
    interrupt: Q(k, {
      interrupt: true
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e2,
    sliceStream: d,
    sliceSerialize: p2,
    now: A,
    defineSkip: C,
    write: f2
  };
  let h = t2.tokenize.call(c, l3);
  return t2.resolveAll && a.push(t2), c;
  function f2(H) {
    return i = Ie(i, H), y2(), i[i.length - 1] !== null ? [] : (Z(t2, 0), c.events = Zr(a, c.events, c), c.events);
  }
  function p2(H, U) {
    return y1(d(H), U);
  }
  function d(H) {
    return k1(i, H);
  }
  function A() {
    const { line: H, column: U, offset: v, _index: F, _bufferIndex: j2 } = r2;
    return {
      line: H,
      column: U,
      offset: v,
      _index: F,
      _bufferIndex: j2
    };
  }
  function C(H) {
    u[H.line] = H.column, I();
  }
  function y2() {
    let H;
    for (; r2._index < i.length; ) {
      const U = i[r2._index];
      if (typeof U == "string")
        for (H = r2._index, r2._bufferIndex < 0 && (r2._bufferIndex = 0); r2._index === H && r2._bufferIndex < U.length; )
          S(U.charCodeAt(r2._bufferIndex));
      else
        S(U);
    }
  }
  function S(H) {
    h = h(H);
  }
  function O(H) {
    z(H) ? (r2.line++, r2.column = 1, r2.offset += H === -3 ? 2 : 1, I()) : H !== -1 && (r2.column++, r2.offset++), r2._bufferIndex < 0 ? r2._index++ : (r2._bufferIndex++, r2._bufferIndex === i[r2._index].length && (r2._bufferIndex = -1, r2._index++)), c.previous = H;
  }
  function L(H, U) {
    const v = U || {};
    return v.type = H, v.start = A(), c.events.push(["enter", v, c]), o.push(v), v;
  }
  function Y(H) {
    const U = o.pop();
    return U.end = A(), c.events.push(["exit", U, c]), U;
  }
  function q(H, U) {
    Z(H, U.from);
  }
  function k(H, U) {
    U.restore();
  }
  function Q(H, U) {
    return v;
    function v(F, j2, le) {
      let he, ye, Fe, T;
      return Array.isArray(F) ? He(F) : "tokenize" in F ? (
        // @ts-expect-error Looks like a construct.
        He([F])
      ) : Ne(F);
      function Ne(de) {
        return Nt;
        function Nt(qe) {
          const ot = qe !== null && de[qe], Ke = qe !== null && de.null, zn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ot) ? ot : ot ? [ot] : [],
            ...Array.isArray(Ke) ? Ke : Ke ? [Ke] : []
          ];
          return He(zn)(qe);
        }
      }
      function He(de) {
        return he = de, ye = 0, de.length === 0 ? le : b(de[ye]);
      }
      function b(de) {
        return Nt;
        function Nt(qe) {
          return T = ee(), Fe = de, de.partial || (c.currentConstruct = de), de.name && c.parser.constructs.disable.null.includes(de.name) ? Xe() : de.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            U ? Object.assign(Object.create(c), U) : c,
            l3,
            Oe,
            Xe
          )(qe);
        }
      }
      function Oe(de) {
        return H(Fe, T), j2;
      }
      function Xe(de) {
        return T.restore(), ++ye < he.length ? b(he[ye]) : le;
      }
    }
  }
  function Z(H, U) {
    H.resolveAll && !a.includes(H) && a.push(H), H.resolve && we(
      c.events,
      U,
      c.events.length - U,
      H.resolve(c.events.slice(U), c)
    ), H.resolveTo && (c.events = H.resolveTo(c.events, c));
  }
  function ee() {
    const H = A(), U = c.previous, v = c.currentConstruct, F = c.events.length, j2 = Array.from(o);
    return {
      restore: le,
      from: F
    };
    function le() {
      r2 = H, c.previous = U, c.currentConstruct = v, c.events.length = F, o = j2, I();
    }
  }
  function I() {
    r2.line in u && r2.column < 2 && (r2.column = u[r2.line], r2.offset += u[r2.line] - 1);
  }
}
function k1(e2, t2) {
  const n = t2.start._index, r2 = t2.start._bufferIndex, u = t2.end._index, a = t2.end._bufferIndex;
  let i;
  if (n === u)
    i = [e2[n].slice(r2, a)];
  else {
    if (i = e2.slice(n, u), r2 > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r2) : i.shift();
    }
    a > 0 && i.push(e2[u].slice(0, a));
  }
  return i;
}
function y1(e2, t2) {
  let n = -1;
  const r2 = [];
  let u;
  for (; ++n < e2.length; ) {
    const a = e2[n];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t2 ? " " : "	";
          break;
        }
        case -1: {
          if (!t2 && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r2.push(i);
  }
  return r2.join("");
}
var N1 = {
  42: be,
  43: be,
  45: be,
  48: be,
  49: be,
  50: be,
  51: be,
  52: be,
  53: be,
  54: be,
  55: be,
  56: be,
  57: be,
  62: Ds
};
var O1 = {
  91: Lp
};
var L1 = {
  [-2]: er,
  [-1]: er,
  32: er
};
var R1 = {
  35: Bp,
  42: bn,
  45: [Ai, bn],
  60: vp,
  61: Ai,
  95: bn,
  96: Ti,
  126: Ti
};
var D1 = {
  38: ws,
  92: Ps
};
var P1 = {
  [-5]: tr,
  [-4]: tr,
  [-3]: tr,
  33: u1,
  38: ws,
  42: xr,
  60: [sp, Gp],
  91: a1,
  92: [wp, Ps],
  93: eu,
  95: xr,
  96: Ap
};
var w1 = {
  null: [xr, _1]
};
var M1 = {
  null: [42, 95]
};
var B1 = {
  null: []
};
var F1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  attentionMarkers: M1,
  contentInitial: O1,
  disable: B1,
  document: N1,
  flow: R1,
  flowInitial: L1,
  insideSpan: w1,
  string: D1,
  text: P1
}, Symbol.toStringTag, { value: "Module" }));
function H1(e2) {
  const n = (
    /** @type {FullNormalizedExtension} */
    Km([F1, ...(e2 || {}).extensions || []])
  ), r2 = {
    defined: [],
    lazy: {},
    constructs: n,
    content: u(ep),
    document: u(np),
    flow: u(b1),
    string: u(C1),
    text: u(S1)
  };
  return r2;
  function u(a) {
    return i;
    function i(o) {
      return I1(r2, a, o);
    }
  }
}
function U1(e2) {
  for (; !Ms(e2); )
    ;
  return e2;
}
var _i = /[\0\t\n\r]/g;
function v1() {
  let e2 = 1, t2 = "", n = true, r2;
  return u;
  function u(a, i, o) {
    const l3 = [];
    let c, h, f2, p2, d;
    for (a = t2 + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), f2 = 0, t2 = "", n && (a.charCodeAt(0) === 65279 && f2++, n = void 0); f2 < a.length; ) {
      if (_i.lastIndex = f2, c = _i.exec(a), p2 = c && c.index !== void 0 ? c.index : a.length, d = a.charCodeAt(p2), !c) {
        t2 = a.slice(f2);
        break;
      }
      if (d === 10 && f2 === p2 && r2)
        l3.push(-3), r2 = void 0;
      else
        switch (r2 && (l3.push(-5), r2 = void 0), f2 < p2 && (l3.push(a.slice(f2, p2)), e2 += p2 - f2), d) {
          case 0: {
            l3.push(65533), e2++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e2 / 4) * 4, l3.push(-2); e2++ < h; ) l3.push(-1);
            break;
          }
          case 10: {
            l3.push(-4), e2 = 1;
            break;
          }
          default:
            r2 = true, e2 = 1;
        }
      f2 = p2 + 1;
    }
    return o && (r2 && l3.push(-5), t2 && l3.push(t2), l3.push(null)), l3;
  }
}
var z1 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Y1(e2) {
  return e2.replace(z1, q1);
}
function q1(e2, t2, n) {
  if (t2)
    return t2;
  if (n.charCodeAt(0) === 35) {
    const u = n.charCodeAt(1), a = u === 120 || u === 88;
    return Rs(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return Jr(n) || e2;
}
var zs = {}.hasOwnProperty;
function j1(e2, t2, n) {
  return typeof t2 != "string" && (n = t2, t2 = void 0), V1(n)(
    U1(
      H1(n).document().write(v1()(e2, t2, true))
    )
  );
}
function V1(e2) {
  const t2 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(lu),
      autolinkProtocol: ee,
      autolinkEmail: ee,
      atxHeading: a(au),
      blockQuote: a(ot),
      characterEscape: ee,
      characterReference: ee,
      codeFenced: a(Ke),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: a(Ke, i),
      codeText: a(zn, i),
      codeTextData: ee,
      data: ee,
      codeFlowValue: ee,
      definition: a($s),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: a(Xs),
      hardBreakEscape: a(su),
      hardBreakTrailing: a(su),
      htmlFlow: a(ou, i),
      htmlFlowData: ee,
      htmlText: a(ou, i),
      htmlTextData: ee,
      image: a(Ks),
      label: i,
      link: a(lu),
      listItem: a(Js),
      listItemValue: p2,
      listOrdered: a(cu, f2),
      listUnordered: a(cu),
      paragraph: a(Zs),
      reference: b,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: a(au),
      strong: a(eo),
      thematicBreak: a(no)
    },
    exit: {
      atxHeading: l3(),
      atxHeadingSequence: q,
      autolink: l3(),
      autolinkEmail: qe,
      autolinkProtocol: Nt,
      blockQuote: l3(),
      characterEscapeValue: I,
      characterReferenceMarkerHexadecimal: Xe,
      characterReferenceMarkerNumeric: Xe,
      characterReferenceValue: de,
      codeFenced: l3(y2),
      codeFencedFence: C,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: A,
      codeFlowValue: I,
      codeIndented: l3(S),
      codeText: l3(j2),
      codeTextData: I,
      data: I,
      definition: l3(),
      definitionDestinationString: Y,
      definitionLabelString: O,
      definitionTitleString: L,
      emphasis: l3(),
      hardBreakEscape: l3(U),
      hardBreakTrailing: l3(U),
      htmlFlow: l3(v),
      htmlFlowData: I,
      htmlText: l3(F),
      htmlTextData: I,
      image: l3(he),
      label: Fe,
      labelText: ye,
      lineEnding: H,
      link: l3(le),
      listItem: l3(),
      listOrdered: l3(),
      listUnordered: l3(),
      paragraph: l3(),
      referenceString: Oe,
      resourceDestinationString: T,
      resourceTitleString: Ne,
      resource: He,
      setextHeading: l3(Z),
      setextHeadingLineSequence: Q,
      setextHeadingText: k,
      strong: l3(),
      thematicBreak: l3()
    }
  };
  Ys(t2, (e2 || {}).mdastExtensions || []);
  const n = {};
  return r2;
  function r2(N2) {
    let M = {
      type: "root",
      children: []
    };
    const V = {
      stack: [M],
      tokenStack: [],
      config: t2,
      enter: o,
      exit: c,
      buffer: i,
      resume: h,
      data: n
    }, K = [];
    let te = -1;
    for (; ++te < N2.length; )
      if (N2[te][1].type === "listOrdered" || N2[te][1].type === "listUnordered")
        if (N2[te][0] === "enter")
          K.push(te);
        else {
          const Le = K.pop();
          te = u(N2, Le, te);
        }
    for (te = -1; ++te < N2.length; ) {
      const Le = t2[N2[te][0]];
      zs.call(Le, N2[te][1].type) && Le[N2[te][1].type].call(
        Object.assign(
          {
            sliceSerialize: N2[te][2].sliceSerialize
          },
          V
        ),
        N2[te][1]
      );
    }
    if (V.tokenStack.length > 0) {
      const Le = V.tokenStack[V.tokenStack.length - 1];
      (Le[1] || Ci).call(V, void 0, Le[0]);
    }
    for (M.position = {
      start: je(
        N2.length > 0 ? N2[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: je(
        N2.length > 0 ? N2[N2.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, te = -1; ++te < t2.transforms.length; )
      M = t2.transforms[te](M) || M;
    return M;
  }
  function u(N2, M, V) {
    let K = M - 1, te = -1, Le = false, Je, Ue, Ot, Lt;
    for (; ++K <= V; ) {
      const _e = N2[K];
      switch (_e[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          _e[0] === "enter" ? te++ : te--, Lt = void 0;
          break;
        }
        case "lineEndingBlank": {
          _e[0] === "enter" && (Je && !Lt && !te && !Ot && (Ot = K), Lt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Lt = void 0;
      }
      if (!te && _e[0] === "enter" && _e[1].type === "listItemPrefix" || te === -1 && _e[0] === "exit" && (_e[1].type === "listUnordered" || _e[1].type === "listOrdered")) {
        if (Je) {
          let lt = K;
          for (Ue = void 0; lt--; ) {
            const ve = N2[lt];
            if (ve[1].type === "lineEnding" || ve[1].type === "lineEndingBlank") {
              if (ve[0] === "exit") continue;
              Ue && (N2[Ue][1].type = "lineEndingBlank", Le = true), ve[1].type = "lineEnding", Ue = lt;
            } else if (!(ve[1].type === "linePrefix" || ve[1].type === "blockQuotePrefix" || ve[1].type === "blockQuotePrefixWhitespace" || ve[1].type === "blockQuoteMarker" || ve[1].type === "listItemIndent")) break;
          }
          Ot && (!Ue || Ot < Ue) && (Je._spread = true), Je.end = Object.assign(
            {},
            Ue ? N2[Ue][1].start : _e[1].end
          ), N2.splice(Ue || K, 0, ["exit", Je, _e[2]]), K++, V++;
        }
        if (_e[1].type === "listItemPrefix") {
          const lt = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, _e[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Je = lt, N2.splice(K, 0, ["enter", lt, _e[2]]), K++, V++, Ot = void 0, Lt = true;
        }
      }
    }
    return N2[M][1]._spread = Le, V;
  }
  function a(N2, M) {
    return V;
    function V(K) {
      o.call(this, N2(K), K), M && M.call(this, K);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(N2, M, V) {
    this.stack[this.stack.length - 1].children.push(N2), this.stack.push(N2), this.tokenStack.push([M, V]), N2.position = {
      start: je(M.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l3(N2) {
    return M;
    function M(V) {
      N2 && N2.call(this, V), c.call(this, V);
    }
  }
  function c(N2, M) {
    const V = this.stack.pop(), K = this.tokenStack.pop();
    if (K)
      K[0].type !== N2.type && (M ? M.call(this, N2, K[0]) : (K[1] || Ci).call(this, N2, K[0]));
    else throw new Error(
      "Cannot close `" + N2.type + "` (" + Gt({
        start: N2.start,
        end: N2.end
      }) + "): it’s not open"
    );
    V.position.end = je(N2.end);
  }
  function h() {
    return qr(this.stack.pop());
  }
  function f2() {
    this.data.expectingFirstListItemValue = true;
  }
  function p2(N2) {
    if (this.data.expectingFirstListItemValue) {
      const M = this.stack[this.stack.length - 2];
      M.start = Number.parseInt(this.sliceSerialize(N2), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.lang = N2;
  }
  function A() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.meta = N2;
  }
  function C() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = true);
  }
  function y2() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N2.replace(/(\r?\n|\r)$/g, "");
  }
  function O(N2) {
    const M = this.resume(), V = this.stack[this.stack.length - 1];
    V.label = M, V.identifier = Tt(
      this.sliceSerialize(N2)
    ).toLowerCase();
  }
  function L() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N2;
  }
  function Y() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N2;
  }
  function q(N2) {
    const M = this.stack[this.stack.length - 1];
    if (!M.depth) {
      const V = this.sliceSerialize(N2).length;
      M.depth = V;
    }
  }
  function k() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function Q(N2) {
    const M = this.stack[this.stack.length - 1];
    M.depth = this.sliceSerialize(N2).codePointAt(0) === 61 ? 1 : 2;
  }
  function Z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function ee(N2) {
    const V = this.stack[this.stack.length - 1].children;
    let K = V[V.length - 1];
    (!K || K.type !== "text") && (K = to(), K.position = {
      start: je(N2.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, V.push(K)), this.stack.push(K);
  }
  function I(N2) {
    const M = this.stack.pop();
    M.value += this.sliceSerialize(N2), M.position.end = je(N2.end);
  }
  function H(N2) {
    const M = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const V = M.children[M.children.length - 1];
      V.position.end = je(N2.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t2.canContainEols.includes(M.type) && (ee.call(this, N2), I.call(this, N2));
  }
  function U() {
    this.data.atHardBreak = true;
  }
  function v() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N2;
  }
  function F() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N2;
  }
  function j2() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N2;
  }
  function le() {
    const N2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N2.type += "Reference", N2.referenceType = M, delete N2.url, delete N2.title;
    } else
      delete N2.identifier, delete N2.label;
    this.data.referenceType = void 0;
  }
  function he() {
    const N2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N2.type += "Reference", N2.referenceType = M, delete N2.url, delete N2.title;
    } else
      delete N2.identifier, delete N2.label;
    this.data.referenceType = void 0;
  }
  function ye(N2) {
    const M = this.sliceSerialize(N2), V = this.stack[this.stack.length - 2];
    V.label = Y1(M), V.identifier = Tt(M).toLowerCase();
  }
  function Fe() {
    const N2 = this.stack[this.stack.length - 1], M = this.resume(), V = this.stack[this.stack.length - 1];
    if (this.data.inReference = true, V.type === "link") {
      const K = N2.children;
      V.children = K;
    } else
      V.alt = M;
  }
  function T() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N2;
  }
  function Ne() {
    const N2 = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N2;
  }
  function He() {
    this.data.inReference = void 0;
  }
  function b() {
    this.data.referenceType = "collapsed";
  }
  function Oe(N2) {
    const M = this.resume(), V = this.stack[this.stack.length - 1];
    V.label = M, V.identifier = Tt(
      this.sliceSerialize(N2)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Xe(N2) {
    this.data.characterReferenceType = N2.type;
  }
  function de(N2) {
    const M = this.sliceSerialize(N2), V = this.data.characterReferenceType;
    let K;
    V ? (K = Rs(
      M,
      V === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : K = Jr(M);
    const te = this.stack.pop();
    te.value += K, te.position.end = je(N2.end);
  }
  function Nt(N2) {
    I.call(this, N2);
    const M = this.stack[this.stack.length - 1];
    M.url = this.sliceSerialize(N2);
  }
  function qe(N2) {
    I.call(this, N2);
    const M = this.stack[this.stack.length - 1];
    M.url = "mailto:" + this.sliceSerialize(N2);
  }
  function ot() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ke() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function zn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function $s() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Xs() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function au() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function su() {
    return {
      type: "break"
    };
  }
  function ou() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ks() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function lu() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function cu(N2) {
    return {
      type: "list",
      ordered: N2.type === "listOrdered",
      start: null,
      spread: N2._spread,
      children: []
    };
  }
  function Js(N2) {
    return {
      type: "listItem",
      spread: N2._spread,
      checked: null,
      children: []
    };
  }
  function Zs() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function eo() {
    return {
      type: "strong",
      children: []
    };
  }
  function to() {
    return {
      type: "text",
      value: ""
    };
  }
  function no() {
    return {
      type: "thematicBreak"
    };
  }
}
function je(e2) {
  return {
    line: e2.line,
    column: e2.column,
    offset: e2.offset
  };
}
function Ys(e2, t2) {
  let n = -1;
  for (; ++n < t2.length; ) {
    const r2 = t2[n];
    Array.isArray(r2) ? Ys(e2, r2) : W1(e2, r2);
  }
}
function W1(e2, t2) {
  let n;
  for (n in t2)
    if (zs.call(t2, n))
      switch (n) {
        case "canContainEols": {
          const r2 = t2[n];
          r2 && e2[n].push(...r2);
          break;
        }
        case "transforms": {
          const r2 = t2[n];
          r2 && e2[n].push(...r2);
          break;
        }
        case "enter":
        case "exit": {
          const r2 = t2[n];
          r2 && Object.assign(e2[n], r2);
          break;
        }
      }
}
function Ci(e2, t2) {
  throw e2 ? new Error(
    "Cannot close `" + e2.type + "` (" + Gt({
      start: e2.start,
      end: e2.end
    }) + "): a different token (`" + t2.type + "`, " + Gt({
      start: t2.start,
      end: t2.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t2.type + "`, " + Gt({
      start: t2.start,
      end: t2.end
    }) + ") is still open"
  );
}
function G1(e2) {
  const t2 = this;
  t2.parser = n;
  function n(r2) {
    return j1(r2, {
      ...t2.data("settings"),
      ...e2,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t2.data("micromarkExtensions") || [],
      mdastExtensions: t2.data("fromMarkdownExtensions") || []
    });
  }
}
function Q1(e2, t2) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e2.wrap(e2.all(t2), true)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function $1(e2, t2) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e2.patch(t2, n), [e2.applyData(t2, n), { type: "text", value: `
` }];
}
function X1(e2, t2) {
  const n = t2.value ? t2.value + `
` : "", r2 = {};
  t2.lang && (r2.className = ["language-" + t2.lang]);
  let u = {
    type: "element",
    tagName: "code",
    properties: r2,
    children: [{ type: "text", value: n }]
  };
  return t2.meta && (u.data = { meta: t2.meta }), e2.patch(t2, u), u = e2.applyData(t2, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, e2.patch(t2, u), u;
}
function K1(e2, t2) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function J1(e2, t2) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function Z1(e2, t2) {
  const n = typeof e2.options.clobberPrefix == "string" ? e2.options.clobberPrefix : "user-content-", r2 = String(t2.identifier).toUpperCase(), u = kt(r2.toLowerCase()), a = e2.footnoteOrder.indexOf(r2);
  let i, o = e2.footnoteCounts.get(r2);
  o === void 0 ? (o = 0, e2.footnoteOrder.push(r2), i = e2.footnoteOrder.length) : i = a + 1, o += 1, e2.footnoteCounts.set(r2, o);
  const l3 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + u,
      id: n + "fnref-" + u + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e2.patch(t2, l3);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l3]
  };
  return e2.patch(t2, c), e2.applyData(t2, c);
}
function eE(e2, t2) {
  const n = {
    type: "element",
    tagName: "h" + t2.depth,
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function tE(e2, t2) {
  if (e2.options.allowDangerousHtml) {
    const n = { type: "raw", value: t2.value };
    return e2.patch(t2, n), e2.applyData(t2, n);
  }
}
function qs(e2, t2) {
  const n = t2.referenceType;
  let r2 = "]";
  if (n === "collapsed" ? r2 += "[]" : n === "full" && (r2 += "[" + (t2.label || t2.identifier) + "]"), t2.type === "imageReference")
    return [{ type: "text", value: "![" + t2.alt + r2 }];
  const u = e2.all(t2), a = u[0];
  a && a.type === "text" ? a.value = "[" + a.value : u.unshift({ type: "text", value: "[" });
  const i = u[u.length - 1];
  return i && i.type === "text" ? i.value += r2 : u.push({ type: "text", value: r2 }), u;
}
function nE(e2, t2) {
  const n = String(t2.identifier).toUpperCase(), r2 = e2.definitionById.get(n);
  if (!r2)
    return qs(e2, t2);
  const u = { src: kt(r2.url || ""), alt: t2.alt };
  r2.title !== null && r2.title !== void 0 && (u.title = r2.title);
  const a = { type: "element", tagName: "img", properties: u, children: [] };
  return e2.patch(t2, a), e2.applyData(t2, a);
}
function rE(e2, t2) {
  const n = { src: kt(t2.url) };
  t2.alt !== null && t2.alt !== void 0 && (n.alt = t2.alt), t2.title !== null && t2.title !== void 0 && (n.title = t2.title);
  const r2 = { type: "element", tagName: "img", properties: n, children: [] };
  return e2.patch(t2, r2), e2.applyData(t2, r2);
}
function uE(e2, t2) {
  const n = { type: "text", value: t2.value.replace(/\r?\n|\r/g, " ") };
  e2.patch(t2, n);
  const r2 = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e2.patch(t2, r2), e2.applyData(t2, r2);
}
function iE(e2, t2) {
  const n = String(t2.identifier).toUpperCase(), r2 = e2.definitionById.get(n);
  if (!r2)
    return qs(e2, t2);
  const u = { href: kt(r2.url || "") };
  r2.title !== null && r2.title !== void 0 && (u.title = r2.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: u,
    children: e2.all(t2)
  };
  return e2.patch(t2, a), e2.applyData(t2, a);
}
function aE(e2, t2) {
  const n = { href: kt(t2.url) };
  t2.title !== null && t2.title !== void 0 && (n.title = t2.title);
  const r2 = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e2.all(t2)
  };
  return e2.patch(t2, r2), e2.applyData(t2, r2);
}
function sE(e2, t2, n) {
  const r2 = e2.all(t2), u = n ? oE(n) : js(t2), a = {}, i = [];
  if (typeof t2.checked == "boolean") {
    const h = r2[0];
    let f2;
    h && h.type === "element" && h.tagName === "p" ? f2 = h : (f2 = { type: "element", tagName: "p", properties: {}, children: [] }, r2.unshift(f2)), f2.children.length > 0 && f2.children.unshift({ type: "text", value: " " }), f2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t2.checked, disabled: true },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r2.length; ) {
    const h = r2[o];
    (u || o !== 0 || h.type !== "element" || h.tagName !== "p") && i.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !u ? i.push(...h.children) : i.push(h);
  }
  const l3 = r2[r2.length - 1];
  l3 && (u || l3.type !== "element" || l3.tagName !== "p") && i.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: i };
  return e2.patch(t2, c), e2.applyData(t2, c);
}
function oE(e2) {
  let t2 = false;
  if (e2.type === "list") {
    t2 = e2.spread || false;
    const n = e2.children;
    let r2 = -1;
    for (; !t2 && ++r2 < n.length; )
      t2 = js(n[r2]);
  }
  return t2;
}
function js(e2) {
  const t2 = e2.spread;
  return t2 ?? e2.children.length > 1;
}
function lE(e2, t2) {
  const n = {}, r2 = e2.all(t2);
  let u = -1;
  for (typeof t2.start == "number" && t2.start !== 1 && (n.start = t2.start); ++u < r2.length; ) {
    const i = r2[u];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t2.ordered ? "ol" : "ul",
    properties: n,
    children: e2.wrap(r2, true)
  };
  return e2.patch(t2, a), e2.applyData(t2, a);
}
function cE(e2, t2) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function fE(e2, t2) {
  const n = { type: "root", children: e2.wrap(e2.all(t2)) };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function hE(e2, t2) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function dE(e2, t2) {
  const n = e2.all(t2), r2 = n.shift(), u = [];
  if (r2) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e2.wrap([r2], true)
    };
    e2.patch(t2.children[0], i), u.push(i);
  }
  if (n.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e2.wrap(n, true)
    }, o = Me(t2.children[1]), l3 = Mn(t2.children[t2.children.length - 1]);
    o && l3 && (i.position = { start: o, end: l3 }), u.push(i);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e2.wrap(u, true)
  };
  return e2.patch(t2, a), e2.applyData(t2, a);
}
function mE(e2, t2, n) {
  const r2 = n ? n.children : void 0, a = (r2 ? r2.indexOf(t2) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, o = i ? i.length : t2.children.length;
  let l3 = -1;
  const c = [];
  for (; ++l3 < o; ) {
    const f2 = t2.children[l3], p2 = {}, d = i ? i[l3] : void 0;
    d && (p2.align = d);
    let A = { type: "element", tagName: a, properties: p2, children: [] };
    f2 && (A.children = e2.all(f2), e2.patch(f2, A), A = e2.applyData(f2, A)), c.push(A);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e2.wrap(c, true)
  };
  return e2.patch(t2, h), e2.applyData(t2, h);
}
function pE(e2, t2) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
var Si = 9;
var xi = 32;
function EE(e2) {
  const t2 = String(e2), n = /\r?\n|\r/g;
  let r2 = n.exec(t2), u = 0;
  const a = [];
  for (; r2; )
    a.push(
      Ii(t2.slice(u, r2.index), u > 0, true),
      r2[0]
    ), u = r2.index + r2[0].length, r2 = n.exec(t2);
  return a.push(Ii(t2.slice(u), u > 0, false)), a.join("");
}
function Ii(e2, t2, n) {
  let r2 = 0, u = e2.length;
  if (t2) {
    let a = e2.codePointAt(r2);
    for (; a === Si || a === xi; )
      r2++, a = e2.codePointAt(r2);
  }
  if (n) {
    let a = e2.codePointAt(u - 1);
    for (; a === Si || a === xi; )
      u--, a = e2.codePointAt(u - 1);
  }
  return u > r2 ? e2.slice(r2, u) : "";
}
function gE(e2, t2) {
  const n = { type: "text", value: EE(String(t2.value)) };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
function TE(e2, t2) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e2.patch(t2, n), e2.applyData(t2, n);
}
var bE = {
  blockquote: Q1,
  break: $1,
  code: X1,
  delete: K1,
  emphasis: J1,
  footnoteReference: Z1,
  heading: eE,
  html: tE,
  imageReference: nE,
  image: rE,
  inlineCode: uE,
  linkReference: iE,
  link: aE,
  listItem: sE,
  list: lE,
  paragraph: cE,
  // @ts-expect-error: root is different, but hard to type.
  root: fE,
  strong: hE,
  table: dE,
  tableCell: pE,
  tableRow: mE,
  text: gE,
  thematicBreak: TE,
  toml: hn,
  yaml: hn,
  definition: hn,
  footnoteDefinition: hn
};
function hn() {
}
var Vs = -1;
var vn = 0;
var Qt = 1;
var yn = 2;
var tu = 3;
var nu = 4;
var ru = 5;
var uu = 6;
var Ws = 7;
var Gs = 8;
var ki = typeof self == "object" ? self : globalThis;
var AE = (e2, t2) => {
  const n = (u, a) => (e2.set(a, u), u), r2 = (u) => {
    if (e2.has(u))
      return e2.get(u);
    const [a, i] = t2[u];
    switch (a) {
      case vn:
      case Vs:
        return n(i, u);
      case Qt: {
        const o = n([], u);
        for (const l3 of i)
          o.push(r2(l3));
        return o;
      }
      case yn: {
        const o = n({}, u);
        for (const [l3, c] of i)
          o[r2(l3)] = r2(c);
        return o;
      }
      case tu:
        return n(new Date(i), u);
      case nu: {
        const { source: o, flags: l3 } = i;
        return n(new RegExp(o, l3), u);
      }
      case ru: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l3, c] of i)
          o.set(r2(l3), r2(c));
        return o;
      }
      case uu: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l3 of i)
          o.add(r2(l3));
        return o;
      }
      case Ws: {
        const { name: o, message: l3 } = i;
        return n(new ki[o](l3), u);
      }
      case Gs:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
      case "ArrayBuffer":
        return n(new Uint8Array(i).buffer, i);
      case "DataView": {
        const { buffer: o } = new Uint8Array(i);
        return n(new DataView(o), i);
      }
    }
    return n(new ki[a](i), u);
  };
  return r2;
};
var yi = (e2) => AE(/* @__PURE__ */ new Map(), e2)(0);
var dt = "";
var { toString: _E } = {};
var { keys: CE } = Object;
var Ft = (e2) => {
  const t2 = typeof e2;
  if (t2 !== "object" || !e2)
    return [vn, t2];
  const n = _E.call(e2).slice(8, -1);
  switch (n) {
    case "Array":
      return [Qt, dt];
    case "Object":
      return [yn, dt];
    case "Date":
      return [tu, dt];
    case "RegExp":
      return [nu, dt];
    case "Map":
      return [ru, dt];
    case "Set":
      return [uu, dt];
    case "DataView":
      return [Qt, n];
  }
  return n.includes("Array") ? [Qt, n] : n.includes("Error") ? [Ws, n] : [yn, n];
};
var dn2 = ([e2, t2]) => e2 === vn && (t2 === "function" || t2 === "symbol");
var SE = (e2, t2, n, r2) => {
  const u = (i, o) => {
    const l3 = r2.push(i) - 1;
    return n.set(o, l3), l3;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l3] = Ft(i);
    switch (o) {
      case vn: {
        let h = i;
        switch (l3) {
          case "bigint":
            o = Gs, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e2)
              throw new TypeError("unable to serialize " + l3);
            h = null;
            break;
          case "undefined":
            return u([Vs], i);
        }
        return u([o, h], i);
      }
      case Qt: {
        if (l3) {
          let p2 = i;
          return l3 === "DataView" ? p2 = new Uint8Array(i.buffer) : l3 === "ArrayBuffer" && (p2 = new Uint8Array(i)), u([l3, [...p2]], i);
        }
        const h = [], f2 = u([o, h], i);
        for (const p2 of i)
          h.push(a(p2));
        return f2;
      }
      case yn: {
        if (l3)
          switch (l3) {
            case "BigInt":
              return u([l3, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l3, i.valueOf()], i);
          }
        if (t2 && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f2 = u([o, h], i);
        for (const p2 of CE(i))
          (e2 || !dn2(Ft(i[p2]))) && h.push([a(p2), a(i[p2])]);
        return f2;
      }
      case tu:
        return u([o, i.toISOString()], i);
      case nu: {
        const { source: h, flags: f2 } = i;
        return u([o, { source: h, flags: f2 }], i);
      }
      case ru: {
        const h = [], f2 = u([o, h], i);
        for (const [p2, d] of i)
          (e2 || !(dn2(Ft(p2)) || dn2(Ft(d)))) && h.push([a(p2), a(d)]);
        return f2;
      }
      case uu: {
        const h = [], f2 = u([o, h], i);
        for (const p2 of i)
          (e2 || !dn2(Ft(p2))) && h.push(a(p2));
        return f2;
      }
    }
    const { message: c } = i;
    return u([o, { name: l3, message: c }], i);
  };
  return a;
};
var Ni = (e2, { json: t2, lossy: n } = {}) => {
  const r2 = [];
  return SE(!(t2 || n), !!t2, /* @__PURE__ */ new Map(), r2)(e2), r2;
};
var Nn = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e2, t2) => t2 && ("json" in t2 || "lossy" in t2) ? yi(Ni(e2, t2)) : structuredClone(e2)
) : (e2, t2) => yi(Ni(e2, t2));
function xE(e2, t2) {
  const n = [{ type: "text", value: "↩" }];
  return t2 > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t2) }]
  }), n;
}
function IE(e2, t2) {
  return "Back to reference " + (e2 + 1) + (t2 > 1 ? "-" + t2 : "");
}
function kE(e2) {
  const t2 = typeof e2.options.clobberPrefix == "string" ? e2.options.clobberPrefix : "user-content-", n = e2.options.footnoteBackContent || xE, r2 = e2.options.footnoteBackLabel || IE, u = e2.options.footnoteLabel || "Footnotes", a = e2.options.footnoteLabelTagName || "h2", i = e2.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l3 = -1;
  for (; ++l3 < e2.footnoteOrder.length; ) {
    const c = e2.footnoteById.get(
      e2.footnoteOrder[l3]
    );
    if (!c)
      continue;
    const h = e2.all(c), f2 = String(c.identifier).toUpperCase(), p2 = kt(f2.toLowerCase());
    let d = 0;
    const A = [], C = e2.footnoteCounts.get(f2);
    for (; C !== void 0 && ++d <= C; ) {
      A.length > 0 && A.push({ type: "text", value: " " });
      let O = typeof n == "string" ? n : n(l3, d);
      typeof O == "string" && (O = { type: "text", value: O }), A.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t2 + "fnref-" + p2 + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r2 == "string" ? r2 : r2(l3, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(O) ? O : [O]
      });
    }
    const y2 = h[h.length - 1];
    if (y2 && y2.type === "element" && y2.tagName === "p") {
      const O = y2.children[y2.children.length - 1];
      O && O.type === "text" ? O.value += " " : y2.children.push({ type: "text", value: " " }), y2.children.push(...A);
    } else
      h.push(...A);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t2 + "fn-" + p2 },
      children: e2.wrap(h, true)
    };
    e2.patch(c, S), o.push(S);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Nn(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: u }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e2.wrap(o, true)
        },
        { type: "text", value: `
` }
      ]
    };
}
var Ir = {}.hasOwnProperty;
var yE = {};
function NE(e2, t2) {
  const n = t2 || yE, r2 = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = { ...bE, ...n.handlers }, o = {
    all: c,
    applyData: LE,
    definitionById: r2,
    footnoteById: u,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: i,
    one: l3,
    options: n,
    patch: OE,
    wrap: DE
  };
  return nn(e2, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const f2 = h.type === "definition" ? r2 : u, p2 = String(h.identifier).toUpperCase();
      f2.has(p2) || f2.set(p2, h);
    }
  }), o;
  function l3(h, f2) {
    const p2 = h.type, d = o.handlers[p2];
    if (Ir.call(o.handlers, p2) && d)
      return d(o, h, f2);
    if (o.options.passThrough && o.options.passThrough.includes(p2)) {
      if ("children" in h) {
        const { children: C, ...y2 } = h, S = Nn(y2);
        return S.children = o.all(h), S;
      }
      return Nn(h);
    }
    return (o.options.unknownHandler || RE)(o, h, f2);
  }
  function c(h) {
    const f2 = [];
    if ("children" in h) {
      const p2 = h.children;
      let d = -1;
      for (; ++d < p2.length; ) {
        const A = o.one(p2[d], h);
        if (A) {
          if (d && p2[d - 1].type === "break" && (!Array.isArray(A) && A.type === "text" && (A.value = Oi(A.value)), !Array.isArray(A) && A.type === "element")) {
            const C = A.children[0];
            C && C.type === "text" && (C.value = Oi(C.value));
          }
          Array.isArray(A) ? f2.push(...A) : f2.push(A);
        }
      }
    }
    return f2;
  }
}
function OE(e2, t2) {
  e2.position && (t2.position = O0(e2));
}
function LE(e2, t2) {
  let n = t2;
  if (e2 && e2.data) {
    const r2 = e2.data.hName, u = e2.data.hChildren, a = e2.data.hProperties;
    if (typeof r2 == "string")
      if (n.type === "element")
        n.tagName = r2;
      else {
        const i = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r2, properties: {}, children: i };
      }
    n.type === "element" && a && Object.assign(n.properties, Nn(a)), "children" in n && n.children && u !== null && u !== void 0 && (n.children = u);
  }
  return n;
}
function RE(e2, t2) {
  const n = t2.data || {}, r2 = "value" in t2 && !(Ir.call(n, "hProperties") || Ir.call(n, "hChildren")) ? { type: "text", value: t2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e2.all(t2)
  };
  return e2.patch(t2, r2), e2.applyData(t2, r2);
}
function DE(e2, t2) {
  const n = [];
  let r2 = -1;
  for (t2 && n.push({ type: "text", value: `
` }); ++r2 < e2.length; )
    r2 && n.push({ type: "text", value: `
` }), n.push(e2[r2]);
  return t2 && e2.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Oi(e2) {
  let t2 = 0, n = e2.charCodeAt(t2);
  for (; n === 9 || n === 32; )
    t2++, n = e2.charCodeAt(t2);
  return e2.slice(t2);
}
function Li(e2, t2) {
  const n = NE(e2, t2), r2 = n.one(e2, void 0), u = kE(n), a = Array.isArray(r2) ? { type: "root", children: r2 } : r2 || { type: "root", children: [] };
  return u && a.children.push({ type: "text", value: `
` }, u), a;
}
function PE(e2, t2) {
  return e2 && "run" in e2 ? async function(n, r2) {
    const u = (
      /** @type {HastRoot} */
      Li(n, { file: r2, ...t2 })
    );
    await e2.run(u, r2);
  } : function(n, r2) {
    return (
      /** @type {HastRoot} */
      Li(n, { file: r2, ...e2 || t2 })
    );
  };
}
function Ri(e2) {
  if (e2)
    throw e2;
}
var nr;
var Di;
function wE() {
  if (Di) return nr;
  Di = 1;
  var e2 = Object.prototype.hasOwnProperty, t2 = Object.prototype.toString, n = Object.defineProperty, r2 = Object.getOwnPropertyDescriptor, u = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t2.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t2.call(c) !== "[object Object]")
      return false;
    var h = e2.call(c, "constructor"), f2 = c.constructor && c.constructor.prototype && e2.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !h && !f2)
      return false;
    var p2;
    for (p2 in c)
      ;
    return typeof p2 > "u" || e2.call(c, p2);
  }, i = function(c, h) {
    n && h.name === "__proto__" ? n(c, h.name, {
      enumerable: true,
      configurable: true,
      value: h.newValue,
      writable: true
    }) : c[h.name] = h.newValue;
  }, o = function(c, h) {
    if (h === "__proto__")
      if (e2.call(c, h)) {
        if (r2)
          return r2(c, h).value;
      } else return;
    return c[h];
  };
  return nr = function l3() {
    var c, h, f2, p2, d, A, C = arguments[0], y2 = 1, S = arguments.length, O = false;
    for (typeof C == "boolean" && (O = C, C = arguments[1] || {}, y2 = 2), (C == null || typeof C != "object" && typeof C != "function") && (C = {}); y2 < S; ++y2)
      if (c = arguments[y2], c != null)
        for (h in c)
          f2 = o(C, h), p2 = o(c, h), C !== p2 && (O && p2 && (a(p2) || (d = u(p2))) ? (d ? (d = false, A = f2 && u(f2) ? f2 : []) : A = f2 && a(f2) ? f2 : {}, i(C, { name: h, newValue: l3(O, A, p2) })) : typeof p2 < "u" && i(C, { name: h, newValue: p2 }));
    return C;
  }, nr;
}
var ME = wE();
var rr = f(ME);
function kr(e2) {
  if (typeof e2 != "object" || e2 === null)
    return false;
  const t2 = Object.getPrototypeOf(e2);
  return (t2 === null || t2 === Object.prototype || Object.getPrototypeOf(t2) === null) && !(Symbol.toStringTag in e2) && !(Symbol.iterator in e2);
}
function BE() {
  const e2 = [], t2 = { run: n, use: r2 };
  return t2;
  function n(...u) {
    let a = -1;
    const i = u.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...u);
    function o(l3, ...c) {
      const h = e2[++a];
      let f2 = -1;
      if (l3) {
        i(l3);
        return;
      }
      for (; ++f2 < u.length; )
        (c[f2] === null || c[f2] === void 0) && (c[f2] = u[f2]);
      u = c, h ? FE(h, o)(...c) : i(null, ...c);
    }
  }
  function r2(u) {
    if (typeof u != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + u
      );
    return e2.push(u), t2;
  }
}
function FE(e2, t2) {
  let n;
  return r2;
  function r2(...i) {
    const o = e2.length > i.length;
    let l3;
    o && i.push(u);
    try {
      l3 = e2.apply(this, i);
    } catch (c) {
      const h = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw h;
      return u(h);
    }
    o || (l3 && l3.then && typeof l3.then == "function" ? l3.then(a, u) : l3 instanceof Error ? u(l3) : a(l3));
  }
  function u(i, ...o) {
    n || (n = true, t2(i, ...o));
  }
  function a(i) {
    u(null, i);
  }
}
var De = { basename: HE, dirname: UE, extname: vE, join: zE, sep: "/" };
function HE(e2, t2) {
  if (t2 !== void 0 && typeof t2 != "string")
    throw new TypeError('"ext" argument must be a string');
  sn(e2);
  let n = 0, r2 = -1, u = e2.length, a;
  if (t2 === void 0 || t2.length === 0 || t2.length > e2.length) {
    for (; u--; )
      if (e2.codePointAt(u) === 47) {
        if (a) {
          n = u + 1;
          break;
        }
      } else r2 < 0 && (a = true, r2 = u + 1);
    return r2 < 0 ? "" : e2.slice(n, r2);
  }
  if (t2 === e2)
    return "";
  let i = -1, o = t2.length - 1;
  for (; u--; )
    if (e2.codePointAt(u) === 47) {
      if (a) {
        n = u + 1;
        break;
      }
    } else
      i < 0 && (a = true, i = u + 1), o > -1 && (e2.codePointAt(u) === t2.codePointAt(o--) ? o < 0 && (r2 = u) : (o = -1, r2 = i));
  return n === r2 ? r2 = i : r2 < 0 && (r2 = e2.length), e2.slice(n, r2);
}
function UE(e2) {
  if (sn(e2), e2.length === 0)
    return ".";
  let t2 = -1, n = e2.length, r2;
  for (; --n; )
    if (e2.codePointAt(n) === 47) {
      if (r2) {
        t2 = n;
        break;
      }
    } else r2 || (r2 = true);
  return t2 < 0 ? e2.codePointAt(0) === 47 ? "/" : "." : t2 === 1 && e2.codePointAt(0) === 47 ? "//" : e2.slice(0, t2);
}
function vE(e2) {
  sn(e2);
  let t2 = e2.length, n = -1, r2 = 0, u = -1, a = 0, i;
  for (; t2--; ) {
    const o = e2.codePointAt(t2);
    if (o === 47) {
      if (i) {
        r2 = t2 + 1;
        break;
      }
      continue;
    }
    n < 0 && (i = true, n = t2 + 1), o === 46 ? u < 0 ? u = t2 : a !== 1 && (a = 1) : u > -1 && (a = -1);
  }
  return u < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && u === n - 1 && u === r2 + 1 ? "" : e2.slice(u, n);
}
function zE(...e2) {
  let t2 = -1, n;
  for (; ++t2 < e2.length; )
    sn(e2[t2]), e2[t2] && (n = n === void 0 ? e2[t2] : n + "/" + e2[t2]);
  return n === void 0 ? "." : YE(n);
}
function YE(e2) {
  sn(e2);
  const t2 = e2.codePointAt(0) === 47;
  let n = qE(e2, !t2);
  return n.length === 0 && !t2 && (n = "."), n.length > 0 && e2.codePointAt(e2.length - 1) === 47 && (n += "/"), t2 ? "/" + n : n;
}
function qE(e2, t2) {
  let n = "", r2 = 0, u = -1, a = 0, i = -1, o, l3;
  for (; ++i <= e2.length; ) {
    if (i < e2.length)
      o = e2.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(u === i - 1 || a === 1)) if (u !== i - 1 && a === 2) {
        if (n.length < 2 || r2 !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l3 = n.lastIndexOf("/"), l3 !== n.length - 1) {
              l3 < 0 ? (n = "", r2 = 0) : (n = n.slice(0, l3), r2 = n.length - 1 - n.lastIndexOf("/")), u = i, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r2 = 0, u = i, a = 0;
            continue;
          }
        }
        t2 && (n = n.length > 0 ? n + "/.." : "..", r2 = 2);
      } else
        n.length > 0 ? n += "/" + e2.slice(u + 1, i) : n = e2.slice(u + 1, i), r2 = i - u - 1;
      u = i, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function sn(e2) {
  if (typeof e2 != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e2)
    );
}
var jE = { cwd: VE };
function VE() {
  return "/";
}
function yr(e2) {
  return !!(e2 !== null && typeof e2 == "object" && "href" in e2 && e2.href && "protocol" in e2 && e2.protocol && // @ts-expect-error: indexing is fine.
  e2.auth === void 0);
}
function WE(e2) {
  if (typeof e2 == "string")
    e2 = new URL(e2);
  else if (!yr(e2)) {
    const t2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e2 + "`"
    );
    throw t2.code = "ERR_INVALID_ARG_TYPE", t2;
  }
  if (e2.protocol !== "file:") {
    const t2 = new TypeError("The URL must be of scheme file");
    throw t2.code = "ERR_INVALID_URL_SCHEME", t2;
  }
  return GE(e2);
}
function GE(e2) {
  if (e2.hostname !== "") {
    const r2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r2.code = "ERR_INVALID_FILE_URL_HOST", r2;
  }
  const t2 = e2.pathname;
  let n = -1;
  for (; ++n < t2.length; )
    if (t2.codePointAt(n) === 37 && t2.codePointAt(n + 1) === 50) {
      const r2 = t2.codePointAt(n + 2);
      if (r2 === 70 || r2 === 102) {
        const u = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw u.code = "ERR_INVALID_FILE_URL_PATH", u;
      }
    }
  return decodeURIComponent(t2);
}
var ur = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var Qs = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t2) {
    let n;
    t2 ? yr(t2) ? n = { path: t2 } : typeof t2 == "string" || QE(t2) ? n = { value: t2 } : n = t2 : n = {}, this.cwd = "cwd" in n ? "" : jE.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r2 = -1;
    for (; ++r2 < ur.length; ) {
      const a = ur[r2];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let u;
    for (u in n)
      ur.includes(u) || (this[u] = n[u]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? De.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t2) {
    ar(t2, "basename"), ir(t2, "basename"), this.path = De.join(this.dirname || "", t2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? De.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t2) {
    Pi(this.basename, "dirname"), this.path = De.join(t2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? De.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t2) {
    if (ir(t2, "extname"), Pi(this.dirname, "extname"), t2) {
      if (t2.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t2.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = De.join(this.dirname, this.stem + (t2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t2) {
    yr(t2) && (t2 = WE(t2)), ar(t2, "path"), this.path !== t2 && this.history.push(t2);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? De.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t2) {
    ar(t2, "stem"), ir(t2, "stem"), this.path = De.join(this.dirname || "", t2 + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t2, n, r2) {
    const u = this.message(t2, n, r2);
    throw u.fatal = true, u;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t2, n, r2) {
    const u = this.message(t2, n, r2);
    return u.fatal = void 0, u;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t2, n, r2) {
    const u = new Ee(
      // @ts-expect-error: the overloads are fine.
      t2,
      n,
      r2
    );
    return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = false, this.messages.push(u), u;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t2) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t2 || void 0).decode(this.value);
  }
};
function ir(e2, t2) {
  if (e2 && e2.includes(De.sep))
    throw new Error(
      "`" + t2 + "` cannot be a path: did not expect `" + De.sep + "`"
    );
}
function ar(e2, t2) {
  if (!e2)
    throw new Error("`" + t2 + "` cannot be empty");
}
function Pi(e2, t2) {
  if (!e2)
    throw new Error("Setting `" + t2 + "` requires `path` to be set too");
}
function QE(e2) {
  return !!(e2 && typeof e2 == "object" && "byteLength" in e2 && "byteOffset" in e2);
}
var $E = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e2) {
    const r2 = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), u = r2[e2], a = function() {
      return u.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r2), a;
  }
);
var XE = {}.hasOwnProperty;
var iu = class _iu extends $E {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = BE();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t2 = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _iu()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r2 = this.attachers[n];
      t2.use(...r2);
    }
    return t2.data(rr(true, {}, this.namespace)), t2;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t2, n) {
    return typeof t2 == "string" ? arguments.length === 2 ? (lr("data", this.frozen), this.namespace[t2] = n, this) : XE.call(this.namespace, t2) && this.namespace[t2] || void 0 : t2 ? (lr("data", this.frozen), this.namespace = t2, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r2] = this.attachers[this.freezeIndex];
      if (r2[0] === false)
        continue;
      r2[0] === true && (r2[0] = void 0);
      const u = n.call(t2, ...r2);
      typeof u == "function" && this.transformers.use(u);
    }
    return this.frozen = true, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t2) {
    this.freeze();
    const n = mn(t2), r2 = this.parser || this.Parser;
    return sr("parse", r2), r2(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t2, n) {
    const r2 = this;
    return this.freeze(), sr("process", this.parser || this.Parser), or("process", this.compiler || this.Compiler), n ? u(void 0, n) : new Promise(u);
    function u(a, i) {
      const o = mn(t2), l3 = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r2.parse(o)
      );
      r2.run(l3, o, function(h, f2, p2) {
        if (h || !f2 || !p2)
          return c(h);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f2
        ), A = r2.stringify(d, p2);
        ZE(A) ? p2.value = A : p2.result = A, c(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          p2
        );
      });
      function c(h, f2) {
        h || !f2 ? i(h) : a ? a(f2) : n(void 0, f2);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t2) {
    let n = false, r2;
    return this.freeze(), sr("processSync", this.parser || this.Parser), or("processSync", this.compiler || this.Compiler), this.process(t2, u), Mi("processSync", "process", n), r2;
    function u(a, i) {
      n = true, Ri(a), r2 = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t2, n, r2) {
    wi(t2), this.freeze();
    const u = this.transformers;
    return !r2 && typeof n == "function" && (r2 = n, n = void 0), r2 ? a(void 0, r2) : new Promise(a);
    function a(i, o) {
      const l3 = mn(n);
      u.run(t2, l3, c);
      function c(h, f2, p2) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f2 || t2
        );
        h ? o(h) : i ? i(d) : r2(void 0, d, p2);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t2, n) {
    let r2 = false, u;
    return this.run(t2, n, a), Mi("runSync", "run", r2), u;
    function a(i, o) {
      Ri(i), u = o, r2 = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t2, n) {
    this.freeze();
    const r2 = mn(n), u = this.compiler || this.Compiler;
    return or("stringify", u), wi(t2), u(t2, r2);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t2, ...n) {
    const r2 = this.attachers, u = this.namespace;
    if (lr("use", this.frozen), t2 != null) if (typeof t2 == "function")
      l3(t2, n);
    else if (typeof t2 == "object")
      Array.isArray(t2) ? o(t2) : i(t2);
    else
      throw new TypeError("Expected usable value, not `" + t2 + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l3(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [h, ...f2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l3(h, f2);
        } else
          i(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function i(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (u.settings = rr(true, u.settings, c.settings));
    }
    function o(c) {
      let h = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++h < c.length; ) {
          const f2 = c[h];
          a(f2);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l3(c, h) {
      let f2 = -1, p2 = -1;
      for (; ++f2 < r2.length; )
        if (r2[f2][0] === c) {
          p2 = f2;
          break;
        }
      if (p2 === -1)
        r2.push([c, ...h]);
      else if (h.length > 0) {
        let [d, ...A] = h;
        const C = r2[p2][1];
        kr(C) && kr(d) && (d = rr(true, C, d)), r2[p2] = [c, d, ...A];
      }
    }
  }
};
var KE = new iu().freeze();
function sr(e2, t2) {
  if (typeof t2 != "function")
    throw new TypeError("Cannot `" + e2 + "` without `parser`");
}
function or(e2, t2) {
  if (typeof t2 != "function")
    throw new TypeError("Cannot `" + e2 + "` without `compiler`");
}
function lr(e2, t2) {
  if (t2)
    throw new Error(
      "Cannot call `" + e2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function wi(e2) {
  if (!kr(e2) || typeof e2.type != "string")
    throw new TypeError("Expected node, got `" + e2 + "`");
}
function Mi(e2, t2, n) {
  if (!n)
    throw new Error(
      "`" + e2 + "` finished async. Use `" + t2 + "` instead"
    );
}
function mn(e2) {
  return JE(e2) ? e2 : new Qs(e2);
}
function JE(e2) {
  return !!(e2 && typeof e2 == "object" && "message" in e2 && "messages" in e2);
}
function ZE(e2) {
  return typeof e2 == "string" || eg(e2);
}
function eg(e2) {
  return !!(e2 && typeof e2 == "object" && "byteLength" in e2 && "byteOffset" in e2);
}
var tg = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var Bi = [];
var Fi = {
  allowDangerousHtml: true
};
var ng = /^(https?|ircs?|mailto|xmpp)$/i;
var rg = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  {
    from: "plugins",
    id: "change-plugins-to-remarkplugins",
    to: "remarkPlugins"
  },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function ug(e2) {
  const t2 = e2.allowedElements, n = e2.allowElement, r2 = e2.children || "", u = e2.className, a = e2.components, i = e2.disallowedElements, o = e2.rehypePlugins || Bi, l3 = e2.remarkPlugins || Bi, c = e2.remarkRehypeOptions ? { ...e2.remarkRehypeOptions, ...Fi } : Fi, h = e2.skipHtml, f2 = e2.unwrapDisallowed, p2 = e2.urlTransform || ig, d = KE().use(G1).use(l3).use(PE, c).use(o), A = new Qs();
  typeof r2 == "string" && (A.value = r2);
  for (const O of rg)
    Object.prototype.hasOwnProperty.call(e2, O.from) && (`Unexpected '${O.from}' prop, ` + (O.to ? `use '${O.to}' instead` : "remove it") + ` (see <${tg}#${O.id}> for more info)`, void 0);
  const C = d.parse(A);
  let y2 = d.runSync(C, A);
  return u && (y2 = {
    type: "element",
    tagName: "div",
    properties: { className: u },
    children: y2.type === "root" ? y2.children : [y2]
  }), nn(y2, S), Mm(y2, {
    Fragment: ae.Fragment,
    components: a,
    ignoreInvalidStyle: true,
    jsx: ae.jsx,
    jsxs: ae.jsxs,
    passKeys: true,
    passNode: true
  });
  function S(O, L, Y) {
    if (O.type === "raw" && Y && typeof L == "number")
      return h ? Y.children.splice(L, 1) : Y.children[L] = { type: "text", value: O.value }, L;
    if (O.type === "element") {
      for (const k in Zn)
        if (Object.prototype.hasOwnProperty.call(Zn, k) && Object.prototype.hasOwnProperty.call(O.properties, k)) {
          const Q = O.properties[k], Z = Zn[k];
          (Z == null || Z.includes(O.tagName)) && (O.properties[k] = p2(String(Q || ""), k, O));
        }
      let q = t2 ? !t2.includes(O.tagName) : i ? i.includes(O.tagName) : false;
      if (!q && n && typeof L == "number" && (q = !n(O, L, Y)), q && Y && typeof L == "number")
        return f2 && O.children ? Y.children.splice(L, 1, ...O.children) : Y.children.splice(L, 1), L;
    }
  }
}
function ig(e2) {
  const t2 = e2.indexOf(":"), n = e2.indexOf("?"), r2 = e2.indexOf("#"), u = e2.indexOf("/");
  return t2 < 0 || u > -1 && t2 > u || n > -1 && t2 > n || r2 > -1 && t2 > r2 || ng.test(e2.slice(0, t2)) ? e2 : "";
}
var ag = () => (e2) => {
  nn(e2, "element", (t2, n, r2) => {
    t2.tagName === "code" && (t2.properties.inline = String((r2 == null ? void 0 : r2.tagName) !== "pre"));
  });
};
var sg = [gd];
var og = [ag, K0];
var Lg = "prose dark:prose-invert prose-neutral";
var lg = (0, import_react.memo)(
  ({ content: e2, className: t2 }) => ae.jsx(
    ug,
    {
      remarkPlugins: sg,
      rehypePlugins: og,
      components: lm,
      className: t2,
      children: e2
    }
  )
);
lg.displayName = "Markdown";

export {
  e,
  Wr,
  Ng,
  rm,
  um,
  Og,
  Ts2 as Ts,
  ft,
  sm,
  om,
  lm,
  Lg,
  lg
};
//# sourceMappingURL=chunk-ALHMGBAY.js.map
