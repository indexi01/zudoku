// node_modules/zudoku/lib/prism-markdown.min-C0Qn0m-5.js
(function(e) {
  function p(n) {
    return n = n.replace(/<inner>/g, function() {
      return `(?:\\\\.|[^\\\\
\r]|(?:
|\r
?)(?![\r
]))`;
    }), RegExp("((?:^|[^\\\\])(?:\\\\{2})*)(?:" + n + ")");
  }
  var g = "(?:\\\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\\\|\r\n`])+", s = `\\|?__(?:\\|__)+\\|?(?:(?:
|\r
?)|(?![^]))`.replace(/__/g, function() {
    return g;
  }), c = `\\|?[ 	]*:?-{3,}:?[ 	]*(?:\\|[ 	]*:?-{3,}:?[ 	]*)+\\|?(?:
|\r
?)`;
  e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: e.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + s + c + "(?:" + s + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + s + c + ")(?:" + s + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(g), inside: e.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + s + ")" + c + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + s + "$"), inside: { "table-header": { pattern: RegExp(g), alias: "important", inside: e.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: p("\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*"), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: p("\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*"), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: p("(~~?)(?:(?!~)<inner>)+\\2"), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: p('!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[	 ]+"(?:\\\\.|[^"\\\\])*")?\\)|[ 	]?\\[(?:(?!\\])<inner>)+\\])'), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(t) {
      n !== t && (e.languages.markdown[n].inside.content.inside[t] = e.languages.markdown[t]);
    });
  }), e.hooks.add("after-tokenize", function(n) {
    n.language !== "markdown" && n.language !== "md" || function t(i) {
      if (i && typeof i != "string") for (var d = 0, b = i.length; d < b; d++) {
        var l = i[d];
        if (l.type === "code") {
          var u = l.content[1], a = l.content[3];
          if (u && a && u.type === "code-language" && a.type === "code-block" && typeof u.content == "string") {
            var o = u.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r = "language-" + (o = (/[a-z][\w-]*/i.exec(o) || [""])[0].toLowerCase());
            a.alias ? typeof a.alias == "string" ? a.alias = [a.alias, r] : a.alias.push(r) : a.alias = [r];
          }
        } else t(l.content);
      }
    }(n.tokens);
  }), e.hooks.add("wrap", function(n) {
    if (n.type === "code-block") {
      for (var t = "", i = 0, d = n.classes.length; i < d; i++) {
        var b = n.classes[i], l = /language-(.+)/.exec(b);
        if (l) {
          t = l[1];
          break;
        }
      }
      var u = e.languages[t];
      if (u) n.content = e.highlight(n.content.replace(h, "").replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(o, r) {
        var k;
        return (r = r.toLowerCase())[0] === "#" ? (k = r[1] === "x" ? parseInt(r.slice(2), 16) : Number(r.slice(1)), f(k)) : m[r] || o;
      }), u, t);
      else if (t && t !== "none" && e.plugins.autoloader) {
        var a = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random());
        n.attributes.id = a, e.plugins.autoloader.loadLanguages(t, function() {
          var o = document.getElementById(a);
          o && (o.innerHTML = e.highlight(o.textContent, e.languages[t], t));
        });
      }
    }
  });
  var h = RegExp(e.languages.markup.tag.pattern.source, "gi"), m = { amp: "&", lt: "<", gt: ">", quot: '"' }, f = String.fromCodePoint || String.fromCharCode;
  e.languages.md = e.languages.markdown;
})(Prism);
//# sourceMappingURL=prism-markdown.min-C0Qn0m-5-YBENOCJN.js.map
